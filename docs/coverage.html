
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>jrp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yanosea/jrp/v2/app/application/jrp/download_usecase.go (100.0%)</option>
				
				<option value="file1">github.com/yanosea/jrp/v2/app/application/jrp/favorite_usecase.go (100.0%)</option>
				
				<option value="file2">github.com/yanosea/jrp/v2/app/application/jrp/generate_jrp_usecase.go (100.0%)</option>
				
				<option value="file3">github.com/yanosea/jrp/v2/app/application/jrp/get_history_usecase.go (100.0%)</option>
				
				<option value="file4">github.com/yanosea/jrp/v2/app/application/jrp/get_version_usecase.go (100.0%)</option>
				
				<option value="file5">github.com/yanosea/jrp/v2/app/application/jrp/remove_history_usecase.go (100.0%)</option>
				
				<option value="file6">github.com/yanosea/jrp/v2/app/application/jrp/save_history_usecase.go (100.0%)</option>
				
				<option value="file7">github.com/yanosea/jrp/v2/app/application/jrp/search_history_usecase.go (100.0%)</option>
				
				<option value="file8">github.com/yanosea/jrp/v2/app/application/jrp/unfavorite_usecase.go (100.0%)</option>
				
				<option value="file9">github.com/yanosea/jrp/v2/app/application/wnjpn/fetch_words_usecase.go (100.0%)</option>
				
				<option value="file10">github.com/yanosea/jrp/v2/app/config/config.go (100.0%)</option>
				
				<option value="file11">github.com/yanosea/jrp/v2/app/domain/jrp/history/history_model.go (100.0%)</option>
				
				<option value="file12">github.com/yanosea/jrp/v2/app/infrastructure/database/connection.go (100.0%)</option>
				
				<option value="file13">github.com/yanosea/jrp/v2/app/infrastructure/database/connection_manager.go (100.0%)</option>
				
				<option value="file14">github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository/history_repository.go (100.0%)</option>
				
				<option value="file15">github.com/yanosea/jrp/v2/app/infrastructure/wnjpn/query_service/word_query_service.go (100.0%)</option>
				
				<option value="file16">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/config/config.go (100.0%)</option>
				
				<option value="file17">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/formatter/formatter.go (100.0%)</option>
				
				<option value="file18">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/formatter/json.go (100.0%)</option>
				
				<option value="file19">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/main.go (100.0%)</option>
				
				<option value="file20">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/server/jrp/get.go (100.0%)</option>
				
				<option value="file21">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/server/route.go (100.0%)</option>
				
				<option value="file22">github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/server/server.go (100.0%)</option>
				
				<option value="file23">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/command.go (87.2%)</option>
				
				<option value="file24">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion/bash.go (100.0%)</option>
				
				<option value="file25">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion/completion.go (100.0%)</option>
				
				<option value="file26">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion/fish.go (100.0%)</option>
				
				<option value="file27">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion/powershell.go (100.0%)</option>
				
				<option value="file28">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion/zsh.go (100.0%)</option>
				
				<option value="file29">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/download.go (100.0%)</option>
				
				<option value="file30">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/favorite.go (100.0%)</option>
				
				<option value="file31">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/generate/generate.go (100.0%)</option>
				
				<option value="file32">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/generate/interactive.go (89.7%)</option>
				
				<option value="file33">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history/clear.go (100.0%)</option>
				
				<option value="file34">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history/history.go (100.0%)</option>
				
				<option value="file35">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history/remove.go (100.0%)</option>
				
				<option value="file36">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history/search.go (100.0%)</option>
				
				<option value="file37">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history/show.go (100.0%)</option>
				
				<option value="file38">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/unfavorite.go (100.0%)</option>
				
				<option value="file39">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/version.go (100.0%)</option>
				
				<option value="file40">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/root.go (100.0%)</option>
				
				<option value="file41">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/config/config.go (100.0%)</option>
				
				<option value="file42">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter/formatter.go (100.0%)</option>
				
				<option value="file43">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter/plain.go (100.0%)</option>
				
				<option value="file44">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter/table.go (100.0%)</option>
				
				<option value="file45">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/main.go (100.0%)</option>
				
				<option value="file46">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter/keyboard.go (100.0%)</option>
				
				<option value="file47">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter/presenter.go (100.0%)</option>
				
				<option value="file48">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter/prompt.go (100.0%)</option>
				
				<option value="file49">github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter/spinner.go (100.0%)</option>
				
				<option value="file50">github.com/yanosea/jrp/v2/docs/docs.go (0.0%)</option>
				
				<option value="file51">github.com/yanosea/jrp/v2/pkg/utility/capture.go (91.7%)</option>
				
				<option value="file52">github.com/yanosea/jrp/v2/pkg/utility/download_util.go (100.0%)</option>
				
				<option value="file53">github.com/yanosea/jrp/v2/pkg/utility/file_util.go (100.0%)</option>
				
				<option value="file54">github.com/yanosea/jrp/v2/pkg/utility/json_util.go (100.0%)</option>
				
				<option value="file55">github.com/yanosea/jrp/v2/pkg/utility/keyboard_util.go (100.0%)</option>
				
				<option value="file56">github.com/yanosea/jrp/v2/pkg/utility/prompt_util.go (100.0%)</option>
				
				<option value="file57">github.com/yanosea/jrp/v2/pkg/utility/rand_util.go (100.0%)</option>
				
				<option value="file58">github.com/yanosea/jrp/v2/pkg/utility/spinner_util.go (100.0%)</option>
				
				<option value="file59">github.com/yanosea/jrp/v2/pkg/utility/strings_util.go (100.0%)</option>
				
				<option value="file60">github.com/yanosea/jrp/v2/pkg/utility/tablewriter_util.go (100.0%)</option>
				
				<option value="file61">github.com/yanosea/jrp/v2/pkg/utility/version_util.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package jrp

import (
        "errors"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// downloadUseCase is a struct that contains the use case of the download.
type downloadUseCase struct{}

// NewDownloadUseCase returns a new instance of the DownloadUseCase struct.
func NewDownloadUseCase() *downloadUseCase <span class="cov8" title="1">{
        return &amp;downloadUseCase{}
}</span>

var (
        // Du is a variable that contains the DownloadUtil struct for injecting dependencies in testing.
        Du = utility.NewDownloadUtil(
                proxy.NewHttp(),
        )
        // Fu is a variable that contains the FileUtil struct for injecting dependencies in testing.
        Fu = utility.NewFileUtil(
                proxy.NewGzip(),
                proxy.NewIo(),
                proxy.NewOs(),
        )
)

// Run returns the output of the DownloadUseCase.
func (uc *downloadUseCase) Run(wnJpnDBPath string) error <span class="cov8" title="1">{
        var deferErr error
        if Fu.IsExist(wnJpnDBPath) </span><span class="cov8" title="1">{
                return errors.New("wnjpn.db already exists")
        }</span>

        <span class="cov8" title="1">resp, err := Du.Download(
                "https://github.com/bond-lab/wnja/releases/download/v1.1/wnjpn.db.gz",
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = resp.Close()
        }</span>()

        <span class="cov8" title="1">tempFilePath, err := Fu.SaveToTempFile(resp.GetBody(), "wnjpn.db.gz")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = Fu.RemoveAll(tempFilePath)
        }</span>()

        <span class="cov8" title="1">if err := Fu.ExtractGzFile(tempFilePath, wnJpnDBPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return deferErr</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package jrp

import (
        "context"
        "errors"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// favoriteUseCase is a struct that contains the use case of the favoriting jrp from the table history in jrp sqlite database.
type favoriteUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewFavoriteUseCase returns a new instance of the FavoriteUseCase struct.
func NewFavoriteUseCase(
        historyRepo historyDomain.HistoryRepository,
) *favoriteUseCase <span class="cov8" title="1">{
        return &amp;favoriteUseCase{
                historyRepo: historyRepo,
        }
}</span>

// Run returns the output of the AddFavorite usecase.
func (uc *favoriteUseCase) Run(ctx context.Context, ids []int, all bool) error <span class="cov8" title="1">{
        var rowsAffected int
        var err error
        if all </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.UpdateIsFavoritedByIsFavoritedIs(ctx, 1, 0)
        }</span> else<span class="cov8" title="1"> {
                rowsAffected, err = uc.historyRepo.UpdateIsFavoritedByIdIn(ctx, 1, ids)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("no histories to favorite")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package jrp

import (
        "time"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// generateJrpUseCase is a struct that contains the use case of the generation jrp.
type generateJrpUseCase struct{}

// NewGenerateJrpUseCase returns a new instance of the GenerateJrpUseCase struct.
func NewGenerateJrpUseCase() *generateJrpUseCase <span class="cov8" title="1">{
        return &amp;generateJrpUseCase{}
}</span>

// GenerateJrpUseCaseInputDto is a DTO struct that contains the input data of the GenerateJrpUseCase.
type GenerateJrpUseCaseInputDto struct {
        WordID int
        Lang   string
        Lemma  string
        Pron   string
        Pos    string
}

// GenerateJrpUseCaseOutputDto is a DTO struct that contains the output data of the GenerateJrpUseCase.
type GenerateJrpUseCaseOutputDto struct {
        ID          int
        Phrase      string
        Prefix      string
        Suffix      string
        IsFavorited int
        CreatedAt   time.Time
        UpdatedAt   time.Time
}

var (
        // ru is a variable that contains the RandUtil struct for injecting dependencies in testing.
        ru = utility.NewRandUtil(proxy.NewRand())
)

// RunWithPrefix generates a jrp with the given prefix.
func (uc *generateJrpUseCase) RunWithPrefix(
        dtos []*GenerateJrpUseCaseInputDto,
        prefix string,
) *GenerateJrpUseCaseOutputDto <span class="cov8" title="1">{
        if len(dtos) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">now := time.Now()
        maxAttempts := len(dtos)

        var jrp *GenerateJrpUseCaseOutputDto = nil
        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov8" title="1">{
                randomSuffix := dtos[ru.GenerateRandomNumber(len(dtos))]
                if randomSuffix.Pos != "n" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">jrp = &amp;GenerateJrpUseCaseOutputDto{
                        ID:          0,
                        Phrase:      prefix + randomSuffix.Lemma,
                        Prefix:      prefix,
                        Suffix:      "",
                        IsFavorited: 0,
                        CreatedAt:   now,
                        UpdatedAt:   now,
                }
                break</span>
        }

        <span class="cov8" title="1">return jrp</span>
}

// RunWithSuffix generates a jrp with the given suffix.
func (uc *generateJrpUseCase) RunWithSuffix(
        dtos []*GenerateJrpUseCaseInputDto,
        suffix string,
) *GenerateJrpUseCaseOutputDto <span class="cov8" title="1">{
        if len(dtos) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">now := time.Now()
        maxAttempts := len(dtos)

        var jrp *GenerateJrpUseCaseOutputDto = nil
        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov8" title="1">{
                randomPrefix := dtos[ru.GenerateRandomNumber(len(dtos))]
                if randomPrefix.Pos != "a" &amp;&amp; randomPrefix.Pos != "v" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">jrp = &amp;GenerateJrpUseCaseOutputDto{
                        ID:          0,
                        Phrase:      randomPrefix.Lemma + suffix,
                        Prefix:      "",
                        Suffix:      suffix,
                        IsFavorited: 0,
                        CreatedAt:   now,
                        UpdatedAt:   now,
                }
                break</span>
        }

        <span class="cov8" title="1">return jrp</span>
}

// RunWithRandom generates a jrp with random prefix and suffix.
func (uc *generateJrpUseCase) RunWithRandom(
        dtos []*GenerateJrpUseCaseInputDto,
) *GenerateJrpUseCaseOutputDto <span class="cov8" title="1">{
        if len(dtos) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">now := time.Now()
        maxAttempts := len(dtos)

        var jrp *GenerateJrpUseCaseOutputDto = nil
        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov8" title="1">{
                indexForPrefix := ru.GenerateRandomNumber(len(dtos))
                indexForSuffix := ru.GenerateRandomNumber(len(dtos))

                randomPrefix := dtos[indexForPrefix]
                if randomPrefix.Pos != "a" &amp;&amp; randomPrefix.Pos != "v" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">randomSuffix := dtos[indexForSuffix]
                if randomSuffix.Pos != "n" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">jrp = &amp;GenerateJrpUseCaseOutputDto{
                        ID:          0,
                        Phrase:      randomPrefix.Lemma + randomSuffix.Lemma,
                        Prefix:      "",
                        Suffix:      "",
                        IsFavorited: 0,
                        CreatedAt:   now,
                        UpdatedAt:   now,
                }
                break</span>
        }

        <span class="cov8" title="1">return jrp</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package jrp

import (
        "context"
        "time"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// getHistoryUseCase is a struct that contains the use case of the getting jrp from the table history in jrp sqlite database.
type getHistoryUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewGetHistoryUseCase returns a new instance of the GetHistoryUseCase struct.
func NewGetHistoryUseCase(
        historyRepo historyDomain.HistoryRepository,
) *getHistoryUseCase <span class="cov8" title="1">{
        return &amp;getHistoryUseCase{
                historyRepo: historyRepo,
        }
}</span>

// GetHistoryUseCaseOutputDto is a DTO struct that contains the output data of the GetHistoryUseCase.
type GetHistoryUseCaseOutputDto struct {
        // ID is the identifier of the phrase.
        ID int
        // Phrase is the generated phrase.
        Phrase string
        // Prefix is the prefix when the phrase is generated.
        Prefix string
        // Suffix is the suffix when the phrase is generated.
        Suffix string
        // IsFavorited is the flag to indicate whether the phrase is favorited.
        IsFavorited int
        // CreatedAt is the timestamp when the phrase is created.
        CreatedAt time.Time
        // UpdatedAt is the timestamp when the phrase is updated.
        UpdatedAt time.Time
}

// Run returns the output of the GetHistoryUseCase.
func (uc *getHistoryUseCase) Run(ctx context.Context, all bool, favorited bool, number int) ([]*GetHistoryUseCaseOutputDto, error) <span class="cov8" title="1">{
        var histories []*historyDomain.History
        var err error
        if all &amp;&amp; favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindByIsFavoritedIs(ctx, 1)
        }</span> else<span class="cov8" title="1"> if all &amp;&amp; !favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindAll(ctx)
        }</span> else<span class="cov8" title="1"> if !all &amp;&amp; favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindTopNByIsFavoritedIsAndByOrderByIdAsc(ctx, number, 1)
        }</span> else<span class="cov8" title="1"> {
                histories, err = uc.historyRepo.FindTopNByOrderByIdAsc(ctx, number)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ucDtos []*GetHistoryUseCaseOutputDto
        for _, history := range histories </span><span class="cov8" title="1">{
                ucDtos = append(ucDtos, &amp;GetHistoryUseCaseOutputDto{
                        ID:          history.ID,
                        Phrase:      history.Phrase,
                        Prefix:      history.Prefix.String,
                        Suffix:      history.Suffix.String,
                        IsFavorited: history.IsFavorited,
                        CreatedAt:   history.CreatedAt,
                        UpdatedAt:   history.UpdatedAt,
                })
        }</span>

        <span class="cov8" title="1">return ucDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package jrp

import ()

// getVersionUseCase is a struct that contains the use case of getting the version.
type getVersionUseCase struct{}

// NewGetVersionUseCase returns a new instance of the GetVersionUseCase struct.
func NewGetVersionUseCase() *getVersionUseCase <span class="cov8" title="1">{
        return &amp;getVersionUseCase{}
}</span>

// GetVersionUseCaseOutputDto is a DTO struct that contains the output data of the GetVersionUseCase.
type GetVersionUseCaseOutputDto struct {
        Version string
}

// Run returns the output of the GetVersionUseCase.
func (uc *getVersionUseCase) Run(version string) *GetVersionUseCaseOutputDto <span class="cov8" title="1">{
        return &amp;GetVersionUseCaseOutputDto{
                Version: version,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package jrp

import (
        "context"
        "errors"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// removeHistoryUseCase is a struct that contains the use case of the removing jrp from the table history in jrp sqlite database.
type removeHistoryUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewRemoveHistoryUseCase returns a new instance of the RemoveHistoryUseCase struct.
func NewRemoveHistoryUseCase(
        historyRepo historyDomain.HistoryRepository,
) *removeHistoryUseCase <span class="cov8" title="1">{
        return &amp;removeHistoryUseCase{
                historyRepo: historyRepo,
        }
}</span>

// Run returns the output of the RemoveHistoryUseCase.
func (uc *removeHistoryUseCase) Run(ctx context.Context, ids []int, all bool, force bool) error <span class="cov8" title="1">{
        var rowsAffected int
        var err error
        if all &amp;&amp; force </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.DeleteAll(ctx)
        }</span> else<span class="cov8" title="1"> if all &amp;&amp; !force </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.DeleteByIsFavoritedIs(ctx, 0)
        }</span> else<span class="cov8" title="1"> if !all &amp;&amp; force </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.DeleteByIdIn(ctx, ids)
        }</span> else<span class="cov8" title="1"> if !all &amp;&amp; !force </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.DeleteByIdInAndIsFavoritedIs(ctx, ids, 0)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("no histories to remove")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package jrp

import (
        "context"
        "time"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// saveHistoryUseCase is a struct that contains the use case of the saving jrp to the table history in jrp sqlite database.
type saveHistoryUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewSaveHistoryUseCase returns a new instance of the SaveHistoryUseCase struct.
func NewSaveHistoryUseCase(
        historyRepo historyDomain.HistoryRepository,
) *saveHistoryUseCase <span class="cov8" title="1">{
        return &amp;saveHistoryUseCase{
                historyRepo: historyRepo,
        }
}</span>

// SaveHistoryUseCaseInputDto is a DTO struct that contains the output data of the SaveHistoryUseCase.
type SaveHistoryUseCaseInputDto struct {
        // Phrase is the generated phrase.
        Phrase string
        // Prefix is the prefix when the phrase is generated.
        Prefix string
        // Suffix is the suffix when the phrase is generated.
        Suffix string
        // IsFavorited is the flag to indicate whether the phrase is favorited.
        IsFavorited int
        // CreatedAt is the timestamp when the phrase is created.
        CreatedAt time.Time
        // UpdatedAt is the timestamp when the phrase is updated.
        UpdatedAt time.Time
}

// SaveHistoryUseCaseOutputDto is a DTO struct that contains the output data of the SaveHistoryUseCase.
type SaveHistoryUseCaseOutputDto struct {
        // ID is the identifier of the phrase.
        ID int
        // Phrase is the generated phrase.
        Phrase string
        // Prefix is the prefix when the phrase is generated.
        Prefix string
        // Suffix is the suffix when the phrase is generated.
        Suffix string
        // IsFavorited is the flag to indicate whether the phrase is favorited.
        IsFavorited int
        // CreatedAt is the timestamp when the phrase is created.
        CreatedAt time.Time
        // UpdatedAt is the timestamp when the phrase is updated.
        UpdatedAt time.Time
}

// Run returns the output of the SaveHistoryUseCase.
func (uc *saveHistoryUseCase) Run(ctx context.Context, inputDtos []*SaveHistoryUseCaseInputDto) ([]*SaveHistoryUseCaseOutputDto, error) <span class="cov8" title="1">{
        var histories []*historyDomain.History
        for _, dto := range inputDtos </span><span class="cov8" title="1">{
                history := historyDomain.NewHistory(
                        dto.Phrase,
                        dto.Prefix,
                        dto.Suffix,
                        dto.IsFavorited,
                        dto.CreatedAt,
                        dto.UpdatedAt,
                )
                histories = append(histories, history)
        }</span>

        <span class="cov8" title="1">histories, err := uc.historyRepo.SaveAll(ctx, histories)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var outputDtos []*SaveHistoryUseCaseOutputDto
        for _, history := range histories </span><span class="cov8" title="1">{
                outputDto := &amp;SaveHistoryUseCaseOutputDto{
                        ID:          history.ID,
                        Phrase:      history.Phrase,
                        Prefix:      history.Prefix.String,
                        Suffix:      history.Suffix.String,
                        IsFavorited: history.IsFavorited,
                        CreatedAt:   history.CreatedAt,
                        UpdatedAt:   history.UpdatedAt,
                }
                outputDtos = append(outputDtos, outputDto)
        }</span>

        <span class="cov8" title="1">return outputDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package jrp

import (
        "context"
        "time"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// searchHistoryUseCase is a struct that contains the use case of the searching jrp from the table history in jrp sqlite database.
type searchHistoryUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewSearchHistoryUseCase returns a new instance of the SearchHistoryUseCase struct.
func NewSearchHistoryUseCase(
        historyRepo historyDomain.HistoryRepository,
) *searchHistoryUseCase <span class="cov8" title="1">{
        return &amp;searchHistoryUseCase{
                historyRepo: historyRepo,
        }
}</span>

// SearchHistoryUseCaseOutputDto is a DTO struct that contains the output data of the SearchHistoryUseCase.
type SearchHistoryUseCaseOutputDto struct {
        // ID is the identifier of the phrase.
        ID int
        // Phrase is the generated phrase.
        Phrase string
        // Prefix is the prefix when the phrase is generated.
        Prefix string
        // Suffix is the suffix when the phrase is generated.
        Suffix string
        // IsFavorited is the flag to indicate whether the phrase is favorited.
        IsFavorited int
        // CreatedAt is the timestamp when the phrase is created.
        CreatedAt time.Time
        // UpdatedAt is the timestamp when the phrase is updated.
        UpdatedAt time.Time
}

// Run returns the output of the SearchHistoryUseCase.
func (uc *searchHistoryUseCase) Run(ctx context.Context, keywords []string, and bool, all bool, favorited bool, number int) ([]*SearchHistoryUseCaseOutputDto, error) <span class="cov8" title="1">{
        var histories []*historyDomain.History
        var err error
        if all &amp;&amp; favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindByIsFavoritedIsAndPhraseContains(ctx, keywords, and, 1)
        }</span> else<span class="cov8" title="1"> if all &amp;&amp; !favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindByPhraseContains(ctx, keywords, and)
        }</span> else<span class="cov8" title="1"> if !all &amp;&amp; favorited </span><span class="cov8" title="1">{
                histories, err = uc.historyRepo.FindTopNByIsFavoritedIsAndByPhraseContainsOrderByIdAsc(ctx, keywords, and, number, 1)
        }</span> else<span class="cov8" title="1"> {
                histories, err = uc.historyRepo.FindTopNByPhraseContainsOrderByIdAsc(ctx, keywords, and, number)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ucDtos []*SearchHistoryUseCaseOutputDto
        for _, h := range histories </span><span class="cov8" title="1">{
                ucDtos = append(ucDtos, &amp;SearchHistoryUseCaseOutputDto{
                        ID:          h.ID,
                        Phrase:      h.Phrase,
                        Prefix:      h.Prefix.String,
                        Suffix:      h.Suffix.String,
                        IsFavorited: h.IsFavorited,
                        CreatedAt:   h.CreatedAt,
                        UpdatedAt:   h.UpdatedAt,
                })
        }</span>

        <span class="cov8" title="1">return ucDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package jrp

import (
        "context"
        "errors"

        historyDomain "github.com/yanosea/jrp/v2/app/domain/jrp/history"
)

// unfavoriteUseCase is a struct that contains the use case of the unfavoriting jrp from the table history in jrp sqlite database.
type unfavoriteUseCase struct {
        historyRepo historyDomain.HistoryRepository
}

// NewUnfavoriteUseCase returns a new instance of the UnfavoriteUseCase struct.
func NewUnfavoriteUseCase(
        historyRepo historyDomain.HistoryRepository,
) *unfavoriteUseCase <span class="cov8" title="1">{
        return &amp;unfavoriteUseCase{
                historyRepo: historyRepo,
        }
}</span>

// Run returns the output of the Unfavorite usecase.
func (uc *unfavoriteUseCase) Run(ctx context.Context, ids []int, all bool) error <span class="cov8" title="1">{
        var rowsAffected int
        var err error
        if all </span><span class="cov8" title="1">{
                rowsAffected, err = uc.historyRepo.UpdateIsFavoritedByIsFavoritedIs(ctx, 0, 1)
        }</span> else<span class="cov8" title="1"> {
                rowsAffected, err = uc.historyRepo.UpdateIsFavoritedByIdIn(ctx, 0, ids)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("no favorited histories to unfavorite")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package wnjpn

import (
        "context"
)

// FetchWordsUseCase is an interface that defines the use case of fetching words.
type FetchWordsUseCase interface {
        Run(ctx context.Context, lang string, pos []string) ([]*FetchWordsUseCaseOutputDto, error)
}

// FetchWordsUseCaseStruct is a struct that implements the FetchWordsUseCase interface.
type FetchWordsUseCaseStruct struct {
        wordQueryService WordQueryService
}

var (
        // NewFetchWordsUseCase is a function that returns a new instance of the fetchWordsUseCase struct.
        NewFetchWordsUseCase = newFetchWordsUseCase
)

// newFetchWordsUseCase returns a new instance of the fetchWordsUseCase struct.
func newFetchWordsUseCase(
        wordQueryService WordQueryService,
) *FetchWordsUseCaseStruct <span class="cov8" title="1">{
        return &amp;FetchWordsUseCaseStruct{
                wordQueryService: wordQueryService,
        }
}</span>

// FetchWordsUseCaseOutputDto is a DTO struct that contains the output data of the FetchWordsUseCase.
type FetchWordsUseCaseOutputDto struct {
        WordID int
        Lang   string
        Lemma  string
        Pron   string
        Pos    string
}

// Run returns the output of the FetchWordsUseCase.
func (uc *FetchWordsUseCaseStruct) Run(ctx context.Context, lang string, pos []string) ([]*FetchWordsUseCaseOutputDto, error) <span class="cov8" title="1">{
        qsDtos, err := uc.wordQueryService.FindByLangIsAndPosIn(ctx, lang, pos)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ucDtos []*FetchWordsUseCaseOutputDto
        for _, qsDto := range qsDtos </span><span class="cov8" title="1">{
                ucDtos = append(ucDtos, &amp;FetchWordsUseCaseOutputDto{
                        WordID: qsDto.WordID,
                        Lang:   qsDto.Lang.String,
                        Lemma:  qsDto.Lemma.String,
                        Pron:   qsDto.Pron.String,
                        Pos:    qsDto.Pos.String,
                })
        }</span>

        <span class="cov8" title="1">return ucDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "github.com/yanosea/jrp/v2/app/infrastructure/database"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// Configurator is an interface that gets the configuration.
type Configurator interface {
        GetConfig() (*JrpConfig, error)
}

// BaseConfigurator is a struct that implements the Configurator interface.
type BaseConfigurator struct {
        Envconfig proxy.Envconfig
        FileUtil  utility.FileUtil
}

// JrpConfig is a struct that contains the configuration of the Jrp application.
type JrpConfig struct {
        WNJpnDBType database.DBType
        WNJpnDBDsn  string
}

// GetConfig gets the configuration of the Jrp application.
func NewConfigurator(
        envconfigProxy proxy.Envconfig,
        fileUtil utility.FileUtil,
) *BaseConfigurator <span class="cov8" title="1">{
        return &amp;BaseConfigurator{
                Envconfig: envconfigProxy,
                FileUtil:  fileUtil,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package history

import (
        "database/sql"
        "time"
)

// History is a struct that represents history table in the jrp database.
type History struct {
        // ID is the primary key of the history table.
        ID int
        // Phrase is the generated phrase.
        Phrase string
        // Prefix is the prefix when the phrase is generated.
        Prefix sql.NullString
        // Suffix is the suffix when the phrase is generated.
        Suffix sql.NullString
        // IsFavorited is the flag to indicate whether the phrase is favorited.
        IsFavorited int
        // CreatedAt is the timestamp when the phrase is created.
        CreatedAt time.Time
        // UpdatedAt is the timestamp when the phrase is updated.
        UpdatedAt time.Time
}

// NewHistory returns a new instance of the History struct.
func NewHistory(
        phrase string,
        prefix string,
        suffix string,
        isFavorited int,
        createdAt time.Time,
        updatedAt time.Time,
) *History <span class="cov8" title="1">{
        return &amp;History{
                Phrase:      phrase,
                Prefix:      sql.NullString{String: prefix, Valid: prefix != ""},
                Suffix:      sql.NullString{String: suffix, Valid: suffix != ""},
                IsFavorited: isFavorited,
                CreatedAt:   createdAt,
                UpdatedAt:   updatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "sync"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// DBConnection is an interface that contains the database connection.
type DBConnection interface {
        Close() error
        Open() (proxy.DB, error)
}

// dbConnection is a struct that contains the database connection.
type dbConnection struct {
        sql            proxy.Sql
        db             proxy.DB
        driverName     string
        dataSourceName string
        mutex          *sync.RWMutex
}

// Close closes the database connection.
func (c *dbConnection) Close() error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if c.db != nil </span><span class="cov8" title="1">{
                err := c.db.Close()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">c.db = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Open opens the database connection.
func (c *dbConnection) Open() (proxy.DB, error) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if c.db != nil </span><span class="cov8" title="1">{
                return c.db, nil
        }</span>

        <span class="cov8" title="1">db, err := c.sql.Open(c.driverName, c.dataSourceName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.db = db
        return c.db, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "errors"
        "sync"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

var (
        // gcm is a global connection manager.
        gcm ConnectionManager
        // gmutex is a global mutex.
        gmutex = &amp;sync.Mutex{}
        // GetConnectionManagerFunc is a function to get the connection manager.
        GetConnectionManagerFunc = getConnectionManager
)

// ConnectionManager is an interface that manages database connections.
type ConnectionManager interface {
        CloseAllConnections() error
        CloseConnection(which DBName) error
        GetConnection(which DBName) (DBConnection, error)
        InitializeConnection(config ConnectionConfig) error
}

// connectionManager is a struct that implements the ConnectionManager interface.
type connectionManager struct {
        sql         proxy.Sql
        connections map[DBName]DBConnection
        mutex       *sync.RWMutex
}

// NewConnectionManager initializes the connection manager.
func NewConnectionManager(sql proxy.Sql) ConnectionManager <span class="cov8" title="1">{
        gmutex.Lock()
        defer gmutex.Unlock()

        if gcm == nil </span><span class="cov8" title="1">{
                gcm = &amp;connectionManager{
                        sql:         sql,
                        connections: make(map[DBName]DBConnection),
                        mutex:       &amp;sync.RWMutex{},
                }
        }</span>

        <span class="cov8" title="1">return gcm</span>
}

// GetConnectionManager gets the connection manager.
func GetConnectionManager() ConnectionManager <span class="cov8" title="1">{
        return GetConnectionManagerFunc()
}</span>

// getConnectionManager gets the connection manager.
func getConnectionManager() ConnectionManager <span class="cov8" title="1">{
        gmutex.Lock()
        defer gmutex.Unlock()

        if gcm == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return gcm</span>
}

// ResetConnectionManager resets the connection manager.
func ResetConnectionManager() error <span class="cov8" title="1">{
        gmutex.Lock()
        defer gmutex.Unlock()

        if gcm == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := gcm.CloseAllConnections(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> {
                gcm = nil
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CloseAllConnections closes all database connections.
func (cm *connectionManager) CloseAllConnections() error <span class="cov8" title="1">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        for dbType, conn := range cm.connections </span><span class="cov8" title="1">{
                if err := conn.Close(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">delete(cm.connections, dbType)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CloseConnection closes the database connection.
func (cm *connectionManager) CloseConnection(dbType DBName) error <span class="cov8" title="1">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        if conn, exists := cm.connections[dbType]; exists </span><span class="cov8" title="1">{
                if err := conn.Close(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">delete(cm.connections, dbType)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConnection gets the database connection.
func (cm *connectionManager) GetConnection(dbType DBName) (DBConnection, error) <span class="cov8" title="1">{
        cm.mutex.RLock()
        conn, exists := cm.connections[dbType]
        cm.mutex.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("connection not initialized")
        }</span>

        <span class="cov8" title="1">return conn, nil</span>
}

// InitializeConnectionManager initializes the connection manager.
func (cm *connectionManager) InitializeConnection(config ConnectionConfig) error <span class="cov8" title="1">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        if _, exists := cm.connections[config.DBName]; exists </span><span class="cov8" title="1">{
                return errors.New("connection already initialized")
        }</span>

        <span class="cov8" title="1">cm.connections[config.DBName] = &amp;dbConnection{
                sql:            cm.sql,
                db:             nil,
                driverName:     string(config.DBType),
                dataSourceName: config.DSN,
                mutex:          &amp;sync.RWMutex{},
        }

        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "github.com/yanosea/jrp/v2/app/domain/jrp/history"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// HistoryRepository is a struct that implements the HistoryRepository interface.
type historyRepository struct {
        connManager database.ConnectionManager
}

// NewHistoryRepository returns a new instance of the historyRepository struct.
func NewHistoryRepository() history.HistoryRepository <span class="cov8" title="1">{
        return &amp;historyRepository{
                connManager: database.GetConnectionManager(),
        }
}</span>

// DeleteAll is a method that removes all the jrps from the history table.
func (h *historyRepository) DeleteAll(ctx context.Context) (int, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">tx, err := db.BeginTx(
                ctx,
                &amp;sql.TxOptions{
                        Isolation: sql.LevelSerializable,
                        ReadOnly:  false,
                },
        )
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = tx.Rollback()
        }</span>()

        <span class="cov8" title="1">var result proxy.Result
        if result, err = tx.ExecContext(ctx, DeleteAllQuery); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if _, err := tx.ExecContext(ctx, DeleteSequenceQuery); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// DeleteByIdIn is a method that removes the jrps from the history table by ID in.
func (h *historyRepository) DeleteByIdIn(ctx context.Context, ids []int) (int, error) <span class="cov8" title="1">{
        var deferErr error
        if len(ids) == 0 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(ids))
        for _, id := range ids </span><span class="cov8" title="1">{
                args = append(args, id)
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(DeleteByIdInQuery, strings.Trim(strings.Repeat("?,", len(ids)), ","))

        var result proxy.Result
        if result, err = db.ExecContext(ctx, query, args...); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// DeleteByIdInAndIsFavoritedIs is a method that removes the jrps from the history table by ID in and is favorited is.
func (h *historyRepository) DeleteByIdInAndIsFavoritedIs(
        ctx context.Context,
        ids []int,
        isFavorited int,
) (int, error) <span class="cov8" title="1">{
        var deferErr error
        if len(ids) == 0 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">placeholders := make([]string, len(ids))
        for i := range placeholders </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(DeleteByIdInAndIsFavoritedIsQuery, strings.Join(placeholders, ","))
        args := make([]interface{}, len(ids)+1)
        for i, id := range ids </span><span class="cov8" title="1">{
                args[i] = id
        }</span>
        <span class="cov8" title="1">args[len(ids)] = isFavorited

        var result proxy.Result
        if result, err = db.ExecContext(ctx, query, args...); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// DeleteByIsFavoritedIs is a method that removes the jrps from the history table by is favorited.
func (h *historyRepository) DeleteByIsFavoritedIs(ctx context.Context, isFavorited int) (int, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">var result proxy.Result
        if result, err = db.ExecContext(ctx, DeleteByIsFavoritedIsQuery, isFavorited); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// FindAll is a method that finds all the jrps from the history table.
func (h *historyRepository) FindAll(ctx context.Context) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := db.QueryContext(ctx, FindAllQuery)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindByIsFavoritedIs is a method that finds the jrps from the history table by is favorited.
func (h *historyRepository) FindByIsFavoritedIs(ctx context.Context, isFavorited int) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := db.QueryContext(ctx, FindByIsFavoritedIsQuery, isFavorited)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindByIsFavoritedIsAndPhraseContains is a method that finds the jrps from the history table by is favorited and phrase contains.
func (h *historyRepository) FindByIsFavoritedIsAndPhraseContains(
        ctx context.Context,
        keywords []string,
        and bool,
        isFavorited int,
) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(keywords)+1)
        whereClause := ""
        for i, keyword := range keywords </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        whereClause += "Phrase LIKE ?"
                }</span> else<span class="cov8" title="1"> {
                        if and </span><span class="cov8" title="1">{
                                whereClause += " AND Phrase LIKE ?"
                        }</span> else<span class="cov8" title="1"> {
                                whereClause += " OR Phrase LIKE ?"
                        }</span>
                }
                <span class="cov8" title="1">args = append(args, "%"+keyword+"%")</span>
        }
        <span class="cov8" title="1">args = append(args, isFavorited)
        query := fmt.Sprintf(FindByIsFavoritedIsAndPhraseContainsQuery, whereClause)

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindByPhraseContains is a method that finds the jrps from the history table by phrase contains.
func (h *historyRepository) FindByPhraseContains(
        ctx context.Context,
        keywords []string,
        and bool,
) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(keywords))
        whereClause := ""
        for i, keyword := range keywords </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        whereClause += "Phrase LIKE ?"
                }</span> else<span class="cov8" title="1"> {
                        if and </span><span class="cov8" title="1">{
                                whereClause += " AND Phrase LIKE ?"
                        }</span> else<span class="cov8" title="1"> {
                                whereClause += " OR Phrase LIKE ?"
                        }</span>
                }
                <span class="cov8" title="1">args = append(args, "%"+keyword+"%")</span>
        }
        <span class="cov8" title="1">query := fmt.Sprintf(FindByPhraseContainsQuery, whereClause)

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindTopNByIsFavoritedIsAndByOrderByIdAsc is a method that finds the top N jrps from the history table by is favorited order by ID ascending.
func (h *historyRepository) FindTopNByIsFavoritedIsAndByOrderByIdAsc(
        ctx context.Context,
        number int,
        isFavorited int,
) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := db.QueryContext(ctx, FindTopNByIsFavoritedIsAndByOrderByIdAscQuery, isFavorited, number)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindTopNByIsFavoritedIsAndByPhraseContainsOrderByIdAsc is a method that finds the top N jrps from the history table by is favorited and phrase contains order by ID ascending.
func (h *historyRepository) FindTopNByIsFavoritedIsAndByPhraseContainsOrderByIdAsc(
        ctx context.Context,
        keywords []string,
        and bool,
        number int,
        isFavorited int,
) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(keywords)+2)
        whereClause := ""
        for i, keyword := range keywords </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        whereClause += "Phrase LIKE ?"
                }</span> else<span class="cov8" title="1"> {
                        if and </span><span class="cov8" title="1">{
                                whereClause += " AND Phrase LIKE ?"
                        }</span> else<span class="cov8" title="1"> {
                                whereClause += " OR Phrase LIKE ?"
                        }</span>
                }
                <span class="cov8" title="1">args = append(args, "%"+keyword+"%")</span>
        }
        <span class="cov8" title="1">args = append(args, isFavorited, number)
        query := fmt.Sprintf(FindTopNByIsFavoritedIsAndByPhraseContainsOrderByIdAscQuery, whereClause)

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindTopNByOrderByIdAsc is a method that finds the top N jrps from the history table by order by ID ascending.
func (h *historyRepository) FindTopNByOrderByIdAsc(ctx context.Context, number int) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rows, err := db.QueryContext(ctx, FindTopNByOrderByIdAscQuery, number)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// FindTopNByPhraseContainsOrderByIdAsc is a method that finds the top N jrps from the history table by phrase contains order by ID ascending.
func (h *historyRepository) FindTopNByPhraseContainsOrderByIdAsc(
        ctx context.Context,
        keywords []string,
        and bool,
        number int,
) ([]*history.History, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(keywords)+1)
        whereClause := ""
        for i, keyword := range keywords </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        whereClause += "Phrase LIKE ?"
                }</span> else<span class="cov8" title="1"> {
                        if and </span><span class="cov8" title="1">{
                                whereClause += " AND Phrase LIKE ?"
                        }</span> else<span class="cov8" title="1"> {
                                whereClause += " OR Phrase LIKE ?"
                        }</span>
                }
                <span class="cov8" title="1">args = append(args, "%"+keyword+"%")</span>
        }
        <span class="cov8" title="1">args = append(args, number)
        query := fmt.Sprintf(FindTopNByPhraseContainsOrderByIdAscQuery, whereClause)

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">histories := []*history.History{}
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;history.History{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">histories = append(histories, history)</span>
        }

        <span class="cov8" title="1">return histories, deferErr</span>
}

// SaveAll is a method that saves all the jrp to the history table.
func (h *historyRepository) SaveAll(ctx context.Context, jrps []*history.History) ([]*history.History, error) <span class="cov8" title="1">{
        if len(jrps) == 0 </span><span class="cov8" title="1">{
                return jrps, nil
        }</span>

        <span class="cov8" title="1">valueStrings := make([]string, 0, len(jrps))
        valueArgs := make([]interface{}, 0, len(jrps)*6)

        for _, jrp := range jrps </span><span class="cov8" title="1">{
                valueStrings = append(valueStrings, "(?, ?, ?, ?, ?, ?)")
                valueArgs = append(valueArgs,
                        jrp.Phrase,
                        jrp.Prefix,
                        jrp.Suffix,
                        jrp.IsFavorited,
                        jrp.CreatedAt,
                        jrp.UpdatedAt,
                )
        }</span>

        <span class="cov8" title="1">var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tx, err := db.BeginTx(
                ctx,
                &amp;sql.TxOptions{
                        Isolation: sql.LevelSerializable,
                        ReadOnly:  false,
                },
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = tx.Rollback()
        }</span>()

        <span class="cov8" title="1">query := fmt.Sprintf(InsertQuery, strings.Join(valueStrings, ","))
        result, err := tx.ExecContext(ctx, query, valueArgs...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">lastID, err := result.LastInsertId()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">firstID := lastID - int64(len(jrps)) + 1

        for i, jrp := range jrps </span><span class="cov8" title="1">{
                jrp.ID = int(firstID) + i
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return jrps, deferErr</span>
}

// UpdateIsFavoritedByIdIn is a method that updates the is favorited of the jrps from the history table by ID in.
func (h *historyRepository) UpdateIsFavoritedByIdIn(
        ctx context.Context,
        isFavorited int,
        ids []int,
) (int, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := make([]interface{}, 0, len(ids))
        for _, id := range ids </span><span class="cov8" title="1">{
                args = append(args, id)
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(UpdateIsFavoritedByIdInQuery, strings.Trim(strings.Repeat("?,", len(ids)), ","))

        var result proxy.Result
        if result, err = db.ExecContext(ctx, query, append([]interface{}{isFavorited}, args...)...); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// UpdateIsFavoritedByIsFavoritedIs is a method that updates the is favorited of the jrps from the history table by is favorited is.
func (h *historyRepository) UpdateIsFavoritedByIsFavoritedIs(
        ctx context.Context,
        isFavorited int,
        isFavoritedIs int,
) (int, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := getJrpDB(ctx, h.connManager)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">var result proxy.Result
        if result, err = db.ExecContext(ctx, UpdateIsFavoritedByIsFavoritedIsQuery, isFavorited, isFavoritedIs); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), deferErr</span>
}

// getJrpDB is a function that returns the jrp database connection.
func getJrpDB(ctx context.Context, connManager database.ConnectionManager) (proxy.DB, error) <span class="cov8" title="1">{
        var deferErr error
        conn, err := connManager.GetConnection(database.JrpDB)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">db, err := conn.Open()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if _, err := db.ExecContext(ctx, CreateQuery); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return db, deferErr</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package query_service

import (
        "context"
        "fmt"
        "strings"

        "github.com/yanosea/jrp/v2/app/application/wnjpn"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"
)

// WordQueryService is a struct that implements the WordQueryService interface.
type wordQueryService struct {
        connManager database.ConnectionManager
}

// NewWordQueryService returns a new instance of the WordQueryService struct.
func NewWordQueryService() wnjpn.WordQueryService <span class="cov8" title="1">{
        return &amp;wordQueryService{
                connManager: database.GetConnectionManager(),
        }
}</span>

// FindByLangAndPosIn is a method that fetches words by lang and pos.
func (w *wordQueryService) FindByLangIsAndPosIn(
        ctx context.Context,
        lang string,
        pos []string,
) ([]*wnjpn.FetchWordsDto, error) <span class="cov8" title="1">{
        var deferErr error
        conn, err := w.connManager.GetConnection(database.WNJpnDB)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">db, err := conn.Open()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">placeholders := make([]string, len(pos))
        for i := range pos </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>

        <span class="cov8" title="1">query := fmt.Sprintf(FindByLangIsAndPosInQuery, strings.Join(placeholders, ","))
        params := make([]interface{}, 0, len(pos)+1)
        params = append(params, lang)
        for _, p := range pos </span><span class="cov8" title="1">{
                params = append(params, p)
        }</span>

        <span class="cov8" title="1">rows, err := db.QueryContext(ctx, query, params...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">words := make([]*wnjpn.FetchWordsDto, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                word := &amp;wnjpn.FetchWordsDto{}
                if err := rows.Scan(
                        &amp;word.WordID,
                        &amp;word.Lang,
                        &amp;word.Lemma,
                        &amp;word.Pron,
                        &amp;word.Pos,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">words = append(words, word)</span>
        }

        <span class="cov8" title="1">return words, deferErr</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "path/filepath"
        "strings"

        baseConfig "github.com/yanosea/jrp/v2/app/config"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// JrpServerConfigurator is an interface that gets the configuration of the Jrp server application.
type JrpServerConfigurator interface {
        GetConfig() (*JrpServerConfig, error)
}

// ServerConfigurator is a struct that implements the JrpServerConfigurator interface.
type ServerConfigurator struct {
        *baseConfig.BaseConfigurator
}

// NewJrpServerConfigurator creates a new JrpServerConfigurator.
func NewJrpServerConfigurator(
        envconfigProxy proxy.Envconfig,
        fileUtil utility.FileUtil,
) JrpServerConfigurator <span class="cov8" title="1">{
        return &amp;ServerConfigurator{
                BaseConfigurator: baseConfig.NewConfigurator(
                        envconfigProxy,
                        fileUtil,
                ),
        }
}</span>

// JrpServerConfig is a struct that contains the configuration of the Jrp server application.
type JrpServerConfig struct {
        baseConfig.JrpConfig
        JrpPort string
}

// envConfig is a struct that contains the environment variables.
type envConfig struct {
        JrpPort     string          `envconfig:"JRP_SERVER_PORT" default:"8080"`
        WnJpnDBType database.DBType `envconfig:"JRP_SERVER_WNJPN_DB_TYPE" default:"sqlite"`
        WnJpnDBDsn  string          `envconfig:"JRP_SERVER_WNJPN_DB" default:"XDG_DATA_HOME/jrp/wnjpn.db"`
}

// GetConfig gets the configuration of the Jrp server application.
func (c *ServerConfigurator) GetConfig() (*JrpServerConfig, error) <span class="cov8" title="1">{
        var env envConfig
        if err := c.Envconfig.Process("", &amp;env); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config := &amp;JrpServerConfig{
                JrpConfig: baseConfig.JrpConfig{
                        WNJpnDBType: env.WnJpnDBType,
                        WNJpnDBDsn:  env.WnJpnDBDsn,
                },
                JrpPort: env.JrpPort,
        }

        if config.WNJpnDBType == database.SQLite </span><span class="cov8" title="1">{
                xdgDataHome, err := c.FileUtil.GetXDGDataHome()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">config.WNJpnDBDsn = strings.Replace(
                        config.WNJpnDBDsn,
                        "XDG_DATA_HOME",
                        xdgDataHome,
                        1,
                )
                if err := c.FileUtil.MkdirIfNotExist(
                        filepath.Dir(config.WNJpnDBDsn),
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package formatter

import (
        "errors"
)

// Formatter is an interface that formats the output of jrp cli.
type Formatter interface {
        Format(result interface{}) ([]byte, error)
}

// NewFormatter returns a new instance of the Formatter interface.
func NewFormatter(
        format string,
) (Formatter, error) <span class="cov8" title="1">{
        var f Formatter
        switch format </span>{
        case "json":<span class="cov8" title="1">
                f = NewJsonFormatter()</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("invalid format")</span>
        }
        <span class="cov8" title="1">return f, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package formatter

import (
        "errors"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// JsonFormatter is a struct that formats the output of jrp server.
type JsonFormatter struct{}

// ResponseOutputDto is a struct that represents the response of jrp server.
type ResponseOutputDto struct {
        Body []byte `json:"body"`
}

// @Description response format for jrp
// JrpJsonOutputDto is a struct that represents the output json of jrp server.
type JrpJsonOutputDto struct {
        // @Description Generated Japanese phrase
        Phrase string `json:"phrase"`
}

var (
        // Ju is a variable that contains the JsonUtil struct for injecting dependencies in testing.
        Ju = utility.NewJsonUtil(proxy.NewJson())
)

// NewJsonFormatter returns a new instance of the JsonFormatter struct.
func NewJsonFormatter() *JsonFormatter <span class="cov8" title="1">{
        return &amp;JsonFormatter{}
}</span>

// Format formats the output of jrp server.
func (f *JsonFormatter) Format(result interface{}) ([]byte, error) <span class="cov8" title="1">{
        var formatted []byte
        var err error
        switch v := result.(type) </span>{
        case *jrpApp.GenerateJrpUseCaseOutputDto:<span class="cov8" title="1">
                jjoDto := JrpJsonOutputDto{Phrase: v.Phrase}
                gjj, err := Ju.Marshal(jjoDto)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">gjroDto := ResponseOutputDto{Body: gjj}
                formatted = gjroDto.Body</span>
        default:<span class="cov8" title="1">
                formatted = nil
                err = errors.New("invalid result type")</span>
        }
        <span class="cov8" title="1">return formatted, err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

// @title JRP API
// @description jrp api server
// @host localhost:8080
// @BasePath /api

import (
        "os"

        "github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/server"
        _ "github.com/yanosea/jrp/v2/docs"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// JrpApiServerParams is a struct that represents the options of jrp api sever.
type JrpApiServerParams struct {
        // Echos is a proxy of labstack/echo/v4.
        Echos proxy.Echos
        // Envconfig is a proxy of kelseyhightower/envconfig.
        Envconfig proxy.Envconfig
        // FileUtil provides the file utility.
        FileUtil utility.FileUtil
        // Sql is a proxy of database/sql.
        Sql proxy.Sql
}

var (
        // exit is a variable that contains the os.Exit function for injecting dependencies in testing.
        exit = os.Exit
        // jrpApiServerParams is a variable that contains the jrpApiServerParams struct.
        jrpApiServerParams = JrpApiServerParams{
                Echos:     proxy.NewEchos(),
                Envconfig: proxy.NewEnvconfig(),
                FileUtil: utility.NewFileUtil(
                        proxy.NewGzip(),
                        proxy.NewIo(),
                        proxy.NewOs(),
                ),
                Sql: proxy.NewSql(),
        }
)

// main is the entry point of jrp api server.
func main() <span class="cov8" title="1">{
        serv := server.NewServer(
                jrpApiServerParams.Echos,
        )
        if exitCode := serv.Init(
                jrpApiServerParams.Envconfig,
                jrpApiServerParams.FileUtil,
                jrpApiServerParams.Sql,
        ); exitCode != 0 </span><span class="cov8" title="1">{
                exit(exitCode)
        }</span>

        <span class="cov8" title="1">exit(serv.Run())</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package jrp

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/log"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        wnjpnApp "github.com/yanosea/jrp/v2/app/application/wnjpn"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/infrastructure/wnjpn/query_service"
        "github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/formatter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

var (
        format = "json"
)

// BindGetJrpHandler binds the getJrp handler to the server.
func BindGetJrpHandler(g proxy.Group) <span class="cov8" title="1">{
        g.GET("/jrp", getJrp)
}</span>

// @Summary get a random Japanese phrase.
// @Description returns a randomly generated Japanese phrase.
// @Tags jrp
// @Produce json
// @Success 200 {object} formatter.JrpJsonOutputDto
// @Router /jrp [get]
// getJrp is a handler that returns a random Japanese phrase.
func getJrp(c echo.Context) error <span class="cov8" title="1">{
        connManager := database.GetConnectionManager()
        if connManager == nil </span><span class="cov8" title="1">{
                log.Error("Connection manager is not initialized...")
                return c.NoContent(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">if _, err := connManager.GetConnection(database.WNJpnDB); err != nil </span><span class="cov8" title="1">{
                log.Error("Failed to get a connection to the database...")
                return c.NoContent(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">wordQueryService := query_service.NewWordQueryService()
        fwuc := wnjpnApp.NewFetchWordsUseCase(wordQueryService)

        fwoDtos, err := fwuc.Run(
                c.Request().Context(),
                "jpn",
                []string{"a", "v", "n"},
        )
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Failed to fetch words...")
                return c.NoContent(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">var gjiDtos []*jrpApp.GenerateJrpUseCaseInputDto
        for _, fwoDto := range fwoDtos </span><span class="cov8" title="1">{
                gjiDto := &amp;jrpApp.GenerateJrpUseCaseInputDto{
                        WordID: fwoDto.WordID,
                        Lang:   fwoDto.Lang,
                        Lemma:  fwoDto.Lemma,
                        Pron:   fwoDto.Pron,
                        Pos:    fwoDto.Pos,
                }
                gjiDtos = append(gjiDtos, gjiDto)
        }</span>

        <span class="cov8" title="1">gjuc := jrpApp.NewGenerateJrpUseCase()
        gjoDto := gjuc.RunWithRandom(gjiDtos)

        f, err := formatter.NewFormatter(format)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Failed to create a new formatter...")
                return c.NoContent(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">body, err := f.Format(gjoDto)
        if body == nil || err != nil </span><span class="cov8" title="1">{
                log.Error("Failed to format the output...")
                return c.NoContent(http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">return c.JSONBlob(http.StatusOK, body)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package server

import (
        "github.com/swaggo/echo-swagger"

        "github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/server/jrp"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// Bind binds the routes to the server.
func Bind(e proxy.Echo) <span class="cov8" title="1">{
        e.Get("/swagger/*", echoSwagger.WrapHandler)
        apiGroup := e.Group("/api")
        jrp.BindGetJrpHandler(apiGroup)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package server

import (
        "errors"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"

        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/presentation/api/jrp-server/config"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

var (
        // NewServer is a variable holding the current server creation function.
        NewServer CreateServerFunc = newServer
)

// Server is an interface that provides a proxy of the methods of jrp server.
type Server interface {
        Init(envconfig proxy.Envconfig, fileUtil utility.FileUtil, sql proxy.Sql) int
        Run() int
}

// server is a struct that represents the server interface of jrp server.
type server struct {
        ConnectionManager database.ConnectionManager
        Echos             proxy.Echos
        Logger            proxy.Logger
        Port              string
        Route             proxy.Echo
}

// CreateServerFunc is a function type for creating new server instances.
type CreateServerFunc func(echo proxy.Echos) Server

// newServer is the default implementation of CreateServerFunc.
func newServer(echos proxy.Echos) Server <span class="cov8" title="1">{
        return &amp;server{
                ConnectionManager: nil,
                Echos:             echos,
                Logger:            nil,
                Port:              "",
                Route:             nil,
        }
}</span>

// Init initializes the server.
func (s *server) Init(
        envconfig proxy.Envconfig,
        fileUtil utility.FileUtil,
        sql proxy.Sql,
) int <span class="cov8" title="1">{
        s.Route, s.Logger = s.Echos.NewEcho()
        s.Route.Use(middleware.Logger())
        s.Route.Use(middleware.Recover())
        Bind(s.Route)

        configurator := config.NewJrpServerConfigurator(envconfig, fileUtil)
        conf, err := configurator.GetConfig()
        if err != nil </span><span class="cov8" title="1">{
                s.Logger.Fatal(err)
                return 1
        }</span>

        <span class="cov8" title="1">s.Port = conf.JrpPort
        if s.Port == "8080" </span><span class="cov8" title="1">{
                s.Route.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                        AllowOrigins: []string{"*"},
                        AllowMethods: []string{echo.GET},
                }))
        }</span>

        <span class="cov8" title="1">if s.ConnectionManager == nil </span><span class="cov8" title="1">{
                s.ConnectionManager = database.NewConnectionManager(sql)
        }</span>

        <span class="cov8" title="1">dbConfig := database.ConnectionConfig{
                DBName: database.WNJpnDB,
                DBType: conf.WNJpnDBType,
                DSN:    conf.WNJpnDBDsn,
        }

        if conf.WNJpnDBType == database.SQLite &amp;&amp; !fileUtil.IsExist(conf.WNJpnDBDsn) </span><span class="cov8" title="1">{
                s.Logger.Fatal(errors.New("wnjpn database file not found"))
                return 1
        }</span>

        <span class="cov8" title="1">if err := s.ConnectionManager.InitializeConnection(dbConfig); err != nil </span><span class="cov8" title="1">{
                s.Logger.Fatal(err)
                return 1
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// Run runs the server.
func (s *server) Run() (exitCode int) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if s.ConnectionManager != nil </span><span class="cov8" title="1">{
                        if err := s.ConnectionManager.CloseAllConnections(); err != nil </span><span class="cov8" title="1">{
                                s.Logger.Fatal(err)
                                exitCode = 1
                        }</span>
                }
        }()

        <span class="cov8" title="1">if err := s.Route.Start(":" + s.Port); err != nil </span><span class="cov8" title="1">{
                s.Logger.Fatal(err)
                exitCode = 1
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package command

import (
        "context"
        "os"

        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/config"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

var (
        // output is the output string.
        output = ""
        // NewCli is a variable holding the current Cli creation function.
        NewCli CreateCliFunc = newCli
)

type Cli interface {
        Init(envconfig proxy.Envconfig, sql proxy.Sql, version string, fileUtil utility.FileUtil, versionUtil utility.VersionUtil) int
        Run(ctx context.Context) int
}

// cli is a struct that represents the command line interface of jrp cli.
type cli struct {
        Cobra             proxy.Cobra
        RootCommand       proxy.Command
        ConnectionManager database.ConnectionManager
}

// CreateCliFunc is a function type for creating new Cli instances.
type CreateCliFunc func(cobra proxy.Cobra) Cli

// newCli is the default implementation of CreateCliFunc.
func newCli(cobra proxy.Cobra) Cli <span class="cov8" title="1">{
        return &amp;cli{
                Cobra:             cobra,
                RootCommand:       nil,
                ConnectionManager: nil,
        }
}</span>

// Init initializes the command line interface of jrp.
func (c *cli) Init(
        envconfig proxy.Envconfig,
        sql proxy.Sql,
        version string,
        fileUtil utility.FileUtil,
        versionUtil utility.VersionUtil,
) int <span class="cov8" title="1">{
        configurator := config.NewJrpCliConfigurator(envconfig, fileUtil)
        conf, err := configurator.GetConfig()
        if err != nil </span><span class="cov8" title="1">{
                output = formatter.AppendErrorToOutput(err, output)
                if err := presenter.Print(os.Stderr, output); err != nil </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 1</span>
        }

        <span class="cov8" title="1">if c.ConnectionManager == nil </span><span class="cov8" title="1">{
                c.ConnectionManager = database.NewConnectionManager(sql)
        }</span>

        <span class="cov8" title="1">if conf.JrpDBType == database.SQLite </span><span class="cov8" title="1">{
                if err := c.ConnectionManager.InitializeConnection(
                        database.ConnectionConfig{
                                DBName: database.JrpDB,
                                DBType: conf.JrpDBType,
                                DSN:    conf.JrpDBDsn,
                        },
                ); err != nil </span><span class="cov8" title="1">{
                        output = formatter.AppendErrorToOutput(err, output)
                        if err := presenter.Print(os.Stderr, output); err != nil </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov8" title="1">return 1</span>
                }
        }

        <span class="cov8" title="1">if conf.WNJpnDBType == database.SQLite &amp;&amp; fileUtil.IsExist(conf.WNJpnDBDsn) </span><span class="cov8" title="1">{
                if err := c.ConnectionManager.InitializeConnection(
                        database.ConnectionConfig{
                                DBName: database.WNJpnDB,
                                DBType: conf.WNJpnDBType,
                                DSN:    conf.WNJpnDBDsn,
                        },
                ); err != nil </span><span class="cov8" title="1">{
                        output = formatter.AppendErrorToOutput(err, output)
                        if err := presenter.Print(os.Stderr, output); err != nil </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov8" title="1">return 1</span>
                }
        }

        <span class="cov8" title="1">c.RootCommand = NewRootCommand(
                c.Cobra,
                versionUtil.GetVersion(version),
                conf,
                &amp;output,
        )

        return 0</span>
}

// Run runs the command line interface of jrp cli.
func (c *cli) Run(ctx context.Context) (exitCode int) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if c.ConnectionManager != nil </span><span class="cov8" title="1">{
                        if err := c.ConnectionManager.CloseAllConnections(); err != nil </span><span class="cov8" title="1">{
                                output = formatter.AppendErrorToOutput(err, output)
                                if err := presenter.Print(os.Stderr, output); err != nil </span><span class="cov0" title="0">{
                                        exitCode = 1
                                }</span>
                                <span class="cov8" title="1">exitCode = 1</span>
                        }
                }
        }()

        <span class="cov8" title="1">out := os.Stdout
        if err := c.RootCommand.ExecuteContext(ctx); err != nil </span><span class="cov8" title="1">{
                output = formatter.AppendErrorToOutput(err, output)
                out = os.Stderr
                exitCode = 1
        }</span>

        <span class="cov8" title="1">if err := presenter.Print(out, output); err != nil </span><span class="cov0" title="0">{
                exitCode = 1
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package completion

import (
        "bytes"

        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewCompletionBashCommand returns a new instance of the completion bash command.
func NewCompletionBashCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("bash")
        cmd.SetAliases([]string{"ba", "b"})
        cmd.SetUsageTemplate(completionBashUsageTemplate)
        cmd.SetHelpTemplate(completionBashHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runCompletionBash(cmd, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runCompletionBash generates the autocompletion script for the bash shell.
func runCompletionBash(cmd *c.Command, output *string) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        err := cmd.Root().GenBashCompletion(buf)
        *output = buf.String()
        return err
}</span>

const (
        // completionBashHelpTemplate is the help template of the completion bash command.
        completionBashHelpTemplate = `🔧🐚 Generate the autocompletion script for the bash shell.

This script depends on the "bash-completion" package.
If it is not installed already, you can install it via your OS's package manager.

To load completions in your current shell session:

  source &lt;(jrp completion bash)

To load completions for every new session, execute once:

  - 🐧 Linux:

    jrp completion bash &gt; /etc/bash_completion.d/jrp

  - 🍎 macOS:

    jrp completion bash &gt; $(brew --prefix)/etc/bash_completion.d/jrp

You will need to start a new shell for this setup to take effect.

` + completionBashUsageTemplate
        // compleitonUsageTemplate is the usage template of the completion bash command.
        completionBashUsageTemplate = `Usage:
  jrp completion bash [flags]

Flags:
  -h, --help  🤝 help for bash
`
)
</pre>
		
		<pre class="file" id="file25" style="display: none">package completion

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewCompletionCommand returns a new instance of the completion command.
func NewCompletionCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("completion")
        cmd.SetAliases([]string{"comp", "c"})
        cmd.SetUsageTemplate(completionUsageTemplate)
        cmd.SetHelpTemplate(completionHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.AddCommand(
                NewCompletionBashCommand(cobra, output),
                NewCompletionFishCommand(cobra, output),
                NewCompletionPowerShellCommand(cobra, output),
                NewCompletionZshCommand(cobra, output),
        )

        return cmd
}</span>

const (
        // completionHelpTemplate is the help template of the completion command.
        completionHelpTemplate = `🔧 Generate the autocompletion script for the specified shell.

` + completionUsageTemplate
        // compleitonUsageTemplate is the usage template of the completion command.
        completionUsageTemplate = `Usage:
  jrp completion [flags]
  jrp completion [command]

Available Subommands:
  bash        🔧🐚 Generate the autocompletion script for the bash shell.
  fish        🔧🐟 Generate the autocompletion script for the fish shell.
  powershell  🔧🪟 Generate the autocompletion script for the powershell shell.
  zsh         🔧🧙 Generate the autocompletion script for the zsh shell.

Flags:
  -h, --help  🤝 help for completion
`
)
</pre>
		
		<pre class="file" id="file26" style="display: none">package completion

import (
        "bytes"

        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewCompletionFishCommand returns a new instance of the completion fish command.
func NewCompletionFishCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("fish")
        cmd.SetAliases([]string{"fi", "f"})
        cmd.SetUsageTemplate(completionFishUsageTemplate)
        cmd.SetHelpTemplate(completionFishHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runCompletionFish(cmd, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runCompletionFish generates the autocompletion script for the fish shell.
func runCompletionFish(cmd *c.Command, output *string) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        err := cmd.Root().GenFishCompletion(buf, true)
        *output = buf.String()
        return err
}</span>

const (
        // completionFishHelpTemplate is the help template of the completion fish command.
        completionFishHelpTemplate = `🔧🐟 Generate the autocompletion script for the fish shell.

To load completions in your current shell session:

  jrp completion fish | source

To load completions for every new session, execute once:

  jrp completion fish &gt; ~/.config/fish/completions/jrp.fish

You will need to start a new shell for this setup to take effect.

` + completionFishUsageTemplate
        // compleitonUsageTemplate is the usage template of the completion fish command.
        completionFishUsageTemplate = `Usage:
  jrp completion fish [flags]

Flags:
  -h, --help  🤝 help for fish
`
)
</pre>
		
		<pre class="file" id="file27" style="display: none">package completion

import (
        "bytes"

        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewCompletionPowerShellCommand returns a new instance of the completion powershell command.
func NewCompletionPowerShellCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("powershell")
        cmd.SetAliases([]string{"pwsh", "p"})
        cmd.SetUsageTemplate(completionPowerShellUsageTemplate)
        cmd.SetHelpTemplate(completionPowerShellHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runCompletionPowerShell(cmd, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runCompletionPowerShell generates the autocompletion script for the powershell shell.
func runCompletionPowerShell(cmd *c.Command, output *string) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        err := cmd.Root().GenPowerShellCompletion(buf)
        *output = buf.String()
        return err
}</span>

const (
        // completionPowerShellHelpTemplate is the help template of the completion powershell command.
        completionPowerShellHelpTemplate = `🔧🪟 Generate the autocompletion script for the powershell shell.

To load completions in your current shell session:

  jrp completion powershell | Out-String | Invoke-Expression

To load completions for every new session, add the output of the above command to your powershell profile.

` + completionPowerShellUsageTemplate
        // compleitonUsageTemplate is the usage template of the completion powershell command.
        completionPowerShellUsageTemplate = `Usage:
  jrp completion powershell [flags]

Flags:
  -h, --help  🤝 help for powershell
`
)
</pre>
		
		<pre class="file" id="file28" style="display: none">package completion

import (
        "bytes"

        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewCompletionZshCommand returns a new instance of the completion zsh command.
func NewCompletionZshCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("zsh")
        cmd.SetAliases([]string{"zs", "z"})
        cmd.SetUsageTemplate(completionZshUsageTemplate)
        cmd.SetHelpTemplate(completionZshHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runCompletionZsh(cmd, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runCompletionZsh generates the autocompletion script for the zsh shell.
func runCompletionZsh(cmd *c.Command, output *string) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        err := cmd.Root().GenZshCompletion(buf)
        *output = buf.String()
        return err
}</span>

const (
        // completionZshHelpTemplate is the help template of the completion zsh command.
        completionZshHelpTemplate = `🔧🧙 Generate the autocompletion script for the zsh shell.

If shell completion is not already enabled in your environment you will need to enable it.

You can execute the following once:

  echo "autoload -U compinit; compinit" &gt;&gt; ~/.zshrc

To load completions in your current shell session:

  source &lt;(jrp completion zsh)

To load completions for every new session, execute once:

  - 🐧 Linux:

    jrp completion zsh &gt; "${fpath[1]}/_jrp"

  - 🍎 macOS:

    jrp completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_jrp

You will need to start a new shell for this setup to take effect.

` + completionZshUsageTemplate
        // compleitonUsageTemplate is the usage template of the completion zsh command.
        completionZshUsageTemplate = `Usage:
  jrp completion zsh [flags]

Flags:
  -h, --help  🤝 help for zsh
`
)
</pre>
		
		<pre class="file" id="file29" style="display: none">package jrp

import (
        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/config"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// NewDownloadCommand returns a new instance of the download command.
func NewDownloadCommand(
        cobra proxy.Cobra,
        conf *config.JrpCliConfig,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("download")
        cmd.SetAliases([]string{"dl", "d"})
        cmd.SetUsageTemplate(downloadUsageTemplate)
        cmd.SetHelpTemplate(downloadHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(_ *c.Command, _ []string) error </span><span class="cov8" title="1">{
                        return runDownload(conf, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runDownload runs the download command.
func runDownload(conf *config.JrpCliConfig, output *string) error <span class="cov8" title="1">{
        if conf.WNJpnDBType != database.SQLite </span><span class="cov8" title="1">{
                o := formatter.Red("❌ The type of WordNet Japan database is not sqlite...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">if err := presenter.StartSpinner(
                true,
                "yellow",
                formatter.Yellow(
                        "  📦 Downloading WordNet Japan sqlite database file from the official web site...",
                ),
        ); err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to start spinner...")
                *output = o
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                presenter.StopSpinner()
        }</span>()

        <span class="cov8" title="1">duc := jrpApp.NewDownloadUseCase()
        if err := duc.Run(conf.WNJpnDBDsn); err != nil &amp;&amp; err.Error() == "wnjpn.db already exists" </span><span class="cov8" title="1">{
                o := formatter.Green("✅ You are already ready to use jrp!")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to download WordNet Japan sqlite database file...")
                *output = o
                return err
        }</span>

        <span class="cov8" title="1">o := formatter.Green("✅ Downloaded successfully! Now, you are ready to use jrp!")
        *output = o

        return nil</span>
}

const (
        // downloadHelpTemplate is the help template of the download command.
        downloadHelpTemplate = `📦 Download WordNet Japan sqlite database file from the official web site.

You have to download WordNet Japan sqlite database file to use jrp at first.
"jrp download" will download archive file from the official web site and decompress it to the database file.

The default directory is "$XDG_DATA_HOME/jrp" ("~/.local/share/jrp").
If you want to change the directory, set the “JRP_WNJPN_DB_FILE_DIR” environment variable.
You have to set the same directory to the “JRP_WNJPN_DB_FILE_DIR” environment variable when you use jrp.

` + downloadUsageTemplate
        // downloadUsageTemplate is the usage template of the download command.
        downloadUsageTemplate = `Usage:
  jrp download [flags]
  jrp dl       [flags]
  jrp d        [flags]

Flags:
  -h, --help  🤝 help for jrp download
`
)
</pre>
		
		<pre class="file" id="file30" style="display: none">package jrp

import (
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// FavoriteOptions provides the options for the favorite command.
type FavoriteOptions struct {
        // All is a flag to add all phrases.
        All bool
        // NoConfirm is a flag to not confirm before removing all the histories.
        NoConfirm bool
}

var (
        // favoriteOps is a variable to store the favorite options with the default values for injecting the dependencies in testing.
        favoriteOps = FavoriteOptions{
                All:       false,
                NoConfirm: false,
        }
)

// NewFavoriteCommand returns a new instance of the favorite command.
func NewFavoriteCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("favorite")
        cmd.SetAliases([]string{"fav", "f"})
        cmd.SetUsageTemplate(favoriteUsageTemplate)
        cmd.SetHelpTemplate(favoriteHelpTemplate)
        cmd.SetSilenceErrors(true)
        cmd.Flags().BoolVarP(
                &amp;favoriteOps.All,
                "all",
                "a",
                false,
                "⭐ favorite all histories",
        )
        cmd.Flags().BoolVarP(
                &amp;favoriteOps.NoConfirm,
                "no-confirm",
                "",
                false,
                "🚫 do not confirm before favoriting all the histories",
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runFavorite(
                                cmd,
                                args,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runFavorite runs the favorite command.
func runFavorite(
        cmd *c.Command,
        args []string,
        output *string,
) error <span class="cov8" title="1">{
        if len(args) == 0 &amp;&amp; !favoriteOps.All </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No ID arguments specified...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">var ids []int
        for _, arg := range args </span><span class="cov8" title="1">{
                id, err := strconv.Atoi(arg)
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("🚨 The ID argument must be an integer...")
                        *output = o
                        return err
                }</span>
                <span class="cov8" title="1">ids = append(ids, id)</span>
        }

        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
        fuc := jrpApp.NewFavoriteUseCase(historyRepo)

        if favoriteOps.All &amp;&amp; !favoriteOps.NoConfirm </span><span class="cov8" title="1">{
                if answer, err := presenter.RunPrompt(
                        "Proceed with favoriting all the histories? [y/N]",
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> if answer != "y" &amp;&amp; answer != "Y" </span><span class="cov8" title="1">{
                        o := formatter.Yellow("🚫 Cancelled favoriting all the histories.")
                        *output = o
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err := fuc.Run(
                cmd.Context(),
                ids,
                favoriteOps.All,
        ); err != nil &amp;&amp; err.Error() == "no histories to favorite" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No histories to favorite...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">o := formatter.Green("✅ Favorited successfully!")
        *output = o

        return nil</span>
}

const (
        // favoriteHelpTemplate is the help template of the favorite command.
        favoriteHelpTemplate = `⭐ Favorite the histories of the "generate" command.

You can specify the histories to favorite with ID arguments.
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.

This command can make the histories easier to find.
And you will not be able to remove the histories with executing "history remove" and "history clear".

Also, you can favorite all the histories with the "-a" or "--all" flag.

` + favoriteUsageTemplate
        // favoriteUsageTemplate is the usage template of the favorite command.
        favoriteUsageTemplate = `Usage:
  jrp favorite [flag] [arguments]
  jrp fav      [flag] [arguments]
  jrp f        [flag] [arguments]

Flags:
  -a, --all    ⭐ favorite all the histories
  -no-confirm  🚫 do not confirm before favoriting all the histories
  -h, --help   🤝 help for favorite

Arguments:
  ID  🆔 favorite with the ID of the history (e.g. : 1 2 3)
`
)
</pre>
		
		<pre class="file" id="file31" style="display: none">package generate

import (
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        wnjpnApp "github.com/yanosea/jrp/v2/app/application/wnjpn"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/infrastructure/wnjpn/query_service"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// GenerateOptions provides the options for the generate command.
type GenerateOptions struct {
        // Number is a flag to specify the number of phrases to generate.
        Number int
        // Prefix is a flag to specify the prefix of the phrases to generate.
        Prefix string
        // Suffix is a flag to specify the suffix of the phrases to generate.
        Suffix string
        // DryRun is a flag to generate phrases without saving to the history.
        DryRun bool
        // Format is a flag to specify the format of the output.
        Format string
        // Interactive is a flag to generate Japanese random phrases interactively.
        Interactive bool
        // Timeout is a flag to specify the timeout in seconds for the interactive mode.
        Timeout int
}

var (
        // GenerateOps is a variable to store the generate options with the default values for injecting the dependencies in testing.
        GenerateOps = GenerateOptions{
                Number:      1,
                Prefix:      "",
                Suffix:      "",
                DryRun:      false,
                Format:      "table",
                Interactive: false,
                Timeout:     30,
        }
)

// NewGenerateCommand returns a new instance of the generate command.
func NewGenerateCommand(
        cobra proxy.Cobra,
        interactiveCmd proxy.Command,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("generate")
        cmd.SetAliases([]string{"gen", "g"})
        cmd.SetUsageTemplate(generateUsageTemplate)
        cmd.SetHelpTemplate(generateHelpTemplate)
        cmd.SetArgs(cobra.MaximumNArgs(1))
        cmd.SetSilenceErrors(true)
        cmd.Flags().IntVarP(
                &amp;GenerateOps.Number,
                "number",
                "n",
                1,
                "🔢 number of phrases to generate (default 1, e.g. : 10)",
        )
        cmd.Flags().StringVarP(
                &amp;GenerateOps.Prefix,
                "prefix",
                "p",
                "",
                "🔡 prefix of phrases to generate",
        )
        cmd.Flags().StringVarP(
                &amp;GenerateOps.Suffix,
                "suffix",
                "s",
                "",
                "🔡 suffix of phrases to generate",
        )
        cmd.Flags().BoolVarP(
                &amp;GenerateOps.DryRun,
                "dry-run",
                "d",
                false,
                "🧪 generate phrases without saving to the history",
        )
        cmd.Flags().StringVarP(
                &amp;GenerateOps.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g. : \"plain\")",
        )
        cmd.Flags().BoolVarP(
                &amp;GenerateOps.Interactive,
                "interactive",
                "i",
                false,
                "💬 generate Japanese random phrases interactively",
        )
        cmd.Flags().IntVarP(
                &amp;GenerateOps.Timeout,
                "timeout",
                "t",
                30,
                "⌛ timeout in seconds for the interactive mode (default 30, e.g. : 10)",
        )
        cmd.AddCommand(interactiveCmd)
        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runGenerate(
                                cmd,
                                args,
                                interactiveCmd,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runGenerate runs the generate command.
func runGenerate(
        cmd *c.Command,
        args []string,
        interactiveCmd proxy.Command,
        output *string,
) error <span class="cov8" title="1">{
        if GenerateOps.Interactive </span><span class="cov8" title="1">{
                interactiveOps.Prefix = GenerateOps.Prefix
                interactiveOps.Suffix = GenerateOps.Suffix
                interactiveOps.Format = GenerateOps.Format
                interactiveOps.Timeout = GenerateOps.Timeout
                return interactiveCmd.RunE(cmd, args)
        }</span>

        <span class="cov8" title="1">connManager := database.GetConnectionManager()
        if connManager == nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Connection manager is not initialized...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">_, err := connManager.GetConnection(database.WNJpnDB)
        if err != nil &amp;&amp; err.Error() == "connection not initialized" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ You have to execute \"download\" to use jrp...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">needRandomPrefix := GenerateOps.Prefix == ""
        needRandomSuffix := GenerateOps.Suffix == ""
        if !needRandomPrefix &amp;&amp; !needRandomSuffix </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ You can't specify both prefix and suffix at the same time...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">var pos []string
        if needRandomPrefix </span><span class="cov8" title="1">{
                pos = append(pos, "a", "v")
        }</span>
        <span class="cov8" title="1">if needRandomSuffix </span><span class="cov8" title="1">{
                pos = append(pos, "n")
        }</span>

        <span class="cov8" title="1">wordQueryService := query_service.NewWordQueryService()
        fwuc := wnjpnApp.NewFetchWordsUseCase(wordQueryService)

        fwoDtos, err := fwuc.Run(
                cmd.Context(),
                "jpn",
                pos,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var number = GenerateOps.Number
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                argNumber, err := strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("🚨 The number argument must be an integer...")
                        *output = o
                        return err
                }</span>
                <span class="cov8" title="1">if argNumber &gt; number </span><span class="cov8" title="1">{
                        number = argNumber
                }</span>
        }

        <span class="cov8" title="1">var gjiDtos []*jrpApp.GenerateJrpUseCaseInputDto
        for _, fwoDto := range fwoDtos </span><span class="cov8" title="1">{
                gjiDto := &amp;jrpApp.GenerateJrpUseCaseInputDto{
                        WordID: fwoDto.WordID,
                        Lang:   fwoDto.Lang,
                        Lemma:  fwoDto.Lemma,
                        Pron:   fwoDto.Pron,
                        Pos:    fwoDto.Pos,
                }
                gjiDtos = append(gjiDtos, gjiDto)
        }</span>

        <span class="cov8" title="1">gjuc := jrpApp.NewGenerateJrpUseCase()
        var gjoDtos []*jrpApp.GenerateJrpUseCaseOutputDto
        for i := 0; i &lt; number; i++ </span><span class="cov8" title="1">{
                var gjoDto *jrpApp.GenerateJrpUseCaseOutputDto
                if needRandomPrefix &amp;&amp; needRandomSuffix </span><span class="cov8" title="1">{
                        gjoDto = gjuc.RunWithRandom(gjiDtos)
                }</span> else<span class="cov8" title="1"> if needRandomPrefix </span><span class="cov8" title="1">{
                        gjoDto = gjuc.RunWithSuffix(gjiDtos, GenerateOps.Suffix)
                }</span> else<span class="cov8" title="1"> {
                        gjoDto = gjuc.RunWithPrefix(gjiDtos, GenerateOps.Prefix)
                }</span>
                <span class="cov8" title="1">gjoDtos = append(gjoDtos, gjoDto)</span>
        }

        <span class="cov8" title="1">if !GenerateOps.DryRun </span><span class="cov8" title="1">{
                var shiDtos []*jrpApp.SaveHistoryUseCaseInputDto
                for _, gjoDto := range gjoDtos </span><span class="cov8" title="1">{
                        shiDto := &amp;jrpApp.SaveHistoryUseCaseInputDto{
                                Phrase:      gjoDto.Phrase,
                                Prefix:      gjoDto.Prefix,
                                Suffix:      gjoDto.Suffix,
                                IsFavorited: gjoDto.IsFavorited,
                                CreatedAt:   gjoDto.CreatedAt,
                                UpdatedAt:   gjoDto.UpdatedAt,
                        }
                        shiDtos = append(shiDtos, shiDto)
                }</span>

                <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
                shuc := jrpApp.NewSaveHistoryUseCase(historyRepo)

                shoDtos, err := shuc.Run(cmd.Context(), shiDtos)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if len(shoDtos) &gt; 0 </span><span class="cov8" title="1">{
                        for i, gjoDto := range gjoDtos </span><span class="cov8" title="1">{
                                gjoDto.ID = shoDtos[i].ID
                        }</span>
                }
        }

        <span class="cov8" title="1">f, err := formatter.NewFormatter(GenerateOps.Format)
        if err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to create a formatter...")
                *output = o
                return err
        }</span>
        <span class="cov8" title="1">o := f.Format(gjoDtos)
        *output = o

        return nil</span>
}

const (
        // generateHelpTemplate is the help template of the generate command.
        generateHelpTemplate = `✨ Generate Japanese random phrases.

You can specify how many phrases to generate by flag "-n" or "--number" or a number argument.
If both are provided, the larger number takes precedence.

And you can specify the prefix or suffix of the phrases to generate
by the flag "-p" or "--prefix" and "-s" or "--suffix".

Those commands below are the same.
  "jrp" : "jrp generate"
  "jrp interactive" : "jrp --interactive" : "jrp generate interactive" : "jrp generate --interactive"

` + generateUsageTemplate
        // generateUsageTemplate is the usage template of the generate command.
        generateUsageTemplate = `Usage:
  jrp generate [flags] [argument]
  jrp gen      [flags] [argument]
  jrp g        [flags] [argument]

Available Subcommands:
  interactive, int, i  💬 Generate Japanese random phrases interactively.

Flags:
  -n, --number       🔢 number of phrases to generate (default 1, e.g. : 10)
  -p, --prefix       🔡 prefix of phrases to generate
  -s, --suffix       🔡 suffix of phrases to generate
  -d, --dry-run      🧪 generate phrases without saving to the history
  -f, --format       📝 format of the output (default "table", e.g. : "plain")
  -i, --interactive  💬 generate Japanese random phrases interactively
  -t, --timeout      ⌛ timeout in seconds for the interactive mode (default 30, e.g. : 10)
  -h, --help         🤝 help for generate

Argument:
  number  🔢 number of phrases to generate (default 1, e.g. : 10)

Use "jrp generate [command] --help" for more information about a command.
`
)
</pre>
		
		<pre class="file" id="file32" style="display: none">package generate

import (
        "os"
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        wnjpnApp "github.com/yanosea/jrp/v2/app/application/wnjpn"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/infrastructure/wnjpn/query_service"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// InteractiveOptions provides the options for the interactive command.
type InteractiveOptions struct {
        // Prefix is a flag to specify the prefix of the phrases to generate.
        Prefix string
        // Suffix is a flag to specify the suffix of the phrases to generate.
        Suffix string
        // Format is a flag to specify the format of the output.
        Format string
        // Timeout is a flag to specify the timeout in seconds for the interactive mode.
        Timeout int
}

var (
        // interactiveOps is a variable to store the interactive options with the default values for injecting the dependencies in testing.
        interactiveOps = InteractiveOptions{
                Prefix:  "",
                Suffix:  "",
                Format:  "table",
                Timeout: 30,
        }
)

// NewInteractiveCommand returns a new instance of the interactive command.
func NewInteractiveCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("interactive")
        cmd.SetAliases([]string{"int", "i"})
        cmd.SetUsageTemplate(interactiveUsageTemplate)
        cmd.SetHelpTemplate(interactiveHelpTemplate)
        cmd.SetArgs(cobra.MaximumNArgs(1))
        cmd.SetSilenceErrors(true)
        cmd.PersistentFlags().StringVarP(
                &amp;interactiveOps.Prefix,
                "prefix",
                "p",
                "",
                "🔡 prefix of phrases to generate",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;interactiveOps.Suffix,
                "suffix",
                "s",
                "",
                "🔡 suffix of phrases to generate",
        )
        cmd.PersistentFlags().StringVarP(
                &amp;interactiveOps.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g: \"plain\")",
        )
        cmd.PersistentFlags().IntVarP(
                &amp;interactiveOps.Timeout,
                "timeout",
                "t",
                30,
                "⌛ timeout in seconds for the interactive mode (default 30, e.g: 10)",
        )

        cmd.SetRunE(
                func(cmd *c.Command, _ []string) error </span><span class="cov8" title="1">{
                        return runInteractive(
                                cmd,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runInteractive runs the interactive command.
func runInteractive(
        cmd *c.Command,
        output *string,
) error <span class="cov8" title="1">{
        connManager := database.GetConnectionManager()
        if connManager == nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Connection manager is not initialized...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">_, err := connManager.GetConnection(database.WNJpnDB)
        if err != nil &amp;&amp; err.Error() == "connection not initialized" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ You have to execute \"download\" to use jrp...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">needRandomPrefix := interactiveOps.Prefix == ""
        needRandomSuffix := interactiveOps.Suffix == ""
        if !needRandomPrefix &amp;&amp; !needRandomSuffix </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ You can't specify both prefix and suffix at the same time...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">var pos []string
        if needRandomPrefix </span><span class="cov8" title="1">{
                pos = append(pos, "a", "v")
        }</span>
        <span class="cov8" title="1">if needRandomSuffix </span><span class="cov8" title="1">{
                pos = append(pos, "n")
        }</span>

        <span class="cov8" title="1">wordQueryService := query_service.NewWordQueryService()
        fwuc := wnjpnApp.NewFetchWordsUseCase(wordQueryService)

        fwoDtos, err := fwuc.Run(
                cmd.Context(),
                "jpn",
                pos,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">phase := 1
        for </span><span class="cov8" title="1">{
                if err := presenter.Print(os.Stdout, formatter.Blue("🔄 Phase : "+strconv.Itoa(phase))); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var gjiDtos []*jrpApp.GenerateJrpUseCaseInputDto
                for _, fwDto := range fwoDtos </span><span class="cov8" title="1">{
                        gjiDto := &amp;jrpApp.GenerateJrpUseCaseInputDto{
                                WordID: fwDto.WordID,
                                Lang:   fwDto.Lang,
                                Lemma:  fwDto.Lemma,
                                Pron:   fwDto.Pron,
                                Pos:    fwDto.Pos,
                        }
                        gjiDtos = append(gjiDtos, gjiDto)
                }</span>

                <span class="cov8" title="1">gjuc := jrpApp.NewGenerateJrpUseCase()
                var gjoDtos []*jrpApp.GenerateJrpUseCaseOutputDto
                var gjoDto *jrpApp.GenerateJrpUseCaseOutputDto
                if needRandomPrefix &amp;&amp; needRandomSuffix </span><span class="cov8" title="1">{
                        gjoDto = gjuc.RunWithRandom(gjiDtos)
                }</span> else<span class="cov8" title="1"> if needRandomPrefix </span><span class="cov8" title="1">{
                        gjoDto = gjuc.RunWithSuffix(gjiDtos, GenerateOps.Suffix)
                }</span> else<span class="cov8" title="1"> {
                        gjoDto = gjuc.RunWithPrefix(gjiDtos, GenerateOps.Prefix)
                }</span>
                <span class="cov8" title="1">gjoDtos = append(gjoDtos, gjoDto)

                f, err := formatter.NewFormatter(interactiveOps.Format)
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("❌ Failed to create a formatter...")
                        *output = o
                        return err
                }</span>
                <span class="cov8" title="1">o := f.Format(gjoDtos)
                if err := presenter.Print(os.Stdout, "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := presenter.Print(os.Stdout, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := presenter.Print(os.Stdout, "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := presenter.Print(os.Stdout, formatter.Yellow(interactivePromptLabel)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := presenter.OpenKeyboard(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">answer, err := presenter.GetKey(interactiveOps.Timeout)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := presenter.CloseKeyboard(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var save bool
                var cont bool
                switch answer </span>{
                case "u", "U":<span class="cov8" title="1">
                        gjoDtos[0].IsFavorited = 1
                        save = true
                        cont = true</span>
                case "i", "I":<span class="cov8" title="1">
                        gjoDtos[0].IsFavorited = 1
                        save = true
                        cont = false</span>
                case "j", "J":<span class="cov8" title="1">
                        save = true
                        cont = true</span>
                case "k", "K":<span class="cov8" title="1">
                        save = true
                        cont = false</span>
                case "m", "M":<span class="cov8" title="1">
                        save = false
                        cont = true</span>
                default:<span class="cov8" title="1">
                        save = false
                        cont = false</span>
                }

                <span class="cov8" title="1">if save </span><span class="cov8" title="1">{
                        var shiDtos []*jrpApp.SaveHistoryUseCaseInputDto
                        for _, gjoDto := range gjoDtos </span><span class="cov8" title="1">{
                                shiDto := &amp;jrpApp.SaveHistoryUseCaseInputDto{
                                        Phrase:      gjoDto.Phrase,
                                        Prefix:      gjoDto.Prefix,
                                        Suffix:      gjoDto.Suffix,
                                        IsFavorited: gjoDto.IsFavorited,
                                        CreatedAt:   gjoDto.CreatedAt,
                                        UpdatedAt:   gjoDto.UpdatedAt,
                                }
                                shiDtos = append(shiDtos, shiDto)
                        }</span>

                        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
                        shuc := jrpApp.NewSaveHistoryUseCase(historyRepo)

                        _, err = shuc.Run(cmd.Context(), shiDtos)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if answer == "u" || answer == "U" || answer == "i" || answer == "I" </span><span class="cov8" title="1">{
                                if err := presenter.Print(os.Stdout, formatter.Green("✅ Favorited successfully!")); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := presenter.Print(os.Stdout, "\n"); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if err := presenter.Print(os.Stdout, formatter.Green("✅ Saved successfully!")); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := presenter.Print(os.Stdout, "\n"); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if err := presenter.Print(os.Stdout, formatter.Yellow("⏩ Skip!")); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := presenter.Print(os.Stdout, "\n"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if !cont </span><span class="cov8" title="1">{
                        if err := presenter.Print(os.Stdout, "🚪 Exit!"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">phase++</span>
        }

        <span class="cov8" title="1">return nil</span>
}

const (
        // interactiveHelpTemplate is the help template of the interactive command.
        interactiveHelpTemplate = `💬 Generate Japanese random phrases interactively.

You can specify the prefix or suffix of the phrases to generate
by the flag "-p" or "--prefix" and "-s" or "--suffix".

And you can choose to save or favorite the phrases generated interactively.

Press either key below for your action:
  "u"   : Favorite, continue.
  "i"   : Favorite, exit.
  "j"   : Save, continue.
  "k"   : Save, exit.
  "m"   : Skip, continue.
  other : Skip, exit.

` + generateUsageTemplate
        // interactiveUsageTemplate is the usage template of the interactive command.
        interactiveUsageTemplate = `Usage:
  jrp interactive [flags]
  jrp int         [flags]
  jrp i           [flags]

Flags:
  -p, --prefix   🔡 prefix of phrases to generate
  -s, --suffix   🔡 suffix of phrases to generate
  -P, --plain    📝 plain text output instead of table output
  -t, --timeout  ⌛ timeout second for the interactive mode (default 30, e.g: 10)
  -h, --help     🤝 help for interactive
`
        // interactivePromptLabel is the prompt label of the interactive command.
        interactivePromptLabel = `🔽 Press either key below for your action:
  "u"   : Favorite, continue.
  "i"   : Favorite, exit.
  "j"   : Save, continue.
  "k"   : Save, exit.
  "m"   : Skip, continue.
  other : Skip, exit.
`
)
</pre>
		
		<pre class="file" id="file33" style="display: none">package history

import (
        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// ClearOptions provides the options for the clear command.
type ClearOptions struct {
        // Force is a flag to clear the histories even if it is favorited.
        Force bool
        // NoConfirm is a flag to not confirm before removing all the histories.
        NoConfirm bool
}

var (
        // clearOps is a variable to store the clear options with the default values for injecting the dependencies in testing.
        clearOps = ClearOptions{
                Force:     false,
                NoConfirm: false,
        }
)

// NewClearCommand returns a new instance of the clear command.
func NewClearCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("clear")
        cmd.SetAliases([]string{"cl", "c"})
        cmd.SetUsageTemplate(clearUsageTemplate)
        cmd.SetHelpTemplate(clearHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.Flags().BoolVarP(
                &amp;clearOps.Force,
                "force",
                "f",
                false,
                "💪 clear the histories even if it is favorited",
        )
        cmd.Flags().BoolVarP(
                &amp;clearOps.NoConfirm,
                "no-confirm",
                "",
                false,
                "🚫 do not confirm before clearing the histories",
        )

        cmd.SetRunE(
                func(cmd *c.Command, _ []string) error </span><span class="cov8" title="1">{
                        return runClear(
                                cmd,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runClear runs the clear command.
func runClear(
        cmd *c.Command,
        output *string,
) error <span class="cov8" title="1">{
        var ids []int

        historyRepo := repository.NewHistoryRepository()
        rhuc := jrpApp.NewRemoveHistoryUseCase(historyRepo)

        if !clearOps.NoConfirm </span><span class="cov8" title="1">{
                if answer, err := presenter.RunPrompt(
                        "Proceed with clearing the histories? [y/N]",
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> if answer != "y" &amp;&amp; answer != "Y" </span><span class="cov8" title="1">{
                        o := formatter.Yellow("🚫 Cancelled clearing the histories.")
                        *output = o
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err := rhuc.Run(
                cmd.Context(),
                ids,
                true,
                clearOps.Force,
        ); err != nil &amp;&amp; err.Error() == "no histories to remove" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No histories to clear...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">o := formatter.Green("✅ Cleared successfully!")
        *output = o

        return nil</span>
}

const (
        // clearHelpTemplate is the help template of the clear command.
        clearHelpTemplate = `📜✨ Clear the histories of the "generate" command.

You can clear the histories.
This is the same as the "history remove -a" command.
Also, you can clear the histories even if it is favorited by using the "-f" or ""--force" flag.

` + clearUsageTemplate
        // clearUsageTemplate is the usage template of the clear command.
        clearUsageTemplate = `Usage:
  jrp history clear [flag]
  jrp history cl    [flag]
  jrp history c     [flag]

Flags:
  -f, --force  💪 clear the histories even if it is favorited
  -no-confirm  🚫 do not confirm before clearing the histories
  -h, --help   🤝 help for clear
`
)
</pre>
		
		<pre class="file" id="file34" style="display: none">package history

import (
        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// HistoryOptions provides the options for the generate command.
type HistoryOptions struct {
        ShowOptions ShowOptions
}

var (
        // historyOps is a variable to store the history options with the default values for injecting the dependencies in testing.
        historyOps = HistoryOptions{
                ShowOptions: ShowOptions{
                        Number:    1,
                        All:       false,
                        Favorited: false,
                        Format:    "table",
                },
        }
)

// NewHistoryCommand returns a new instance of the history command.
func NewHistoryCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("history")
        cmd.SetAliases([]string{"hist", "h"})
        cmd.SetUsageTemplate(historyUsageTemplate)
        cmd.SetHelpTemplate(historyHelpTemplate)
        cmd.SetArgs(cobra.MaximumNArgs(1))
        cmd.SetSilenceErrors(true)
        cmd.Flags().IntVarP(
                &amp;historyOps.ShowOptions.Number,
                "number",
                "n",
                10,
                "🔢 number how many histories to show (default 10, e.g. : 50)",
        )
        cmd.Flags().BoolVarP(
                &amp;historyOps.ShowOptions.All,
                "all",
                "a",
                false,
                "📁 show all the history",
        )
        cmd.Flags().BoolVarP(
                &amp;historyOps.ShowOptions.Favorited,
                "favorited",
                "F",
                false,
                "🌟 show only favorited histories",
        )
        cmd.Flags().StringVarP(
                &amp;historyOps.ShowOptions.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g. : \"plain\")",
        )

        showCmd := NewShowCommand(
                cobra,
                output,
        )
        cmd.AddCommand(
                NewClearCommand(
                        cobra,
                        output,
                ),
                NewRemoveCommand(
                        cobra,
                        output,
                ),
                NewSearchCommand(
                        cobra,
                        output,
                ),
                showCmd,
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runHistory(
                                cmd,
                                showCmd,
                                args,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runHistory runs the history command.
func runHistory(
        cmd *c.Command,
        showCmd proxy.Command,
        args []string,
) error <span class="cov8" title="1">{
        showOps = historyOps.ShowOptions
        return showCmd.RunE(cmd, args)
}</span>

const (
        // historyHelpTemplate is the help template of the history command.
        historyHelpTemplate = `📜 Manage the histories of the "generate" command.

You can show, search, remove and clear the histories of the "generate" command.

You can specify how many histories to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent histories from the histories.
If you don't specify the number of histories, jrp will show the most recent 10 histories by default.
If both are provided, the larger number takes precedence.

Also, you can show all the histories the history by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

` + historyUsageTemplate
        // historyUsageTemplate is the usage template of the history command.
        historyUsageTemplate = `Usage:
  jrp history [flag] [argument]
  jrp hist    [flag] [argument]
  jrp h       [flag] [argument]
  jrp history [command]
  jrp hist    [command]
  jrp h       [command]

Available Subommands:
  show,   sh, s  📜📖 Show the histories of the "generate" command.
                      You can abbreviate "show" sub command. ("jrp history" and "jrp history show" are the same.)
  search, se, S  📜🔍 Search the histories of the "generate" command.
  remove, rm, r  📜🧹 Remove the histories of the "generate" command.
  clear,  cl, c  📜✨ Clear the histories of the "generate" command.

Flags:
  -n, --number     🔢 number how many histories to show (default 10, e.g. : 50)
  -a, --all        📁 show all the histories
  -F, --favorited  🌟 show only favorited histories
  -f, --format     📝 format of the output (default "table", e.g. : "plain")
  -h, --help       🤝 help for history

Argument:
  number  🔢 number how many histories to show (default 10, e.g. : 50)

Use "jrp history [command] --help" for more information about a command.
`
)
</pre>
		
		<pre class="file" id="file35" style="display: none">package history

import (
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// RemoveOptions provides the options for the remove command.
type RemoveOptions struct {
        // All is a flag to remove all phrases.
        All bool
        // Force is a flag to remove the histories even if it is favorited.
        Force bool
        // NoConfirm is a flag to not confirm before removing all the histories.
        NoConfirm bool
}

var (
        // removeOps is a variable to store the remove options with the default values for injecting the dependencies in testing.
        removeOps = RemoveOptions{
                All:       false,
                Force:     false,
                NoConfirm: false,
        }
)

// NewRemoveCommand returns a new instance of the remove command.
func NewRemoveCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("remove")
        cmd.SetAliases([]string{"rm", "r"})
        cmd.SetUsageTemplate(removeUsageTemplate)
        cmd.SetHelpTemplate(removeHelpTemplate)
        cmd.SetSilenceErrors(true)
        cmd.Flags().BoolVarP(
                &amp;removeOps.All,
                "all",
                "a",
                false,
                "✨ remove all history",
        )
        cmd.Flags().BoolVarP(
                &amp;removeOps.Force,
                "force",
                "f",
                false,
                "💪 remove the histories even if it is favorited",
        )
        cmd.Flags().BoolVarP(
                &amp;removeOps.NoConfirm,
                "no-confirm",
                "",
                false,
                "🚫 do not confirm before removing all the histories",
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runRemove(
                                cmd,
                                args,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runRemove runs the remove command.
func runRemove(
        cmd *c.Command,
        args []string,
        output *string,
) error <span class="cov8" title="1">{
        if len(args) == 0 &amp;&amp; !removeOps.All </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No ID arguments specified...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">var ids []int
        for _, arg := range args </span><span class="cov8" title="1">{
                id, err := strconv.Atoi(arg)
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("🚨 The ID argument must be an integer...")
                        *output = o
                        return err
                }</span>
                <span class="cov8" title="1">ids = append(ids, id)</span>
        }

        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
        rhuc := jrpApp.NewRemoveHistoryUseCase(historyRepo)

        if removeOps.All &amp;&amp; !removeOps.NoConfirm </span><span class="cov8" title="1">{
                if answer, err := presenter.RunPrompt(
                        "Proceed with removing all the histories? [y/N]",
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> if answer != "y" &amp;&amp; answer != "Y" </span><span class="cov8" title="1">{
                        o := formatter.Yellow("🚫 Cancelled removing all the histories.")
                        *output = o
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err := rhuc.Run(
                cmd.Context(),
                ids,
                removeOps.All,
                removeOps.Force,
        ); err != nil &amp;&amp; err.Error() == "no histories to remove" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No histories to remove...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">o := formatter.Green("✅ Removed successfully!")
        *output = o

        return nil</span>
}

const (
        // removeHelpTemplate is the help template of the remove command.
        removeHelpTemplate = `📜🧹 Remove the histories of the "generate" command.

You can specify the histories to remove with ID arguments.
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.

You can remove all the histories by flag "-a" or "--all".
This is the same as the "history clear" command.

Also, you can remove the histories even if it is favorited by using the "-f" or ""--force" flag.

` + removeUsageTemplate
        // removeUsageTemplate is the usage template of the remove command.
        removeUsageTemplate = `Usage:
  jrp history remove [flag] [arguments]
  jrp history rm     [flag] [arguments]
  jrp history r      [flag] [arguments]

Flags:
  -a, --all    ✨ remove all histories
  -f, --force  💪 remove the histories even if it is favorited
  -no-confirm  🚫 do not confirm before removing all the histories
  -h, --help   🤝 help for remove

Arguments:
  ID  🆔 remove the history by the ID (e.g: 1 2 3)
`
)
</pre>
		
		<pre class="file" id="file36" style="display: none">package history

import (
        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// SearchOptions provides the options for the search command.
type SearchOptions struct {
        // Number is a flag to specify the number of histories to search.
        Number int
        // And is a flag to search histories by AND condition.
        And bool
        // All is a flag to search all histories.
        All bool
        // Favorited is a flag to show only favorited histories.
        Favorited bool
        // Format is a flag to specify the format of the output.
        Format string
}

var (
        // searchOps is a variable to store the search options with the default values for injecting the dependencies in testing.
        searchOps = SearchOptions{
                Number:    1,
                And:       false,
                All:       false,
                Favorited: false,
                Format:    "table",
        }
)

// NewSearchCommand returns a new instance of the search command.
func NewSearchCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("search")
        cmd.SetAliases([]string{"se", "S"})
        cmd.SetUsageTemplate(searchUsageTemplate)
        cmd.SetHelpTemplate(searchHelpTemplate)
        cmd.SetSilenceErrors(true)
        cmd.Flags().IntVarP(
                &amp;searchOps.Number,
                "number",
                "n",
                10,
                "🔢 number how many histories to search (default 10, e.g: 50)",
        )
        cmd.Flags().BoolVarP(
                &amp;searchOps.And,
                "and",
                "A",
                false,
                "🧠 search histories by AND condition",
        )
        cmd.Flags().BoolVarP(
                &amp;searchOps.All,
                "all",
                "a",
                false,
                "📁 search all histories",
        )
        cmd.Flags().BoolVarP(
                &amp;searchOps.Favorited,
                "favorited",
                "F",
                false,
                "🌟 show only favorited histories",
        )
        cmd.Flags().StringVarP(
                &amp;searchOps.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g: \"plain\")",
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runSearch(
                                cmd,
                                args,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runSearch runs the search command.
func runSearch(
        cmd *c.Command,
        args []string,
        output *string,
) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No keywords provided...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
        shuc := jrpApp.NewSearchHistoryUseCase(historyRepo)

        shoDtos, err := shuc.Run(
                cmd.Context(),
                args,
                searchOps.And,
                searchOps.All,
                searchOps.Favorited,
                searchOps.Number,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(shoDtos) == 0 </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No histories found...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">f, err := formatter.NewFormatter(searchOps.Format)
        if err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to create a formatter...")
                *output = o
                return err
        }</span>
        <span class="cov8" title="1">o := f.Format(shoDtos)
        *output = o

        return nil</span>
}

const (
        // searchHelpTemplate is the help template of the search command.
        searchHelpTemplate = `📜🔍 Search the histories of the "generate" command.

You can search histories with keyword arguments.
Multiple keywords are separated by a space.

If you want to search histories by AND condition, you can use flag "-A" or "--and".
OR condition is by default.

You can specify how many histories to show with flag "-n" or "--number".
If you don't specify the number of histories, jrp will show the most recent 10 histories by default.

Also, you can show all histories by flag "-a" or "--all".
If you use the flag, the number flag will be ignored.

` + searchUsageTemplate
        // searchUsageTemplate is the usage template of the search command.
        searchUsageTemplate = `Usage:
  jrp history search [flag] [arguments]
  jrp history se     [flag] [arguments]
  jrp history S      [flag] [arguments]

Flags:
  -A, --and        🧠 search histories by AND condition
  -n, --number     🔢 number how many histories to show (default 10, e.g: 50)
  -a, --all        📁 show all histories
  -F, --favorited  🌟 show only favorited histories
  -f, --format     📝 format of the output (default "table", e.g: "plain")
  -h, --help       🤝 help for search

Arguments:
  keywords  🔡 search histories by keywords (multiple keywords are separated by space)
`
)
</pre>
		
		<pre class="file" id="file37" style="display: none">package history

import (
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// ShowOptions provides the options for the show command.
type ShowOptions struct {
        // Number is a flag to specify the number of histories to show.
        Number int
        // All is a flag to show all the histories.
        All bool
        // Favorited is a flag to show only favorited histories.
        Favorited bool
        // Format is a flag to specify the format of the output.
        Format string
}

var (
        // showOps is a variable to store the show options with the default values for injecting the dependencies in testing.
        showOps = ShowOptions{
                Number:    1,
                All:       false,
                Favorited: false,
                Format:    "table",
        }
)

// NewShowCommand returns a new instance of the show command.
func NewShowCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("show")
        cmd.SetAliases([]string{"sh", "s"})
        cmd.SetUsageTemplate(showUsageTemplate)
        cmd.SetHelpTemplate(showHelpTemplate)
        cmd.SetArgs(cobra.MaximumNArgs(1))
        cmd.SetSilenceErrors(true)
        cmd.Flags().IntVarP(
                &amp;showOps.Number,
                "number",
                "n",
                10,
                "🔢 number how many histories to show (default 10, e.g. : 50)",
        )
        cmd.Flags().BoolVarP(
                &amp;showOps.All,
                "all",
                "a",
                false,
                "📁 show all the history",
        )
        cmd.Flags().BoolVarP(
                &amp;showOps.Favorited,
                "favorited",
                "F",
                false,
                "🌟 show only favorited histories",
        )
        cmd.Flags().StringVarP(
                &amp;showOps.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g. : \"plain\")",
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runShow(
                                cmd,
                                args,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runShow runs the show command.
func runShow(
        cmd *c.Command,
        args []string,
        output *string,
) error <span class="cov8" title="1">{
        var number = showOps.Number
        isDefaultNumber := number == 10
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                argNumber, err := strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("🚨 The number argument must be an integer...")
                        *output = o
                        return err
                }</span>

                <span class="cov8" title="1">if isDefaultNumber </span><span class="cov8" title="1">{
                        number = argNumber
                }</span> else<span class="cov8" title="1"> {
                        if argNumber &gt; number </span><span class="cov8" title="1">{
                                number = argNumber
                        }</span>
                }
        }

        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
        ghuc := jrpApp.NewGetHistoryUseCase(historyRepo)

        ghoDtos, err := ghuc.Run(
                cmd.Context(),
                showOps.All,
                showOps.Favorited,
                number,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(ghoDtos) == 0 </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No histories found...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">f, err := formatter.NewFormatter(showOps.Format)
        if err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to create a formatter...")
                *output = o
                return err
        }</span>
        <span class="cov8" title="1">o := f.Format(ghoDtos)
        *output = o

        return nil</span>
}

const (
        // showHelpTemplate is the help template of the show command.
        showHelpTemplate = `📜📖 Show the histories of the "generate" command.

You can specify how many histories to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent histories from the histories.
If you don't specify the number of histories, jrp will show the most recent 10 histories by default.
If both are provided, the larger number takes precedence.

Also, you can show all the histories by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

` + showUsageTemplate
        // showUsageTemplate is the usage template of the show command.
        showUsageTemplate = `Usage:
  jrp history show [flag] [argument]
  jrp history sh   [flag] [argument]
  jrp history s    [flag] [argument]

Flags:
  -n, --number     🔢 number how many histories to show (default 10, e.g. : 50)
  -a, --all        📁 show all the histories
  -F, --favorited  🌟 show only favorited histories
  -f, --format     📝 format of the output (default "table", e.g. : "plain")
  -h, --help       🤝 help for show

Argument:
  number  🔢 number how many histories to show (default 10, e.g. : 50)
`
)
</pre>
		
		<pre class="file" id="file38" style="display: none">package jrp

import (
        "strconv"

        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/infrastructure/jrp/repository"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/presenter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// UnfavoriteOptions provides the options for the unfavorite command.
type UnfavoriteOptions struct {
        // All is a flag to unfavorite all the histories.
        All bool
        // NoConfirm is a flag to not confirm before unfavoriting all the historyies.
        NoConfirm bool
}

var (
        // unfavoriteOps is a variable to store the unfavorite options with the default values for injecting the dependencies in testing.
        unfavoriteOps = UnfavoriteOptions{
                All:       false,
                NoConfirm: false,
        }
)

// NewUnfavoriteCommand returns a new instance of the unfavorite command.
func NewUnfavoriteCommand(
        cobra proxy.Cobra,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("unfavorite")
        cmd.SetAliases([]string{"unf", "u"})
        cmd.SetUsageTemplate(unfavoriteUsageTemplate)
        cmd.SetHelpTemplate(unfavoriteHelpTemplatep)
        cmd.SetSilenceErrors(true)
        cmd.Flags().BoolVarP(
                &amp;unfavoriteOps.All,
                "all",
                "a",
                false,
                "✨ remove all favorited phrases",
        )
        cmd.Flags().BoolVarP(
                &amp;unfavoriteOps.NoConfirm,
                "no-confirm",
                "",
                false,
                "🚫 do not confirm before removing all the favorited phrases",
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runUnfavorite(
                                cmd,
                                args,
                                output,
                        )
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runUnfavorite runs the unfavorite command.
func runUnfavorite(
        cmd *c.Command,
        args []string,
        output *string,
) error <span class="cov8" title="1">{
        if len(args) == 0 &amp;&amp; !unfavoriteOps.All </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No ID arguments specified...")
                *output = o
                return nil
        }</span>

        <span class="cov8" title="1">var ids []int
        for _, arg := range args </span><span class="cov8" title="1">{
                id, err := strconv.Atoi(arg)
                if err != nil </span><span class="cov8" title="1">{
                        o := formatter.Red("🚨 The ID argument must be an integer...")
                        *output = o
                        return err
                }</span>
                <span class="cov8" title="1">ids = append(ids, id)</span>
        }

        <span class="cov8" title="1">historyRepo := repository.NewHistoryRepository()
        uuc := jrpApp.NewUnfavoriteUseCase(historyRepo)

        if unfavoriteOps.All &amp;&amp; !unfavoriteOps.NoConfirm </span><span class="cov8" title="1">{
                if answer, err := presenter.RunPrompt(
                        "Proceed with unfavoriting all the histories? [y/N]",
                ); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov8" title="1"> if answer != "y" &amp;&amp; answer != "Y" </span><span class="cov8" title="1">{
                        o := formatter.Yellow("🚫 Cancelled unfavoriting all the favorited histories.")
                        *output = o
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err := uuc.Run(
                cmd.Context(),
                ids,
                unfavoriteOps.All,
        ); err != nil &amp;&amp; err.Error() == "no favorited histories to unfavorite" </span><span class="cov8" title="1">{
                o := formatter.Yellow("⚡ No favorited histories to unfavorite...")
                *output = o
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">o := formatter.Green("✅ Unfavorited successfully!")
        *output = o

        return nil</span>
}

const (
        // unfavoriteHelpTemplatep is the help template of the unfavorite command.
        unfavoriteHelpTemplatep = `⭐🧹 Unfavorite the favorited histories with the "favorite" command.

You can specify the favorited histories to unfavorite with ID arguments.
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.

This does not remove the history of the "generate" command, just unfavorite.

Also, you can unfavorite all the favorited histories with the "-a" or "--all" flag.

` + unfavoriteUsageTemplate
        // unfavoriteUsageTemplate is the usage template of the unfavorite command.
        unfavoriteUsageTemplate = `Usage:
  jrp unfavorite [flag] [arguments]
  jrp unf        [flag] [arguments]
  jrp u          [flag] [arguments]

Flags:
  -a, --all    ✨ unfavorite all the favorited histories
  -no-confirm  🚫 do not confirm before unfavoriting all the favorited histories
  -h, --help   🤝 help for unfavorite

Arguments:
  ID  🆔 unfavorite with the the ID of the favorited history (e.g. : 1 2 3)
`
)
</pre>
		
		<pre class="file" id="file39" style="display: none">package jrp

import (
        c "github.com/spf13/cobra"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/formatter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

var (
        format = "plain"
)

// NewVersionCommand returns a new instance of the version command.
func NewVersionCommand(
        cobra proxy.Cobra,
        version string,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("version")
        cmd.SetAliases([]string{"ver", "v"})
        cmd.SetUsageTemplate(versionUsageTemplate)
        cmd.SetHelpTemplate(versionHelpTemplate)
        cmd.SetArgs(cobra.ExactArgs(0))
        cmd.SetSilenceErrors(true)
        cmd.SetRunE(
                func(_ *c.Command, _ []string) error </span><span class="cov8" title="1">{
                        return runVersion(version, output)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runVersion runs the version command.
func runVersion(version string, output *string) error <span class="cov8" title="1">{
        uc := jrpApp.NewGetVersionUseCase()
        dto := uc.Run(version)

        f, err := formatter.NewFormatter(format)
        if err != nil </span><span class="cov8" title="1">{
                o := formatter.Red("❌ Failed to create a formatter...")
                *output = o
                return err
        }</span>
        <span class="cov8" title="1">o := f.Format(dto)
        *output = o

        return nil</span>
}

const (
        // versionHelpTemplate is the help template of the version command.
        versionHelpTemplate = `🔖 Show the version of jrp

` + versionUsageTemplate
        // versionUsageTemplate is the usage template of the version command.
        versionUsageTemplate = `Usage:
  jrp version [flags]
        jrp ver     [flags]
        jrp v       [flags]

Flags:
  -h, --help  🤝 help for jrp version
`
)
</pre>
		
		<pre class="file" id="file40" style="display: none">package command

import (
        c "github.com/spf13/cobra"

        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/completion"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/generate"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command/jrp/history"
        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/config"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// RootOptions provides the options for the root command.
type RootOptions struct {
        // Version is a flag to show the version of jrp.
        Version bool
        // GenerateOptions provides the options for the generate command.
        GenerateOptions generate.GenerateOptions
}

var (
        // rootOps is a variable to store the root options with the default values for injecting the dependencies in testing.
        rootOps = RootOptions{
                Version: false,
                GenerateOptions: generate.GenerateOptions{
                        Number:      1,
                        Prefix:      "",
                        Suffix:      "",
                        DryRun:      false,
                        Format:      "table",
                        Interactive: false,
                        Timeout:     30,
                },
        }
)

// NewRootCommand returns a new instance of the root command.
func NewRootCommand(
        cobra proxy.Cobra,
        version string,
        conf *config.JrpCliConfig,
        output *string,
) proxy.Command <span class="cov8" title="1">{
        cmd := cobra.NewCommand()
        cmd.SetUse("jrp")
        cmd.SetUsageTemplate(rootUsageTemplate)
        cmd.SetHelpTemplate(rootHelpTemplate)
        cmd.SetArgs(cobra.MaximumNArgs(1))
        cmd.SetSilenceErrors(true)
        cmd.PersistentFlags().BoolVarP(
                &amp;rootOps.Version,
                "version",
                "v",
                false,
                "🔖 show the version of jrp",
        )
        cmd.Flags().IntVarP(
                &amp;rootOps.GenerateOptions.Number,
                "number",
                "n",
                1,
                "🔢 number of phrases to generate (default 1, e.g. : 10)",
        )
        cmd.Flags().StringVarP(
                &amp;rootOps.GenerateOptions.Prefix,
                "prefix",
                "p",
                "",
                "🔡 prefix of phrases to generate",
        )
        cmd.Flags().StringVarP(
                &amp;rootOps.GenerateOptions.Suffix,
                "suffix",
                "s",
                "",
                "🔡 suffix of phrases to generate",
        )
        cmd.Flags().BoolVarP(
                &amp;rootOps.GenerateOptions.DryRun,
                "dry-run",
                "d",
                false,
                "🧪 generate phrases without saving to the history",
        )
        cmd.Flags().StringVarP(
                &amp;rootOps.GenerateOptions.Format,
                "format",
                "f",
                "table",
                "📝 format of the output (default \"table\", e.g. : \"plain\")",
        )
        cmd.Flags().BoolVarP(
                &amp;rootOps.GenerateOptions.Interactive,
                "interactive",
                "i",
                false,
                "💬 generate Japanese random phrases interactively",
        )
        cmd.Flags().IntVarP(
                &amp;rootOps.GenerateOptions.Timeout,
                "timeout",
                "t",
                30,
                "⌛ timeout in seconds for the interactive mode (default 30, e.g. : 10)",
        )
        interactiveCmd := generate.NewInteractiveCommand(
                cobra,
                output,
        )
        generateCmd := generate.NewGenerateCommand(
                cobra,
                interactiveCmd,
                output,
        )
        versionCmd := jrp.NewVersionCommand(
                cobra,
                version,
                output,
        )
        cmd.AddCommand(
                completion.NewCompletionCommand(
                        cobra,
                        output,
                ),
                jrp.NewDownloadCommand(
                        cobra,
                        conf,
                        output,
                ),
                jrp.NewFavoriteCommand(
                        cobra,
                        output,
                ),
                generateCmd,
                history.NewHistoryCommand(
                        cobra,
                        output,
                ),
                interactiveCmd,
                jrp.NewUnfavoriteCommand(
                        cobra,
                        output,
                ),
                versionCmd,
        )

        cmd.SetRunE(
                func(cmd *c.Command, args []string) error </span><span class="cov8" title="1">{
                        return runRoot(cmd, args, generateCmd, versionCmd)
                }</span>,
        )

        <span class="cov8" title="1">return cmd</span>
}

// runRoot runs the root command.
func runRoot(
        cmd *c.Command,
        args []string,
        generateCmd proxy.Command,
        versionCmd proxy.Command,
) error <span class="cov8" title="1">{
        if rootOps.Version </span><span class="cov8" title="1">{
                return versionCmd.RunE(cmd, args)
        }</span>
        <span class="cov8" title="1">generate.GenerateOps = rootOps.GenerateOptions
        return generateCmd.RunE(cmd, args)</span>
}

const (
        // rootHelpTemplate is the help template of the root command.
        rootHelpTemplate = `🎲 jrp is the CLI jokeey tool to generate Japanese random phrases.

You can generate Japanese random phrases.

You can specify how many phrases to generate by flag "-n" or "--number" or a number argument.
If both are provided, the larger number takes precedence.

And you can specify the prefix or suffix of the phrases to generate
by the flag "-p" or "--prefix" and "-s" or "--suffix".

Those commands below are the same.
  "jrp" : "jrp generate"
  "jrp interactive" : "jrp --interactive" : "jrp generate interactive" : "jrp generate --interactive"

` + rootUsageTemplate
        // rootUsageTemplate is the usage template of the root command.
        rootUsageTemplate = `Usage:
  jrp [flags]
  jrp [command]
  jrp [argument]

Available Subcommands:
  download,    dl,   d  📦 Download WordNet Japan sqlite database file from the official web site.
  generate,    gen,  g  ✨ Generate Japanese random phrases.
                           You can abbreviate "generate" sub command. ("jrp" and "jrp generate" are the same.)
  interactive, int,  i  💬 Generate Japanese random phrases interactively.
  history,     hist, h  📜 Manage the histories of the "generate" command.
  favorite,    fav,  f  ⭐ Favorite the histories of the "generate" command.
  unfavorite,  unf,  u  ❌ Unfavorite the favorited histories of the "generate" command.
  completion   comp, c  🔧 Generate the autocompletion script for the specified shell.
  version      ver,  v  🔖 Show the version of jrp.
  help                  🤝 Help for jrp.

Flags:
  -n, --number       🔢 number of phrases to generate (default 1, e.g. : 10)
  -p, --prefix       🔡 prefix of phrases to generate
  -s, --suffix       🔡 suffix of phrases to generate
  -d, --dry-run      🧪 generate phrases without saving as the histories
  -f, --format       📝 format of the output (default "table", e.g. : "plain")
  -i, --interactive  💬 generate Japanese random phrases interactively
  -t, --timeout      ⌛ timeout in seconds for the interactive mode (default 30, e.g. : 10)
  -h, --help         🤝 help for jrp
  -v, --version      🔖 version for jrp

Argument:
  number  🔢 number of phrases to generate (e.g. : 10)

Use "jrp [command] --help" for more information about a command.
`
)
</pre>
		
		<pre class="file" id="file41" style="display: none">package config

import (
        "path/filepath"
        "strings"

        baseConfig "github.com/yanosea/jrp/v2/app/config"
        "github.com/yanosea/jrp/v2/app/infrastructure/database"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// JrpCliConfigurator is an interface that gets the configuration of the Jrp cli application.
type JrpCliConfigurator interface {
        GetConfig() (*JrpCliConfig, error)
}

// cliConfigurator is a struct that implements the JrpCliConfigurator interface.
type cliConfigurator struct {
        *baseConfig.BaseConfigurator
}

// NewJrpCliConfigurator creates a new JrpCliConfigurator.
func NewJrpCliConfigurator(
        envconfigProxy proxy.Envconfig,
        fileUtil utility.FileUtil,
) JrpCliConfigurator <span class="cov8" title="1">{
        return &amp;cliConfigurator{
                BaseConfigurator: baseConfig.NewConfigurator(
                        envconfigProxy,
                        fileUtil,
                ),
        }
}</span>

// JrpCliConfig is a struct that contains the configuration of the Jrp cli application.
type JrpCliConfig struct {
        baseConfig.JrpConfig
        JrpDBType database.DBType
        JrpDBDsn  string
}

// envConfig is a struct that contains the environment variables.
type envConfig struct {
        JrpDBType   database.DBType `envconfig:"JRP_DB_TYPE" default:"sqlite"`
        JrpDBDsn    string          `envconfig:"JRP_DB" default:"XDG_DATA_HOME/jrp/jrp.db"`
        WnJpnDBType database.DBType `envconfig:"JRP_WNJPN_DB_TYPE" default:"sqlite"`
        WnJpnDBDsn  string          `envconfig:"JRP_WNJPN_DB" default:"XDG_DATA_HOME/jrp/wnjpn.db"`
}

// GetConfig gets the configuration of the Jrp cli application.
func (c *cliConfigurator) GetConfig() (*JrpCliConfig, error) <span class="cov8" title="1">{
        var env envConfig
        if err := c.Envconfig.Process("", &amp;env); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config := &amp;JrpCliConfig{
                JrpConfig: baseConfig.JrpConfig{
                        WNJpnDBType: env.WnJpnDBType,
                        WNJpnDBDsn:  env.WnJpnDBDsn,
                },
                JrpDBType: env.JrpDBType,
                JrpDBDsn:  env.JrpDBDsn,
        }

        if config.JrpDBType == database.SQLite || config.WNJpnDBType == database.SQLite </span><span class="cov8" title="1">{
                xdgDataHome, err := c.FileUtil.GetXDGDataHome()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if config.JrpDBType == database.SQLite </span><span class="cov8" title="1">{
                        config.JrpDBDsn = strings.Replace(
                                config.JrpDBDsn,
                                "XDG_DATA_HOME",
                                xdgDataHome,
                                1,
                        )
                        if err := c.FileUtil.MkdirIfNotExist(
                                filepath.Dir(config.JrpDBDsn),
                        ); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">if config.WNJpnDBType == database.SQLite </span><span class="cov8" title="1">{
                        config.WNJpnDBDsn = strings.Replace(
                                config.WNJpnDBDsn,
                                "XDG_DATA_HOME",
                                xdgDataHome,
                                1,
                        )
                        if err := c.FileUtil.MkdirIfNotExist(
                                filepath.Dir(config.WNJpnDBDsn),
                        ); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package formatter

import (
        "errors"
        "fmt"
)

// Formatter is an interface that formats the output of jrp cli.
type Formatter interface {
        Format(result interface{}) string
}

// NewFormatter returns a new instance of the Formatter interface.
func NewFormatter(
        format string,
) (Formatter, error) <span class="cov8" title="1">{
        var f Formatter
        switch format </span>{
        case "plain":<span class="cov8" title="1">
                f = NewPlainFormatter()</span>
        case "table":<span class="cov8" title="1">
                f = NewTableFormatter()</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("invalid format")</span>
        }
        <span class="cov8" title="1">return f, nil</span>
}

// AppendErrorToOutput appends an error to the output.
func AppendErrorToOutput(err error, output string) string <span class="cov8" title="1">{
        if err == nil &amp;&amp; output == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var result string
        if err != nil </span><span class="cov8" title="1">{
                if output == "" </span><span class="cov8" title="1">{
                        result = fmt.Sprintf("Error : %s", err)
                }</span> else<span class="cov8" title="1"> {
                        result = fmt.Sprintf(output+"\nError : %s", err)
                }</span>
        } else<span class="cov8" title="1"> {
                result = output
        }</span>

        <span class="cov8" title="1">if result != "" </span><span class="cov8" title="1">{
                result = Red(result)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package formatter

import (
        "fmt"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"
)

// PlainFormatter is a struct that formats the output of jrp cli.
type PlainFormatter struct{}

// NewPlainFormatter returns a new instance of the PlainFormatter struct.
func NewPlainFormatter() *PlainFormatter <span class="cov8" title="1">{
        return &amp;PlainFormatter{}
}</span>

// Format formats the output of jrp cli.
func (f *PlainFormatter) Format(result interface{}) string <span class="cov8" title="1">{
        var formatted string
        switch v := result.(type) </span>{
        case *jrpApp.GetVersionUseCaseOutputDto:<span class="cov8" title="1">
                formatted = fmt.Sprintf("jrp version %s", v.Version)</span>
        case []*jrpApp.GenerateJrpUseCaseOutputDto:<span class="cov8" title="1">
                for i, item := range v </span><span class="cov8" title="1">{
                        formatted += item.Phrase
                        if i &lt; len(v)-1 </span><span class="cov8" title="1">{
                                formatted += "\n"
                        }</span>
                }
        case []*jrpApp.GetHistoryUseCaseOutputDto:<span class="cov8" title="1">
                for i, item := range v </span><span class="cov8" title="1">{
                        formatted += item.Phrase
                        if i &lt; len(v)-1 </span><span class="cov8" title="1">{
                                formatted += "\n"
                        }</span>
                }
        case []*jrpApp.SearchHistoryUseCaseOutputDto:<span class="cov8" title="1">
                for i, item := range v </span><span class="cov8" title="1">{
                        formatted += item.Phrase
                        if i &lt; len(v)-1 </span><span class="cov8" title="1">{
                                formatted += "\n"
                        }</span>
                }
        default:<span class="cov8" title="1">
                formatted = ""</span>
        }
        <span class="cov8" title="1">return formatted</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package formatter

import (
        "fmt"
        "slices"
        "strconv"
        "strings"
        "time"

        jrpApp "github.com/yanosea/jrp/v2/app/application/jrp"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// TableFormatter is a struct that formats the output of jrp cli.
type TableFormatter struct{}

// NewTableFormatter returns a new instance of the TableFormatter struct.
func NewTableFormatter() *TableFormatter <span class="cov8" title="1">{
        return &amp;TableFormatter{}
}</span>

var (
        // t is a variable to store the table writer with the default values for injecting the dependencies in testing.
        t = utility.NewTableWriterUtil(proxy.NewTableWriter())
)

// tableData is a struct that holds the data of a table.
type tableData struct {
        header []string
        rows   [][]string
}

// Format formats the output of jrp cli.
func (f *TableFormatter) Format(result interface{}) string <span class="cov8" title="1">{
        var data tableData

        switch v := result.(type) </span>{
        case []*jrpApp.GenerateJrpUseCaseOutputDto:<span class="cov8" title="1">
                data = f.formatGenerateJrp(v)</span>
        case []*jrpApp.GetHistoryUseCaseOutputDto:<span class="cov8" title="1">
                data = f.formatHistory(v, func(h interface{}) (int, string, string, string, int, time.Time, time.Time) </span><span class="cov8" title="1">{
                        dto := h.(*jrpApp.GetHistoryUseCaseOutputDto)
                        return dto.ID, dto.Phrase, dto.Prefix, dto.Suffix, dto.IsFavorited, dto.CreatedAt, dto.UpdatedAt
                }</span>)
        case []*jrpApp.SearchHistoryUseCaseOutputDto:<span class="cov8" title="1">
                data = f.formatHistory(v, func(h interface{}) (int, string, string, string, int, time.Time, time.Time) </span><span class="cov8" title="1">{
                        dto := h.(*jrpApp.SearchHistoryUseCaseOutputDto)
                        return dto.ID, dto.Phrase, dto.Prefix, dto.Suffix, dto.IsFavorited, dto.CreatedAt, dto.UpdatedAt
                }</span>)
        default:<span class="cov8" title="1">
                return ""</span>
        }

        <span class="cov8" title="1">return f.getTableString(data)</span>
}

// formatGenerateJrp formats the output of the GenerateJrp use case.
func (f *TableFormatter) formatGenerateJrp(items []*jrpApp.GenerateJrpUseCaseOutputDto) tableData <span class="cov8" title="1">{
        header := []string{"phrase", "prefix", "suffix", "created_at"}

        noId := slices.ContainsFunc(items, func(dto *jrpApp.GenerateJrpUseCaseOutputDto) bool </span><span class="cov8" title="1">{
                return dto.ID == 0
        }</span>)
        <span class="cov8" title="1">if !noId </span><span class="cov8" title="1">{
                header = append([]string{"id"}, header...)
        }</span>

        <span class="cov8" title="1">var rows [][]string
        for _, jrp := range items </span><span class="cov8" title="1">{
                row := []string{jrp.Phrase, jrp.Prefix, jrp.Suffix, jrp.CreatedAt.Format("2006-01-02 15:04:05")}
                if !noId </span><span class="cov8" title="1">{
                        row = append([]string{strconv.Itoa(jrp.ID)}, row...)
                }</span>
                <span class="cov8" title="1">rows = append(rows, row)</span>
        }

        <span class="cov8" title="1">if !noId </span><span class="cov8" title="1">{
                rows = f.addTotalRow(rows)
        }</span>

        <span class="cov8" title="1">return tableData{header: header, rows: rows}</span>
}

// formatHistory formats the output of the GetHistory and SearchHistory use cases.
func (f *TableFormatter) formatHistory(items interface{}, getData func(interface{}) (int, string, string, string, int, time.Time, time.Time)) tableData <span class="cov8" title="1">{
        header := []string{"id", "phrase", "prefix", "suffix", "is_favorited", "created_at", "updated_at"}
        var rows [][]string

        addRows := func(v interface{}) </span><span class="cov8" title="1">{
                switch v := v.(type) </span>{
                case []*jrpApp.GetHistoryUseCaseOutputDto:<span class="cov8" title="1">
                        for _, item := range v </span><span class="cov8" title="1">{
                                id, phrase, prefix, suffix, isFavorited, createdAt, updatedAt := getData(item)
                                favorited := ""
                                if isFavorited == 1 </span><span class="cov8" title="1">{
                                        favorited = "○"
                                }</span>
                                <span class="cov8" title="1">rows = append(rows, []string{
                                        strconv.Itoa(id),
                                        phrase,
                                        prefix,
                                        suffix,
                                        favorited,
                                        createdAt.Format("2006-01-02 15:04:05"),
                                        updatedAt.Format("2006-01-02 15:04:05"),
                                })</span>
                        }
                case []*jrpApp.SearchHistoryUseCaseOutputDto:<span class="cov8" title="1">
                        for _, item := range v </span><span class="cov8" title="1">{
                                id, phrase, prefix, suffix, isFavorited, createdAt, updatedAt := getData(item)
                                favorited := ""
                                if isFavorited == 1 </span><span class="cov8" title="1">{
                                        favorited = "○"
                                }</span>
                                <span class="cov8" title="1">rows = append(rows, []string{
                                        strconv.Itoa(id),
                                        phrase,
                                        prefix,
                                        suffix,
                                        favorited,
                                        createdAt.Format("2006-01-02 15:04:05"),
                                        updatedAt.Format("2006-01-02 15:04:05"),
                                })</span>
                        }
                default:<span class="cov8" title="1">
                        return</span>
                }
        }
        <span class="cov8" title="1">addRows(items)

        if len(rows) &lt;= 0 </span><span class="cov8" title="1">{
                return tableData{}
        }</span>

        <span class="cov8" title="1">rows = f.addTotalRow(rows)
        return tableData{header: header, rows: rows}</span>
}

// addTotalRow adds a total row to the table.
func (f *TableFormatter) addTotalRow(rows [][]string) [][]string <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return [][]string{}
        }</span>

        <span class="cov8" title="1">emptyRow := make([]string, len(rows[0]))
        for i := range emptyRow </span><span class="cov8" title="1">{
                emptyRow[i] = ""
        }</span>

        <span class="cov8" title="1">totalRow := make([]string, len(rows[0]))
        totalRow[0] = fmt.Sprintf("TOTAL : %d jrps!", len(rows))

        rows = append(rows, emptyRow)
        rows = append(rows, totalRow)

        return rows</span>
}

// getTableString returns a string representation of a table.
func (f *TableFormatter) getTableString(data tableData) string <span class="cov8" title="1">{
        if len(data.header) == 0 || len(data.rows) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">tableString := &amp;strings.Builder{}
        table := t.GetNewDefaultTable(tableString)
        table.SetHeader(data.header)
        table.AppendBulk(data.rows)
        table.Render()
        return strings.TrimSuffix(tableString.String(), "\n")</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package main

import (
        "context"
        "os"

        "github.com/yanosea/jrp/v2/app/presentation/cli/jrp/command"

        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

// JrpCliParams is a struct that represents the options of jrp cli.
type JrpCliParams struct {
        // Version is the version of jrp cli.
        Version string
        // Cobra is a proxy of spf13/cobra.
        Cobra proxy.Cobra
        // Envconfig is a proxy of kelseyhightower/envconfig.
        Envconfig proxy.Envconfig
        // Sql is a proxy of database/sql.
        Sql proxy.Sql
        // FileUtil provides the file utility.
        FileUtil utility.FileUtil
        // VersionUtil provides the version of the application.
        VersionUtil utility.VersionUtil
}

var (
        // version is the version of jrp cli and is embedded by goreleaser.
        version = ""
        // exit is a variable that contains the os.Exit function for injecting dependencies in testing.
        exit = os.Exit
        // jrpCliParams is a variable that contains the JrpCliParams struct.
        jrpCliParams = JrpCliParams{
                Version:   version,
                Cobra:     proxy.NewCobra(),
                Envconfig: proxy.NewEnvconfig(),
                Sql:       proxy.NewSql(),
                FileUtil: utility.NewFileUtil(
                        proxy.NewGzip(),
                        proxy.NewIo(),
                        proxy.NewOs(),
                ),
                VersionUtil: utility.NewVersionUtil(proxy.NewDebug()),
        }
)

// main is the entry point of jrp cli.
func main() <span class="cov8" title="1">{
        cli := command.NewCli(
                jrpCliParams.Cobra,
        )
        if exitCode := cli.Init(
                jrpCliParams.Envconfig,
                jrpCliParams.Sql,
                jrpCliParams.Version,
                jrpCliParams.FileUtil,
                jrpCliParams.VersionUtil,
        ); exitCode != 0 </span><span class="cov8" title="1">{
                exit(exitCode)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        defer ctx.Done()

        exit(cli.Run(ctx))</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package presenter

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

var (
        // Ku is a variable that contains the KeyboardUtil struct for injecting dependencies in testing.
        Ku = utility.NewKeyboardUtil(proxy.NewKeyboard())
)

// CloseKeyboard closes the keyboard.
func CloseKeyboard() error <span class="cov8" title="1">{
        return Ku.CloseKeyboard()
}</span>

// GetKey gets a key from the keyboard.
func GetKey(timeoutSec int) (string, error) <span class="cov8" title="1">{
        return Ku.GetKey(timeoutSec)
}</span>

// OpenKeyboard opens the keyboard.
func OpenKeyboard() error <span class="cov8" title="1">{
        return Ku.OpenKeyboard()
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package presenter

import (
        "fmt"
        "io"
)

// Print is a function that writes the output to the writer.
func Print(writer io.Writer, output string) error <span class="cov8" title="1">{
        if output != "" &amp;&amp; output != "\n" </span><span class="cov8" title="1">{
                _, err := fmt.Fprintf(writer, "%s\n", output)
                return err
        }</span> else<span class="cov8" title="1"> {
                _, err := fmt.Fprintln(writer)
                return err
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package presenter

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

var (
        // Pu is a variable that contains the PromptUtil struct for injecting dependencies in testing.
        Pu = utility.NewPromptUtil(proxy.NewPromptui())
)

// RunPrompt runs the prompt.
func RunPrompt(label string) (string, error) <span class="cov8" title="1">{
        prompt := Pu.GetPrompt(label)
        return prompt.Run()
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package presenter

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
        "github.com/yanosea/jrp/v2/pkg/utility"
)

var (
        // Su is a variable that contains the SpinnerUtil struct for injecting dependencies in testing.
        Su = utility.NewSpinnerUtil(proxy.NewSpinners())
        // spinner is a variable that contains the Spinner struct.
        spinner proxy.Spinner
)

// StartSpinner gets and starts the spinner.
func StartSpinner(isRversed bool, color string, suffix string) error <span class="cov8" title="1">{
        sp, err := Su.GetSpinner(isRversed, color, suffix)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">spinner = sp
        sp.Start()

        return nil</span>
}

// StopSpinner stops the spinner.
func StopSpinner() <span class="cov8" title="1">{
        if spinner != nil </span><span class="cov8" title="1">{
                spinner.Stop()
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/jrp": {
            "get": {
                "description": "returns a randomly generated Japanese phrase.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "jrp"
                ],
                "summary": "get a random Japanese phrase.",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_yanosea_jrp_v2_app_presentation_api_jrp-server_formatter.JrpJsonOutputDto"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_yanosea_jrp_v2_app_presentation_api_jrp-server_formatter.JrpJsonOutputDto": {
            "description": "response format for jrp",
            "type": "object",
            "properties": {
                "phrase": {
                    "description": "@Description Generated Japanese phrase",
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{},
        Title:            "JRP API",
        Description:      "jrp api server",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package utility

import (
        "os"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// Capturer is an interface that captures the output of a function.
type Capturer interface {
        CaptureOutput(fnc func()) (string, string, error)
}

// capturer is a struct that implements the Captures interface.
type capturer struct {
        // stdBuffer is a buffer for standard output.
        stdBuffer proxy.Buffer
        // errBuffer is a buffer for error output.
        errBuffer proxy.Buffer
}

// NewCapturer returns a new instance of the capturer struct.
func NewCapturer(
        stdBuffer proxy.Buffer,
        errBuffer proxy.Buffer,
) *capturer <span class="cov8" title="1">{
        return &amp;capturer{
                stdBuffer: stdBuffer,
                errBuffer: errBuffer,
        }
}</span>

// CaptureOutput captures the output of a function.
func (c *capturer) CaptureOutput(fnc func()) (string, string, error) <span class="cov8" title="1">{
        origStdout := os.Stdout
        origStderr := os.Stderr
        defer func() </span><span class="cov8" title="1">{
                os.Stdout = origStdout
                os.Stderr = origStderr
        }</span>()

        <span class="cov8" title="1">rOut, wOut, _ := os.Pipe()
        rErr, wErr, _ := os.Pipe()
        os.Stdout = wOut
        os.Stderr = wErr

        fnc()

        if err := wOut.Close(); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">if err := wErr.Close(); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if _, err := c.stdBuffer.ReadFrom(rOut); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if _, err := c.errBuffer.ReadFrom(rErr); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">stdout := c.stdBuffer.String()
        errout := c.errBuffer.String()

        c.stdBuffer.Reset()
        c.errBuffer.Reset()

        return stdout, errout, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// DownloadUtil is an interface that contains the utility functions for downloading files.
type DownloadUtil interface {
        Download(url string) (proxy.Response, error)
}

// downloadUtil is a struct that contains the utility functions for downloading files.
type downloadUtil struct {
        http proxy.Http
}

// NewDownloadUtil returns a new instance of the DownloadUtil struct.
func NewDownloadUtil(http proxy.Http) DownloadUtil <span class="cov8" title="1">{
        return &amp;downloadUtil{
                http: http,
        }
}</span>

// Download downloads a file from the given URL.
func (d *downloadUtil) Download(url string) (proxy.Response, error) <span class="cov8" title="1">{
        if res, err := d.http.Get(url); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                return res, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package utility

import (
        "io"
        "path/filepath"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// FileUtil is an interface that contains the utility functions for file operations.
type FileUtil interface {
        ExtractGzFile(gzFilePath, destDir string) error
        GetXDGDataHome() (string, error)
        HideFile(filePath string) (string, error)
        IsExist(name string) bool
        MkdirIfNotExist(dirPath string) error
        RemoveAll(path string) error
        SaveToTempFile(body io.Reader, fileName string) (string, error)
        UnhideFile(filePath string) error
}

// fileUtil is a struct that contains the utility functions for file operations.
type fileUtil struct {
        gzip proxy.Gzip
        io   proxy.Io
        os   proxy.Os
}

// NewFileUtil returns a new instance of the FileUtil struct.
func NewFileUtil(
        gzip proxy.Gzip,
        io proxy.Io,
        os proxy.Os,
) FileUtil <span class="cov8" title="1">{
        return &amp;fileUtil{
                gzip: gzip,
                io:   io,
                os:   os,
        }
}</span>

// ExtractGzFile extracts a gzipped file to the destination directory.
func (f *fileUtil) ExtractGzFile(gzFilePath, destFilePath string) error <span class="cov8" title="1">{
        var deferErr error
        gzFile, err := f.os.Open(gzFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = gzFile.Close()
        }</span>()

        <span class="cov8" title="1">gzReader, err := f.gzip.NewReader(gzFile)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = gzReader.Close()
        }</span>()

        <span class="cov8" title="1">destFile, err := f.os.Create(destFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = destFile.Close()
        }</span>()

        <span class="cov8" title="1">if _, err := f.io.Copy(destFile, gzReader); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return deferErr</span>
}

// GetXDGDataHome returns the XDG data home directory.
func (f *fileUtil) GetXDGDataHome() (string, error) <span class="cov8" title="1">{
        xdgDataHome := f.os.Getenv("XDG_DATA_HOME")
        if xdgDataHome == "" </span><span class="cov8" title="1">{
                homeDir, err := f.os.UserHomeDir()
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>

                <span class="cov8" title="1">xdgDataHome = filepath.Join(homeDir, ".local", "share")</span>
        }

        <span class="cov8" title="1">return xdgDataHome, nil</span>
}

// HideFile hides the file by adding a dot prefix to the file name.
func (f *fileUtil) HideFile(filePath string) (string, error) <span class="cov8" title="1">{
        hiddenFilePath := filepath.Join(filepath.Dir(filePath), "."+filepath.Base(filePath))
        if err := f.os.Rename(filePath, hiddenFilePath); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hiddenFilePath, nil</span>
}

// IsExist checks if the file or directory exists.
func (f *fileUtil) IsExist(name string) bool <span class="cov8" title="1">{
        _, err := f.os.Stat(name)
        return !f.os.IsNotExist(err)
}</span>

// MkdirIfNotExist creates a directory if it does not exist.
func (f *fileUtil) MkdirIfNotExist(dirPath string) error <span class="cov8" title="1">{
        if _, err := f.os.Stat(dirPath); f.os.IsNotExist(err) </span><span class="cov8" title="1">{
                if err := f.os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RemoveAll removes path and any children it contains.
func (f *fileUtil) RemoveAll(path string) error <span class="cov8" title="1">{
        return f.os.RemoveAll(path)
}</span>

// SaveToTempFile saves the body to a temporary file.
func (f *fileUtil) SaveToTempFile(body io.Reader, fileName string) (string, error) <span class="cov8" title="1">{
        var deferErr error
        tempFilePath := filepath.Join(f.os.TempDir(), fileName)

        file, err := f.os.Create(tempFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = file.Close()
        }</span>()

        <span class="cov8" title="1">if _, err := f.io.Copy(file, body); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tempFilePath, deferErr</span>
}

// UnhideFile unhides the file by removing the dot prefix from the file name.
func (f *fileUtil) UnhideFile(hiddenFilePath string) error <span class="cov8" title="1">{
        filePath := filepath.Join(filepath.Dir(hiddenFilePath), filepath.Base(hiddenFilePath)[1:])
        if err := f.os.Rename(hiddenFilePath, filePath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// JsonUtil is an interface that contains the utility functions for JSON.
type JsonUtil interface {
        Marshal(v interface{}) ([]byte, error)
}

// jsonUtil is a struct that contains the utility functions for JSON.
type jsonUtil struct {
        json proxy.Json
}

// NewJsonUtil returns a new instance of the JsonUtil struct.
func NewJsonUtil(json proxy.Json) JsonUtil <span class="cov8" title="1">{
        return &amp;jsonUtil{
                json: json,
        }
}</span>

// Marshal marshals v into JSON.
func (ju *jsonUtil) Marshal(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        return ju.json.Marshal(v)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// KeyboardUtil provides the utility for the keyboard.
type KeyboardUtil interface {
        CloseKeyboard() error
        GetKey(timeoutSec int) (string, error)
        OpenKeyboard() error
}

// keyboardUtil is a struct that implements the KeyboardUtil interface.
type keyboardUtil struct {
        keyboard proxy.Keyboard
}

// NewKeyboardUtil returns a new instance of the KeyboardUtil.
func NewKeyboardUtil(
        keyboard proxy.Keyboard,
) KeyboardUtil <span class="cov8" title="1">{
        return &amp;keyboardUtil{
                keyboard: keyboard,
        }
}</span>

// CloseKeyboard closes the keyboard.
func (k *keyboardUtil) CloseKeyboard() error <span class="cov8" title="1">{
        return k.keyboard.Close()
}</span>

// GetKey returns a key from the keyboard.
func (k *keyboardUtil) GetKey(timeoutSec int) (string, error) <span class="cov8" title="1">{
        rune, _, err := k.keyboard.GetKey(timeoutSec)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(rune), nil</span>
}

// OpenKeyboard opens the keyboard.
func (k *keyboardUtil) OpenKeyboard() error <span class="cov8" title="1">{
        return k.keyboard.Open()
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

type PromptUtil interface {
        GetPrompt(label string) proxy.Prompt
}

// promptUtil is a struct that implements the PromptUtil interface.
type promptUtil struct {
        promptui proxy.Promptui
}

// NewPromptUtil returns a new instance of the promptUtil struct.
func NewPromptUtil(
        promptui proxy.Promptui,
) PromptUtil <span class="cov8" title="1">{
        return &amp;promptUtil{
                promptui: promptui,
        }
}</span>

// GetPrompt returns a new instance of the promptui.Prompt.
func (p *promptUtil) GetPrompt(label string) proxy.Prompt <span class="cov8" title="1">{
        prompt := p.promptui.NewPrompt()
        prompt.SetLabel(label)

        return prompt
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// RandUtil is an interface that contains the utility functions for generating random numbers.
type RandUtil interface {
        GenerateRandomNumber(max int) int
}

// randUtil is a struct that contains the utility functions for generating random numbers.
type randUtil struct {
        rand proxy.Rand
}

// NewRandUtil returns a new instance of the RandomUtil struct.
func NewRandUtil(rand proxy.Rand) RandUtil <span class="cov8" title="1">{
        return &amp;randUtil{
                rand: rand,
        }
}</span>

// GenerateRandomNumber generates a random number between min and max.
func (ru *randUtil) GenerateRandomNumber(max int) int <span class="cov8" title="1">{
        if max &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return ru.rand.Intn(max)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

type SpinnerUtil interface {
        GetSpinner(isReversed bool, color string, suffix string) (proxy.Spinner, error)
}

// spinnerUtil is a struct that implements the SpinnerUtil interface.
type spinnerUtil struct {
        spinners proxy.Spinners
}

// NewSpinnerUtil returns a new instance of the spinnerUtil struct.
func NewSpinnerUtil(
        spinners proxy.Spinners,
) SpinnerUtil <span class="cov8" title="1">{
        return &amp;spinnerUtil{
                spinners: spinners,
        }
}</span>

// GetSpinner returns a new instance of the spinner.Spinner.
func (s *spinnerUtil) GetSpinner(isReversed bool, color string, suffix string) (proxy.Spinner, error) <span class="cov8" title="1">{
        spinner := s.spinners.NewSpinner()
        if isReversed </span><span class="cov8" title="1">{
                spinner.Reverse()
        }</span>
        <span class="cov8" title="1">if err := spinner.SetColor(color); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">spinner.SetSuffix(suffix)

        return spinner, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package utility

import (
        "strings"
)

// StringsUtil is an interface that contains the utility functions for manipulating strings.
type StringsUtil interface {
        RemoveNewLines(s string) string
        RemoveSpaces(s string) string
        RemoveTabs(s string) string
}

// stringsUtil is a struct that contains the utility functions for manipulating strings.
type stringsUtil struct{}

// NewStringsUtil returns a new instance of the StringsUtil struct.
func NewStringsUtil() StringsUtil <span class="cov8" title="1">{
        return &amp;stringsUtil{}
}</span>

// RemoveNewLines removes all new lines from the given strings.
func (s *stringsUtil) RemoveNewLines(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(str, "\n", "")
}</span>

// RemoveSpaces removes all spaces from the given strings.
func (s *stringsUtil) RemoveSpaces(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(str, " ", "")
}</span>

// RemoveTabs removes all tabs from the given strings.
func (s *stringsUtil) RemoveTabs(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(str, "\t", "")
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package utility

import (
        "io"

        "github.com/olekukonko/tablewriter"

        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// TableWriterUtil is an interface that contains the utility functions for writing tables.
type TableWriterUtil interface {
        GetNewDefaultTable(writer io.Writer) proxy.Table
}

// tableWriterUtil is a struct that contains the utility functions for writing tables.
type tableWriterUtil struct {
        tableWriter proxy.TableWriter
}

// NewTableWriterUtil returns a new instance of the TableWriterUtil interface.
func NewTableWriterUtil(tableWriter proxy.TableWriter) TableWriterUtil <span class="cov8" title="1">{
        return &amp;tableWriterUtil{
                tableWriter: tableWriter,
        }
}</span>

// GetNewDefaultTable returns a new instance of the default table.
func (t *tableWriterUtil) GetNewDefaultTable(writer io.Writer) proxy.Table <span class="cov8" title="1">{
        table := t.tableWriter.NewTable(writer)
        table.SetAutoWrapText(false)
        table.SetAutoFormatHeaders(true)
        table.SetHeaderAlignment(tablewriter.ALIGN_LEFT)
        table.SetAlignment(tablewriter.ALIGN_LEFT)
        table.SetCenterSeparator("")
        table.SetColumnSeparator("")
        table.SetRowSeparator("")
        table.SetHeaderLine(false)
        table.SetBorder(false)
        table.SetTablePadding("\t")
        table.SetNoWhiteSpace(true)
        return table
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package utility

import (
        "github.com/yanosea/jrp/v2/pkg/proxy"
)

// VersionUtil is an interface that provides the version of the application.
type VersionUtil interface {
        GetVersion(version string) string
}

// versionUtil is a struct that implements the VersionUtil interface.
type versionUtil struct {
        debug proxy.Debug
}

// NewVersionUtil returns a new instance of the versionUtil struct.
func NewVersionUtil(
        debug proxy.Debug,
) VersionUtil <span class="cov8" title="1">{
        return &amp;versionUtil{
                debug: debug,
        }
}</span>

// GetVersion returns the version of the application.
func (v *versionUtil) GetVersion(version string) string <span class="cov8" title="1">{
        // if version is embedded, return it.
        if version != "" </span><span class="cov8" title="1">{
                return version
        }</span>

        <span class="cov8" title="1">if i, ok := v.debug.ReadBuildInfo(); !ok </span><span class="cov8" title="1">{
                return "unknown"
        }</span> else<span class="cov8" title="1"> if i.Main.Version != "" </span><span class="cov8" title="1">{
                return i.Main.Version
        }</span> else<span class="cov8" title="1"> {
                return "dev"
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
