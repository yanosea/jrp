
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repository: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yanosea/jrp/app/database/jrp/repository/repository.go (100.0%)</option>
				
				<option value="file1">github.com/yanosea/jrp/app/database/wnjpn/repository/repository.go (100.0%)</option>
				
				<option value="file2">github.com/yanosea/jrp/app/library/dbfiledirpathprovider/dbfiledirpathprovider.go (100.0%)</option>
				
				<option value="file3">github.com/yanosea/jrp/app/library/downloader/downloader.go (100.0%)</option>
				
				<option value="file4">github.com/yanosea/jrp/app/library/generator/generator.go (100.0%)</option>
				
				<option value="file5">github.com/yanosea/jrp/app/library/jrpwriter/jrpwriter.go (100.0%)</option>
				
				<option value="file6">github.com/yanosea/jrp/app/library/utility/utility.go (100.0%)</option>
				
				<option value="file7">github.com/yanosea/jrp/app/library/versionprovider/versionprovider.go (100.0%)</option>
				
				<option value="file8">github.com/yanosea/jrp/app/proxy/buffer/bufferproxy.go (100.0%)</option>
				
				<option value="file9">github.com/yanosea/jrp/app/proxy/cobra/cobraproxy.go (100.0%)</option>
				
				<option value="file10">github.com/yanosea/jrp/app/proxy/cobra/commandinstance.go (100.0%)</option>
				
				<option value="file11">github.com/yanosea/jrp/app/proxy/color/colorproxy.go (100.0%)</option>
				
				<option value="file12">github.com/yanosea/jrp/app/proxy/debug/debugproxy.go (100.0%)</option>
				
				<option value="file13">github.com/yanosea/jrp/app/proxy/filepath/filepathproxy.go (100.0%)</option>
				
				<option value="file14">github.com/yanosea/jrp/app/proxy/fmt/fmtproxy.go (100.0%)</option>
				
				<option value="file15">github.com/yanosea/jrp/app/proxy/gzip/gzipproxy.go (100.0%)</option>
				
				<option value="file16">github.com/yanosea/jrp/app/proxy/http/httpproxy.go (100.0%)</option>
				
				<option value="file17">github.com/yanosea/jrp/app/proxy/io/ioproxy.go (100.0%)</option>
				
				<option value="file18">github.com/yanosea/jrp/app/proxy/os/fileinstance.go (100.0%)</option>
				
				<option value="file19">github.com/yanosea/jrp/app/proxy/os/osproxy.go (100.0%)</option>
				
				<option value="file20">github.com/yanosea/jrp/app/proxy/pflag/flagsetinstance.go (100.0%)</option>
				
				<option value="file21">github.com/yanosea/jrp/app/proxy/promptui/promptinstance.go (100.0%)</option>
				
				<option value="file22">github.com/yanosea/jrp/app/proxy/promptui/promptuiproxy.go (100.0%)</option>
				
				<option value="file23">github.com/yanosea/jrp/app/proxy/rand/randproxy.go (100.0%)</option>
				
				<option value="file24">github.com/yanosea/jrp/app/proxy/sort/sortproxy.go (100.0%)</option>
				
				<option value="file25">github.com/yanosea/jrp/app/proxy/spinner/spinnerinstance.go (100.0%)</option>
				
				<option value="file26">github.com/yanosea/jrp/app/proxy/spinner/spinnerproxy.go (100.0%)</option>
				
				<option value="file27">github.com/yanosea/jrp/app/proxy/sql/dbinstance.go (100.0%)</option>
				
				<option value="file28">github.com/yanosea/jrp/app/proxy/sql/nullstringinstance.go (100.0%)</option>
				
				<option value="file29">github.com/yanosea/jrp/app/proxy/sql/resultinstance.go (100.0%)</option>
				
				<option value="file30">github.com/yanosea/jrp/app/proxy/sql/rowinstance.go (100.0%)</option>
				
				<option value="file31">github.com/yanosea/jrp/app/proxy/sql/rowsinstance.go (100.0%)</option>
				
				<option value="file32">github.com/yanosea/jrp/app/proxy/sql/sqlproxy.go (100.0%)</option>
				
				<option value="file33">github.com/yanosea/jrp/app/proxy/sql/stmtinstance.go (100.0%)</option>
				
				<option value="file34">github.com/yanosea/jrp/app/proxy/sql/txinstance.go (100.0%)</option>
				
				<option value="file35">github.com/yanosea/jrp/app/proxy/strconv/strconvproxy.go (100.0%)</option>
				
				<option value="file36">github.com/yanosea/jrp/app/proxy/strings/stringsproxy.go (100.0%)</option>
				
				<option value="file37">github.com/yanosea/jrp/app/proxy/tablewriter/tableinstance.go (100.0%)</option>
				
				<option value="file38">github.com/yanosea/jrp/app/proxy/tablewriter/tablewriterproxy.go (100.0%)</option>
				
				<option value="file39">github.com/yanosea/jrp/app/proxy/time/timeinstance.go (100.0%)</option>
				
				<option value="file40">github.com/yanosea/jrp/app/proxy/time/timeproxy.go (100.0%)</option>
				
				<option value="file41">github.com/yanosea/jrp/app/proxy/user/userproxy.go (100.0%)</option>
				
				<option value="file42">github.com/yanosea/jrp/cmd/completion.go (100.0%)</option>
				
				<option value="file43">github.com/yanosea/jrp/cmd/completion_bash.go (100.0%)</option>
				
				<option value="file44">github.com/yanosea/jrp/cmd/completion_fish.go (100.0%)</option>
				
				<option value="file45">github.com/yanosea/jrp/cmd/completion_powershell.go (100.0%)</option>
				
				<option value="file46">github.com/yanosea/jrp/cmd/completion_zsh.go (100.0%)</option>
				
				<option value="file47">github.com/yanosea/jrp/cmd/constant/download.go (100.0%)</option>
				
				<option value="file48">github.com/yanosea/jrp/cmd/constant/favorite.go (100.0%)</option>
				
				<option value="file49">github.com/yanosea/jrp/cmd/constant/favorite_add.go (100.0%)</option>
				
				<option value="file50">github.com/yanosea/jrp/cmd/constant/favorite_clear.go (100.0%)</option>
				
				<option value="file51">github.com/yanosea/jrp/cmd/constant/favorite_remove.go (100.0%)</option>
				
				<option value="file52">github.com/yanosea/jrp/cmd/constant/favorite_search.go (100.0%)</option>
				
				<option value="file53">github.com/yanosea/jrp/cmd/constant/favorite_show.go (100.0%)</option>
				
				<option value="file54">github.com/yanosea/jrp/cmd/constant/generate.go (100.0%)</option>
				
				<option value="file55">github.com/yanosea/jrp/cmd/constant/history.go (100.0%)</option>
				
				<option value="file56">github.com/yanosea/jrp/cmd/constant/history_clear.go (100.0%)</option>
				
				<option value="file57">github.com/yanosea/jrp/cmd/constant/history_remove.go (100.0%)</option>
				
				<option value="file58">github.com/yanosea/jrp/cmd/constant/history_search.go (100.0%)</option>
				
				<option value="file59">github.com/yanosea/jrp/cmd/constant/history_show.go (100.0%)</option>
				
				<option value="file60">github.com/yanosea/jrp/cmd/download.go (100.0%)</option>
				
				<option value="file61">github.com/yanosea/jrp/cmd/favorite.go (100.0%)</option>
				
				<option value="file62">github.com/yanosea/jrp/cmd/favorite_add.go (100.0%)</option>
				
				<option value="file63">github.com/yanosea/jrp/cmd/favorite_clear.go (100.0%)</option>
				
				<option value="file64">github.com/yanosea/jrp/cmd/favorite_remove.go (100.0%)</option>
				
				<option value="file65">github.com/yanosea/jrp/cmd/favorite_search.go (100.0%)</option>
				
				<option value="file66">github.com/yanosea/jrp/cmd/favorite_show.go (100.0%)</option>
				
				<option value="file67">github.com/yanosea/jrp/cmd/generate.go (100.0%)</option>
				
				<option value="file68">github.com/yanosea/jrp/cmd/history.go (100.0%)</option>
				
				<option value="file69">github.com/yanosea/jrp/cmd/history_clear.go (100.0%)</option>
				
				<option value="file70">github.com/yanosea/jrp/cmd/history_remove.go (100.0%)</option>
				
				<option value="file71">github.com/yanosea/jrp/cmd/history_search.go (100.0%)</option>
				
				<option value="file72">github.com/yanosea/jrp/cmd/history_show.go (100.0%)</option>
				
				<option value="file73">github.com/yanosea/jrp/cmd/root.go (100.0%)</option>
				
				<option value="file74">github.com/yanosea/jrp/cmd/version.go (100.0%)</option>
				
				<option value="file75">github.com/yanosea/jrp/main.go (100.0%)</option>
				
				<option value="file76">github.com/yanosea/jrp/test/testutility/capture.go (100.0%)</option>
				
				<option value="file77">github.com/yanosea/jrp/test/testutility/jrpchecker.go (100.0%)</option>
				
				<option value="file78">github.com/yanosea/jrp/test/testutility/utility.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package repository

import (
        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository/query"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strings"
)

// JrpRepositoryInterface is an interface for JrpRepository.
type JrpRepositoryInterface interface {
        SaveHistory(jrpDBFilePath string, jrps []*model.Jrp) (SaveStatus, error)
        GetAllHistory(jrpDBFilePath string) ([]*model.Jrp, error)
        GetHistoryWithNumber(jrpDBFilePath string, number int) ([]*model.Jrp, error)
        SearchHistoryWithNumber(jrpDBFilePath string, number int, keywords []string, and bool) ([]*model.Jrp, error)
        SearchAllHistory(jrpDBFilePath string, keywords []string, and bool) ([]*model.Jrp, error)
        RemoveHistoryByIDs(jrpDBFilePath string, ids []int, force bool) (RemoveStatus, error)
        RemoveHistoryAll(jrpDBFilePath string, force bool) (RemoveStatus, error)
        GetAllFavorite(jrpDBFilePath string) ([]*model.Jrp, error)
        GetFavoriteWithNumber(jrpDBFilePath string, number int) ([]*model.Jrp, error)
        SearchAllFavorite(jrpDBFilePath string, keywords []string, and bool) ([]*model.Jrp, error)
        SearchFavoriteWithNumber(jrpDBFilePath string, number int, keywords []string, and bool) ([]*model.Jrp, error)
        AddFavoriteByIDs(jrpDBFilePath string, ids []int) (AddStatus, error)
        RemoveFavoriteByIDs(jrpDBFilePath string, ids []int) (RemoveStatus, error)
        RemoveFavoriteAll(jrpDBFilePath string) (RemoveStatus, error)
}

// JrpRepository is a struct that implements JrpRepositoryInterface.
type JrpRepository struct {
        FmtProxy     fmtproxy.Fmt
        SortProxy    sortproxy.Sort
        SqlProxy     sqlproxy.Sql
        StringsProxy stringsproxy.Strings
}

// New is a constructor for JrpRepository.
func New(
        fmtProxy fmtproxy.Fmt,
        sortProxy sortproxy.Sort,
        sqlProxy sqlproxy.Sql,
        stringsProxy stringsproxy.Strings,
) *JrpRepository <span class="cov8" title="1">{
        return &amp;JrpRepository{
                FmtProxy:     fmtProxy,
                SortProxy:    sortProxy,
                SqlProxy:     sqlProxy,
                StringsProxy: stringsProxy,
        }
}</span>

// SaveHistory saves jrps as  history.
func (j JrpRepository) SaveHistory(jrpDBFilePath string, jrps []*model.Jrp) (SaveStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // if jrps is nil or empty, return nil
        if jrps == nil || len(jrps) &lt;= 0 </span><span class="cov8" title="1">{
                return SavedNone, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return SavedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return SavedFailed, err
        }</span>

        // start transaction
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return SavedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = tx.Rollback()
        }</span>()

        // prepare insert statement
        <span class="cov8" title="1">stmt, err := db.Prepare(query.InsertJrp)
        if err != nil </span><span class="cov8" title="1">{
                return SavedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = stmt.Close()
        }</span>()

        // insert jrp and count affected rows
        <span class="cov8" title="1">count := int64(0)
        for _, jrp := range jrps </span><span class="cov8" title="1">{
                res, err := stmt.Exec(
                        jrp.Phrase,
                        jrp.Prefix,
                        jrp.Suffix,
                        jrp.CreatedAt,
                        jrp.UpdatedAt,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return SavedFailed, err
                }</span>

                // get count
                <span class="cov8" title="1">c, err := res.RowsAffected()
                if err != nil </span><span class="cov8" title="1">{
                        // failed to get rows affected
                        return SavedFailed, err
                }</span>
                <span class="cov8" title="1">count += c

                // set ID
                i, err := res.LastInsertId()
                if err != nil </span><span class="cov8" title="1">{
                        return SavedFailed, err
                }</span>
                <span class="cov8" title="1">jrp.ID = int(i)</span>
        }

        // commit transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return SavedFailed, err
        }</span>

        <span class="cov8" title="1">if count != int64(len(jrps)) </span><span class="cov8" title="1">{
                // not all rows affected
                return SavedNotAll, nil
        }</span>

        <span class="cov8" title="1">return SavedSuccessfully, deferErr</span>
}

// GetAllHistory gets all jrps as history.
func (j JrpRepository) GetAllHistory(jrpDBFilePath string) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // get all history from jrp
        <span class="cov8" title="1">rows, err := db.Query(query.GetAllJrp)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var allHistory []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allHistory = append(allHistory, history)</span>
        }

        <span class="cov8" title="1">return allHistory, deferErr</span>
}

// GetHistoryWithNumber gets history with number.
func (j JrpRepository) GetHistoryWithNumber(jrpDBFilePath string, number int) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if number &lt;= 0 </span><span class="cov8" title="1">{
                // if number is less than or equal to 0, return nil
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // prepare the query
        <span class="cov8" title="1">stmt, err := db.Prepare(query.GetJrpByNumber)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = stmt.Close()
        }</span>()

        // get history from jrp by number
        <span class="cov8" title="1">rows, err := stmt.Query(number)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var allHistory []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allHistory = append(allHistory, history)</span>
        }

        // sort by ID asc
        <span class="cov8" title="1">j.SortProxy.Slice(allHistory, func(i, j int) bool </span><span class="cov8" title="1">{
                return allHistory[i].ID &lt; allHistory[j].ID
        }</span>)

        <span class="cov8" title="1">return allHistory, deferErr</span>
}

// SearchAllHistory searches all jrps as history with keywords.
func (j JrpRepository) SearchAllHistory(jrpDBFilePath string, keywords []string, and bool) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if keywords == nil || len(keywords) &lt;= 0 </span><span class="cov8" title="1">{
                // if keywords is nil or empty, return nil
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // build query
        <span class="cov8" title="1">args := []interface{}{}
        conditions := []string{}

        // build conditions
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                conditions = append(conditions, "jrp.Phrase LIKE ?")
                args = append(args, "%"+keyword+"%")
        }</span>

        // build where clause
        <span class="cov8" title="1">var whereClause string
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                separator := " OR "
                if and </span><span class="cov8" title="1">{
                        separator = " AND "
                }</span>
                <span class="cov8" title="1">whereClause = j.StringsProxy.Join(conditions, separator)</span>
        }

        <span class="cov8" title="1">query := j.FmtProxy.Sprintf(query.SearchAllJrp, whereClause)

        // execute query
        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var searchedAllHistory []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">searchedAllHistory = append(searchedAllHistory, history)</span>
        }

        <span class="cov8" title="1">return searchedAllHistory, deferErr</span>
}

// SearchHistoryWithNumber searches jrps as history with number and keywords.
func (j JrpRepository) SearchHistoryWithNumber(
        jrpDBFilePath string,
        number int,
        keywords []string,
        and bool,
) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if number &lt;= 0 || keywords == nil || len(keywords) &lt;= 0 </span><span class="cov8" title="1">{
                // if number is less than or equal to 0 or keywords is nil or empty
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // build query
        <span class="cov8" title="1">args := []interface{}{}
        conditions := []string{}

        // build conditions
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                conditions = append(conditions, "jrp.Phrase LIKE ?")
                args = append(args, "%"+keyword+"%")
        }</span>

        // build where clause
        <span class="cov8" title="1">var whereClause string
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                separator := " OR "
                if and </span><span class="cov8" title="1">{
                        separator = " AND "
                }</span>
                <span class="cov8" title="1">whereClause = j.StringsProxy.Join(conditions, separator)</span>
        }

        <span class="cov8" title="1">query := j.FmtProxy.Sprintf(query.SearchJrpByNumber, whereClause)
        args = append(args, number)

        // execute query
        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var searchedHistory []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                history := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;history.ID,
                        &amp;history.Phrase,
                        &amp;history.Prefix,
                        &amp;history.Suffix,
                        &amp;history.IsFavorited,
                        &amp;history.CreatedAt,
                        &amp;history.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">searchedHistory = append(searchedHistory, history)</span>
        }

        // sort by ID asc
        <span class="cov8" title="1">j.SortProxy.Slice(searchedHistory, func(i, j int) bool </span><span class="cov8" title="1">{
                return searchedHistory[i].ID &lt; searchedHistory[j].ID
        }</span>)

        <span class="cov8" title="1">return searchedHistory, deferErr</span>
}

// RemoveHistoryByIDs removes jrps by IDs.
func (j JrpRepository) RemoveHistoryByIDs(jrpDBFilePath string, ids []int, force bool) (RemoveStatus, error) <span class="cov8" title="1">{
        var deferErr error
        if ids == nil || len(ids) &lt;= 0 </span><span class="cov8" title="1">{
                // if ids is nil or empty, return nil
                return RemovedNone, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // create the correct number of placeholders for the IDs
        <span class="cov8" title="1">placeholders := make([]string, len(ids))
        for i := range ids </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>
        <span class="cov8" title="1">placeholdersStr := j.StringsProxy.Join(placeholders, ",")

        // prepare the delete q with the correct number of placeholders
        var q string
        if force </span><span class="cov8" title="1">{
                q = j.FmtProxy.Sprintf(query.RemoveJrpByIDs, placeholdersStr)
        }</span> else<span class="cov8" title="1"> {
                q = j.FmtProxy.Sprintf(query.RemoveJrpByIDsExceptFavorite, placeholdersStr)
        }</span>
        <span class="cov8" title="1">stmt, err := db.Prepare(q)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = stmt.Close()
        }</span>()

        // convert ids to interface slice for Exec
        <span class="cov8" title="1">args := make([]interface{}, len(ids))
        for i, id := range ids </span><span class="cov8" title="1">{
                args[i] = id
        }</span>

        // execute the delete query
        <span class="cov8" title="1">res, err := stmt.Exec(args...)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        <span class="cov8" title="1">if count, err := res.RowsAffected(); err != nil </span><span class="cov8" title="1">{
                // failed to get rows affected
                return RemovedFailed, err
        }</span> else<span class="cov8" title="1"> if count &lt;= 0 </span><span class="cov8" title="1">{
                // no rows affected
                return RemovedNone, nil
        }</span> else<span class="cov8" title="1"> if count != int64(len(ids)) </span><span class="cov8" title="1">{
                // not all rows affected
                return RemovedNotAll, nil
        }</span>

        <span class="cov8" title="1">return RemovedSuccessfully, deferErr</span>
}

// RemoveHistoryAll removes all jrps.
func (j JrpRepository) RemoveHistoryAll(jrpDBFilePath string, force bool) (RemoveStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // start transaction
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = tx.Rollback()
        }</span>()

        // set q
        <span class="cov8" title="1">var q string
        if force </span><span class="cov8" title="1">{
                q = query.RemoveAllJrp
        }</span> else<span class="cov8" title="1"> {
                q = query.RemoveAllJrpExceptFavorite
        }</span>

        // remove all jrp
        <span class="cov8" title="1">var res sqlproxy.ResultInstanceInterface
        if res, err = tx.Exec(q); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // check if the count of rows is zero after execution
        <span class="cov8" title="1">checkCount := query.CountJrp
        var count int
        if err := tx.QueryRow(checkCount).Scan(&amp;count); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                // remove jrp sequence
                if _, err := tx.Exec(query.RemoveJrpSeq); err != nil </span><span class="cov8" title="1">{
                        return RemovedFailed, err
                }</span>
        }

        // check rows affected by the remove jrp query
        <span class="cov8" title="1">if affected, err := res.RowsAffected(); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span> else<span class="cov8" title="1"> if affected == 0 </span><span class="cov8" title="1">{
                return RemovedNone, nil
        }</span>

        // commit transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        <span class="cov8" title="1">return RemovedSuccessfully, deferErr</span>
}

// GetAllFavorite gets all jrps that are favorited.
func (j JrpRepository) GetAllFavorite(jrpDBFilePath string) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // get all favorite from jrp
        <span class="cov8" title="1">rows, err := db.Query(query.GetAllFavorite)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var allFavorite []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                favorite := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;favorite.ID,
                        &amp;favorite.Phrase,
                        &amp;favorite.Prefix,
                        &amp;favorite.Suffix,
                        &amp;favorite.IsFavorited,
                        &amp;favorite.CreatedAt,
                        &amp;favorite.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allFavorite = append(allFavorite, favorite)</span>
        }

        <span class="cov8" title="1">return allFavorite, deferErr</span>
}

// GetFavoriteWithNumber gets jrps that are favorited with number.
func (j JrpRepository) GetFavoriteWithNumber(jrpDBFilePath string, number int) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if number &lt;= 0 </span><span class="cov8" title="1">{
                // if number is less than or equal to 0, return nil
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // prepare the query
        <span class="cov8" title="1">stmt, err := db.Prepare(query.GetFavoriteByNumber)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = stmt.Close()
        }</span>()

        // get favorite from jrp by number
        <span class="cov8" title="1">rows, err := stmt.Query(number)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var allFavorite []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                favorite := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;favorite.ID,
                        &amp;favorite.Phrase,
                        &amp;favorite.Prefix,
                        &amp;favorite.Suffix,
                        &amp;favorite.IsFavorited,
                        &amp;favorite.CreatedAt,
                        &amp;favorite.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allFavorite = append(allFavorite, favorite)</span>
        }

        // sort by ID asc
        <span class="cov8" title="1">j.SortProxy.Slice(allFavorite, func(i, j int) bool </span><span class="cov8" title="1">{
                return allFavorite[i].ID &lt; allFavorite[j].ID
        }</span>)

        <span class="cov8" title="1">return allFavorite, deferErr</span>
}

// SearchAllFavorite searches all jrps that are favorited with keywords.
func (j JrpRepository) SearchAllFavorite(jrpDBFilePath string, keywords []string, and bool) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if keywords == nil || len(keywords) &lt;= 0 </span><span class="cov8" title="1">{
                // if keywords is nil or empty, return nil
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // build query
        <span class="cov8" title="1">args := []interface{}{}
        conditions := []string{}

        // build conditions
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                conditions = append(conditions, "jrp.Phrase LIKE ?")
                args = append(args, "%"+keyword+"%")
        }</span>

        // build where clause
        <span class="cov8" title="1">var whereClause string
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                separator := " OR "
                if and </span><span class="cov8" title="1">{
                        separator = " AND "
                }</span>
                <span class="cov8" title="1">whereClause = j.StringsProxy.Join(conditions, separator)</span>
        }

        <span class="cov8" title="1">query := j.FmtProxy.Sprintf(query.SearchAllFavorite, whereClause)

        // execute query
        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var searchedAllFavorite []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                favorite := &amp;model.Jrp{}
                if err := rows.Scan(&amp;favorite.ID,
                        &amp;favorite.Phrase,
                        &amp;favorite.Prefix,
                        &amp;favorite.Suffix,
                        &amp;favorite.IsFavorited,
                        &amp;favorite.CreatedAt,
                        &amp;favorite.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">searchedAllFavorite = append(searchedAllFavorite, favorite)</span>
        }

        <span class="cov8" title="1">return searchedAllFavorite, deferErr</span>
}

// SearchFavoriteWithNumber searches jrps that are favorited with number and keywords.
func (j JrpRepository) SearchFavoriteWithNumber(
        jrpDBFilePath string,
        number int,
        keywords []string,
        and bool,
) ([]*model.Jrp, error) <span class="cov8" title="1">{
        var deferErr error
        if number &lt;= 0 || keywords == nil || len(keywords) &lt;= 0 </span><span class="cov8" title="1">{
                // if number is less than or equal to 0 or keywords is nil or empty
                return nil, nil
        }</span>

        // connect to db
        <span class="cov8" title="1">db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // build query
        <span class="cov8" title="1">args := []interface{}{}
        conditions := []string{}

        // build conditions
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                conditions = append(conditions, "jrp.Phrase LIKE ?")
                args = append(args, "%"+keyword+"%")
        }</span>

        // build where clause
        <span class="cov8" title="1">var whereClause string
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                separator := " OR "
                if and </span><span class="cov8" title="1">{
                        separator = " AND "
                }</span>
                <span class="cov8" title="1">whereClause = j.StringsProxy.Join(conditions, separator)</span>
        }

        <span class="cov8" title="1">query := j.FmtProxy.Sprintf(query.SearchFavoriteByNumber, whereClause)
        args = append(args, number)

        // execute query
        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">var searchedFavorite []*model.Jrp
        for rows.Next() </span><span class="cov8" title="1">{
                favorite := &amp;model.Jrp{}
                if err := rows.Scan(
                        &amp;favorite.ID,
                        &amp;favorite.Phrase,
                        &amp;favorite.Prefix,
                        &amp;favorite.Suffix,
                        &amp;favorite.IsFavorited,
                        &amp;favorite.CreatedAt,
                        &amp;favorite.UpdatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">searchedFavorite = append(searchedFavorite, favorite)</span>
        }

        // sort by ID asc
        <span class="cov8" title="1">j.SortProxy.Slice(searchedFavorite, func(i, j int) bool </span><span class="cov8" title="1">{
                return searchedFavorite[i].ID &lt; searchedFavorite[j].ID
        }</span>)

        <span class="cov8" title="1">return searchedFavorite, deferErr</span>
}

// AddFavoriteByIDs adds jrps to favorite by IDs.
func (j JrpRepository) AddFavoriteByIDs(jrpDBFilePath string, ids []int) (AddStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return AddedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return AddedFailed, err
        }</span>

        // create the correct number of placeholders for the IDs
        <span class="cov8" title="1">placeholders := make([]string, len(ids))
        for i := range ids </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>
        <span class="cov8" title="1">placeholdersStr := j.StringsProxy.Join(placeholders, ",")

        // prepare the delete query with the correct number of placeholders
        query := j.FmtProxy.Sprintf(query.AddFavoriteByIDs, placeholdersStr)
        stmt, err := db.Prepare(query)
        if err != nil </span><span class="cov8" title="1">{
                return AddedFailed, err
        }</span>

        // convert ids to interface slice for Exec
        <span class="cov8" title="1">args := make([]interface{}, len(ids))
        for i, id := range ids </span><span class="cov8" title="1">{
                args[i] = id
        }</span>

        // execute the delete query
        <span class="cov8" title="1">res, err := stmt.Exec(args...)
        if err != nil </span><span class="cov8" title="1">{
                return AddedFailed, err
        }</span>

        <span class="cov8" title="1">if count, err := res.RowsAffected(); err != nil </span><span class="cov8" title="1">{
                // failed to get rows affected
                return AddedFailed, err
        }</span> else<span class="cov8" title="1"> if count &lt;= 0 </span><span class="cov8" title="1">{
                // no rows affected
                return AddedNone, nil
        }</span> else<span class="cov8" title="1"> if count != int64(len(ids)) </span><span class="cov8" title="1">{
                // not all rows affected
                return AddedNotAll, nil
        }</span>

        <span class="cov8" title="1">return AddedSuccessfully, deferErr</span>
}

// RemoveFavoriteByIDs removes jrps from favorite by IDs.
func (j JrpRepository) RemoveFavoriteByIDs(jrpDBFilePath string, ids []int) (RemoveStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // create the correct number of placeholders for the IDs
        <span class="cov8" title="1">placeholders := make([]string, len(ids))
        for i := range ids </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>
        <span class="cov8" title="1">placeholdersStr := j.StringsProxy.Join(placeholders, ",")

        // prepare the delete query with the correct number of placeholders
        query := j.FmtProxy.Sprintf(query.RemoveFavoriteByIDs, placeholdersStr)
        stmt, err := db.Prepare(query)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = stmt.Close()
        }</span>()

        // convert ids to interface slice for Exec
        <span class="cov8" title="1">args := make([]interface{}, len(ids))
        for i, id := range ids </span><span class="cov8" title="1">{
                args[i] = id
        }</span>

        // execute the delete query
        <span class="cov8" title="1">res, err := stmt.Exec(args...)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // check rows affected
        <span class="cov8" title="1">if count, err := res.RowsAffected(); err != nil </span><span class="cov8" title="1">{
                // failed to get rows affected
                return RemovedFailed, err
        }</span> else<span class="cov8" title="1"> if count &lt;= 0 </span><span class="cov8" title="1">{
                // no rows affected
                return RemovedNone, nil
        }</span> else<span class="cov8" title="1"> if count != int64(len(ids)) </span><span class="cov8" title="1">{
                // not all rows affected
                return RemovedNotAll, nil
        }</span>

        <span class="cov8" title="1">return RemovedSuccessfully, deferErr</span>
}

// RemoveFavoriteAll removes all jrps from favorite.
func (j JrpRepository) RemoveFavoriteAll(jrpDBFilePath string) (RemoveStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // create table 'jrp'
        <span class="cov8" title="1">if _, err := j.createTableJrp(db); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // start transaction
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = tx.Rollback()
        }</span>()

        // remove all favorite
        <span class="cov8" title="1">var res sqlproxy.ResultInstanceInterface
        if res, err = tx.Exec(query.RemoveAllFavorite); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        // check rows affected
        <span class="cov8" title="1">if count, err := res.RowsAffected(); err != nil </span><span class="cov8" title="1">{
                // failed to get rows affected
                return RemovedFailed, err
        }</span> else<span class="cov8" title="1"> if count &lt;= 0 </span><span class="cov8" title="1">{
                // no rows affected
                return RemovedNone, err
        }</span>

        // commit transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                return RemovedFailed, err
        }</span>

        <span class="cov8" title="1">return RemovedSuccessfully, deferErr</span>
}

// createTableJrp creates table 'jrp'.
func (j JrpRepository) createTableJrp(db sqlproxy.DBInstanceInterface) (sqlproxy.ResultInstanceInterface, error) <span class="cov8" title="1">{
        return db.Exec(query.CreateTableJrp)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package repository

import (
        "github.com/yanosea/jrp/app/database/wnjpn/model"
        "github.com/yanosea/jrp/app/database/wnjpn/repository/query"
        "github.com/yanosea/jrp/app/proxy/sql"
)

// WNJpnRepositoryInterface is an interface for WNJpnRepository.
type WNJpnRepositoryInterface interface {
        GetAllAVNWords(wnJpnDBFilePath string) ([]model.Word, error)
        GetAllNWords(wnJpnDBFilePath string) ([]model.Word, error)
        GetAllAVWords(wnJpnDBFilePath string) ([]model.Word, error)
}

// WNJpnRepository is a struct that implements WNJpnRepositoryInterface.
type WNJpnRepository struct {
        SqlProxy sqlproxy.Sql
}

// New is a constructor for WNJpnRepository.
func New(
        sqlProxy sqlproxy.Sql,
) *WNJpnRepository <span class="cov8" title="1">{
        return &amp;WNJpnRepository{
                SqlProxy: sqlProxy,
        }
}</span>

// GetAllAVNWords gets all AVN words.
func (w *WNJpnRepository) GetAllAVNWords(wnJpnDBFilePath string) ([]model.Word, error) <span class="cov8" title="1">{
        return w.getWords(wnJpnDBFilePath, query.GetAllJapaneseAVNWords)
}</span>

// GetAllNWords gets all N words.
func (w *WNJpnRepository) GetAllNWords(wnJpnDBFilePath string) ([]model.Word, error) <span class="cov8" title="1">{
        return w.getWords(wnJpnDBFilePath, query.GetAllJapaneseNWords)
}</span>

// GetAllAVWords gets all AV words.
func (w *WNJpnRepository) GetAllAVWords(wnJpnDBFilePath string) ([]model.Word, error) <span class="cov8" title="1">{
        return w.getWords(wnJpnDBFilePath, query.GetAllJapaneseAVWords)
}</span>

// getWords gets words.
func (w *WNJpnRepository) getWords(wnJpnDBFilePath string, query string) ([]model.Word, error) <span class="cov8" title="1">{
        var deferErr error
        // connect to db
        db, err := w.SqlProxy.Open(sqlproxy.Sqlite, wnJpnDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        // execute query
        <span class="cov8" title="1">rows, err := db.Query(query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        // scan rows
        <span class="cov8" title="1">allWords := make([]model.Word, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                var word model.Word
                if err := rows.Scan(&amp;word.Lemma, &amp;word.Pos); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allWords = append(allWords, word)</span>
        }

        <span class="cov8" title="1">return allWords, deferErr</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dbfiledirpathprovider

import (
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/user"
)

// DBFileDirPathProvidable is an interface for DBFileDirPathProvider.
type DBFileDirPathProvidable interface {
        GetJrpDBFileDirPath() (string, error)
        GetWNJpnDBFileDirPath() (string, error)
}

// DBFileDirPathProvider is a struct that implements DBFileDirPathProvidable.
type DBFileDirPathProvider struct {
        FilepathProxy filepathproxy.FilePath
        OsProxy       osproxy.Os
        UserProxy     userproxy.User
}

// New is a constructor for DBFileDirPathProvider.
func New(
        filepath filepathproxy.FilePath,
        os osproxy.Os,
        user userproxy.User,
) *DBFileDirPathProvider <span class="cov8" title="1">{
        return &amp;DBFileDirPathProvider{
                FilepathProxy: filepath,
                OsProxy:       os,
                UserProxy:     user,
        }
}</span>

// GetJrpDBFileDirPath provides db file directory path for jrp db file.
func (d *DBFileDirPathProvider) GetJrpDBFileDirPath() (string, error) <span class="cov8" title="1">{
        return d.getDBFileDirPath(JRP_ENV_JRP_DB_FILE_DIR)
}</span>

// GetWNJpnDBFileDirPath provides db file directory path for wnjpn db file.
func (d *DBFileDirPathProvider) GetWNJpnDBFileDirPath() (string, error) <span class="cov8" title="1">{
        return d.getDBFileDirPath(JRP_ENV_WNJPN_DB_FILE_DIR)
}</span>

// getDBFileDirPath gets db file directory path from env var or default.
func (d *DBFileDirPathProvider) getDBFileDirPath(envVar string) (string, error) <span class="cov8" title="1">{
        // get env var
        envDir := d.OsProxy.Getenv(envVar)
        if envDir != "" </span><span class="cov8" title="1">{
                // if env var is set, use it
                return envDir, nil
        }</span>

        // get current user
        <span class="cov8" title="1">currentUser, err := d.UserProxy.Current()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // get default db file dir path
        <span class="cov8" title="1">var defaultDBFileDirPath string
        xdgDataHome := d.OsProxy.Getenv("XDG_DATA_HOME")
        if xdgDataHome != "" </span><span class="cov8" title="1">{
                // if XDG_DATA_HOME is set, use it
                defaultDBFileDirPath = d.FilepathProxy.Join(xdgDataHome, "jrp")
        }</span> else<span class="cov8" title="1"> {
                // if XDG_DATA_HOME is not set, use default
                defaultDBFileDirPath = d.FilepathProxy.Join(currentUser.FieldUser.HomeDir, ".local", "share", "jrp")
        }</span>

        <span class="cov8" title="1">return defaultDBFileDirPath, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package downloader

import (
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/gzip"
        "github.com/yanosea/jrp/app/proxy/http"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
)

// Downloadable is an interface that provides a function to download wnjpn db file.
type Downloadable interface {
        DownloadWNJpnDBFile(wnJpnDBFileDirPath string) (DownloadStatus, error)
}

// Downloader is a struct that implements Downloadable interface.
type Downloader struct {
        FilepathProxy filepathproxy.FilePath
        GzipProxy     gzipproxy.Gzip
        HttpProxy     httpproxy.Http
        IoProxy       ioproxy.Io
        OsProxy       osproxy.Os
        Utility       utility.UtilityInterface
}

// New is a constructor of Downloader.
func New(
        filepathProxy filepathproxy.FilePath,
        gzipProxy gzipproxy.Gzip,
        httpProxy httpproxy.Http,
        ioProxy ioproxy.Io,
        osProxy osproxy.Os,
        utility utility.UtilityInterface,
) *Downloader <span class="cov8" title="1">{
        return &amp;Downloader{
                FilepathProxy: filepathProxy,
                GzipProxy:     gzipProxy,
                HttpProxy:     httpProxy,
                IoProxy:       ioProxy,
                OsProxy:       osProxy,
                Utility:       utility,
        }
}</span>

// DownloadWNJpnDBFile downloads wnjpn db file.
func (d *Downloader) DownloadWNJpnDBFile(wnJpnDBFileDirPath string) (DownloadStatus, error) <span class="cov8" title="1">{
        // create dir if not exist
        if err := d.Utility.CreateDirIfNotExist(wnJpnDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                // if failed to create dir, return failure
                return DownloadedFailed, err
        }</span>

        // check if db file is already downloaded
        <span class="cov8" title="1">dbFilePath := d.FilepathProxy.Join(wnJpnDBFileDirPath, WNJPN_DB_FILE_NAME)
        if _, err := d.OsProxy.Stat(dbFilePath); d.OsProxy.IsNotExist(err) </span><span class="cov8" title="1">{
                // if not downloaded, download and extract db file
                return d.downloadAndExtractDBFile(dbFilePath)
        }</span>

        // if already downloaded, return
        <span class="cov8" title="1">return DownloadedAlready, nil</span>
}

// downloadAndExtractDBFile downloads and extracts wnjapn db file.
func (d *Downloader) downloadAndExtractDBFile(dbFilePath string) (DownloadStatus, error) <span class="cov8" title="1">{
        var deferErr error
        // download gzip file
        resp, err := d.downloadGzipFile()
        if err != nil </span><span class="cov8" title="1">{
                return DownloadedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = resp.FieldResponse.Body.Close()
        }</span>()

        // save to temp file
        <span class="cov8" title="1">tempFilePath, err := d.saveToTempFile(resp.FieldResponse.Body)
        if err != nil </span><span class="cov8" title="1">{
                return DownloadedFailed, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = d.OsProxy.Remove(tempFilePath)
        }</span>()

        // extract gzip file
        <span class="cov8" title="1">if err := d.extractGzipFile(tempFilePath, dbFilePath); err != nil </span><span class="cov8" title="1">{
                return DownloadedFailed, err
        }</span>

        <span class="cov8" title="1">return DownloadedSuccessfully, deferErr</span>
}

// downloadGzipFile downloads gzip file.
func (d *Downloader) downloadGzipFile() (*httpproxy.ResponseInstance, error) <span class="cov8" title="1">{
        // download gzip file
        return d.HttpProxy.Get(WNJPN_DB_ARCHIVE_FILE_URL)
}</span>

// saveToTempFile saves body to temp file.
func (d *Downloader) saveToTempFile(body ioproxy.ReaderInstanceInterface) (string, error) <span class="cov8" title="1">{
        var deferErr error
        // create temp file
        tempFilePath := d.FilepathProxy.Join(d.OsProxy.TempDir(), WNJPN_DB_ARCHIVE_FILE_NAME)
        out, err := d.OsProxy.Create(tempFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = out.Close()
        }</span>()

        // copy downloaded file to temp file
        <span class="cov8" title="1">if _, err := d.IoProxy.Copy(out, body); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // seek to start
        <span class="cov8" title="1">if _, err := out.Seek(0, ioproxy.SeekStart); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tempFilePath, deferErr</span>
}

// extractGzipFile extracts gzip file.
func (d *Downloader) extractGzipFile(srcPath, destPath string) error <span class="cov8" title="1">{
        var deferErr error
        // open gzip file
        file, err := d.OsProxy.Open(srcPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = file.Close()
        }</span>()
        <span class="cov8" title="1">gz, err := d.GzipProxy.NewReader(file)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = gz.Close()
        }</span>()

        // create file to save
        <span class="cov8" title="1">out, err := d.OsProxy.Create(destPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = out.Close()
        }</span>()

        // copy gzip file to dest file
        <span class="cov8" title="1">if _, err := d.IoProxy.Copy(out, gz); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return deferErr</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package generator

import (
        jrp "github.com/yanosea/jrp/app/database/jrp/model"
        wnjpn "github.com/yanosea/jrp/app/database/wnjpn/model"
        "github.com/yanosea/jrp/app/database/wnjpn/repository"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/rand"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/time"
)

// Generatable is an interface for Generator.
type Generatable interface {
        GenerateJrp(wnJpnDBFilePath string, num int, word string, mode GenerateMode) (GenerateResult, []*jrp.Jrp, error)
}

// Generatoor is a struct that implements Generatable interface.
type Generator struct {
        OsProxy         osproxy.Os
        RandProxy       randproxy.Rand
        SqlProxy        sqlproxy.Sql
        TimeProxy       timeproxy.Time
        WNJpnRepository repository.WNJpnRepositoryInterface
}

// New is a constructor of Generator.
func New(
        osProxy osproxy.Os,
        randProxy randproxy.Rand,
        sqlProxy sqlproxy.Sql,
        timeProxy timeproxy.Time,
        wnJpnRepository repository.WNJpnRepositoryInterface,
) *Generator <span class="cov8" title="1">{
        return &amp;Generator{
                OsProxy:         osProxy,
                RandProxy:       randProxy,
                SqlProxy:        sqlProxy,
                TimeProxy:       timeProxy,
                WNJpnRepository: wnJpnRepository,
        }
}</span>

// GenerateJrp generates jrps.
func (g *Generator) GenerateJrp(wnJpnDBFilePath string, num int, word string, mode GenerateMode) (GenerateResult, []*jrp.Jrp, error) <span class="cov8" title="1">{
        if _, err := g.OsProxy.Stat(wnJpnDBFilePath); g.OsProxy.IsNotExist(err) </span><span class="cov8" title="1">{
                // if WordNet Japan sqlite database file does not exist, return warning
                return DBFileNotFound, nil, nil
        }</span>

        // define prefix, suffix and query
        <span class="cov8" title="1">prefix, suffix := g.getPrefixAndSuffix(word, mode)

        // execute query and get all words
        allWords, err := g.getAllWords(wnJpnDBFilePath, mode)
        if err != nil </span><span class="cov8" title="1">{
                return GeneratedFailed, nil, err
        }</span>

        // separate all words into AV and N words
        <span class="cov8" title="1">allAVWords, allNWords := g.separateWords(allWords)

        // get jrps
        jrps := g.getJrps(num, allAVWords, allNWords, prefix, suffix, mode)

        return GeneratedSuccessfully, jrps, nil</span>
}

// getAllWords gets all words based on mode.
func (g *Generator) getAllWords(wnJpnDBFilePath string, mode GenerateMode) ([]wnjpn.Word, error) <span class="cov8" title="1">{
        var allWords []wnjpn.Word
        var err error
        switch mode </span>{
        case WithNoPrefixOrSuffix:<span class="cov8" title="1">
                allWords, err = g.WNJpnRepository.GetAllAVNWords(wnJpnDBFilePath)</span>
        case WithPrefix:<span class="cov8" title="1">
                allWords, err = g.WNJpnRepository.GetAllNWords(wnJpnDBFilePath)</span>
        case WithSuffix:<span class="cov8" title="1">
                allWords, err = g.WNJpnRepository.GetAllAVWords(wnJpnDBFilePath)</span>
        }
        <span class="cov8" title="1">return allWords, err</span>
}

// getJrps gets jrps based on mode.
func (g *Generator) getJrps(num int,
        allAVWords []wnjpn.Word,
        allNWords []wnjpn.Word,
        argPrefix string,
        argSuffix string,
        mode GenerateMode,
) []*jrp.Jrp <span class="cov8" title="1">{
        jrps := make([]*jrp.Jrp, 0)
        createdAt := g.TimeProxy.Now()

        for i := 0; i &lt; num; i++ </span><span class="cov8" title="1">{
                var prefixWord string
                var suffixWord string
                switch mode </span>{
                case WithNoPrefixOrSuffix:<span class="cov8" title="1">
                        // get random number for prefix
                        randomIndexForPrefix := g.RandProxy.Intn(len(allAVWords))
                        // get random prefix word
                        randomPrefix := allAVWords[randomIndexForPrefix]
                        // get random number for suffix
                        randomIndexForSuffix := g.RandProxy.Intn(len(allNWords))
                        // get random suffix word
                        randomSuffix := allNWords[randomIndexForSuffix]
                        // set prefix word and suffix word
                        prefixWord = randomPrefix.Lemma.FieldNullString.String
                        suffixWord = randomSuffix.Lemma.FieldNullString.String
                        // set argPrefix and argSuffix to empty string
                        argPrefix = ""
                        argSuffix = ""</span>
                case WithPrefix:<span class="cov8" title="1">
                        // get random number for suffix
                        randomIndexSuffix := g.RandProxy.Intn(len(allNWords))
                        // get random prefix word
                        randomSuffix := allNWords[randomIndexSuffix]
                        // set prefix word and suffix word
                        prefixWord = argPrefix
                        suffixWord = randomSuffix.Lemma.FieldNullString.String
                        // set argSuffix to empty string
                        argSuffix = ""</span>
                case WithSuffix:<span class="cov8" title="1">
                        // get random number for argPrefix
                        randomIndexPrefix := g.RandProxy.Intn(len(allAVWords))
                        // get random prefix word
                        randomPrefix := allAVWords[randomIndexPrefix]
                        // set prefix word and suffix word
                        prefixWord = randomPrefix.Lemma.FieldNullString.String
                        suffixWord = argSuffix
                        // set argPrefix to empty string
                        argPrefix = ""</span>
                }

                <span class="cov8" title="1">jrp := &amp;jrp.Jrp{
                        Phrase:    prefixWord + suffixWord,
                        Prefix:    g.SqlProxy.StringToNullString(argPrefix),
                        Suffix:    g.SqlProxy.StringToNullString(argSuffix),
                        CreatedAt: createdAt,
                        UpdatedAt: createdAt,
                }

                jrps = append(jrps, jrp)</span>
        }

        <span class="cov8" title="1">return jrps</span>
}

// getPrefixAndSuffix gets prefix word and suffix word based on mode.
func (g *Generator) getPrefixAndSuffix(word string, mode GenerateMode) (string, string) <span class="cov8" title="1">{
        var prefix, suffix string
        // define prefix and suffix
        switch mode </span>{
        case WithNoPrefixOrSuffix:<span class="cov8" title="1">
                prefix = ""
                suffix = ""</span>
        case WithPrefix:<span class="cov8" title="1">
                prefix = word
                suffix = ""</span>
        case WithSuffix:<span class="cov8" title="1">
                prefix = ""
                suffix = word</span>
        }

        <span class="cov8" title="1">return prefix, suffix</span>
}

// separateWords separates all words into AV and N words.
func (g *Generator) separateWords(allWords []wnjpn.Word) ([]wnjpn.Word, []wnjpn.Word) <span class="cov8" title="1">{
        allAVWords := []wnjpn.Word{}
        allNWords := []wnjpn.Word{}
        for _, word := range allWords </span><span class="cov8" title="1">{
                if word.Pos.FieldNullString.Valid &amp;&amp; word.Pos.FieldNullString.String == "n" </span><span class="cov8" title="1">{
                        // if word is noun
                        allNWords = append(allNWords, word)
                }</span> else<span class="cov8" title="1"> {
                        // if word is adjective or verb
                        allAVWords = append(allAVWords, word)
                }</span>
        }

        <span class="cov8" title="1">return allAVWords, allNWords</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package jrpwriter

import (
        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
)

// JrpWritable is an interface for JrpWriter.
type JrpWritable interface {
        WriteGenerateResultAsTable(writer ioproxy.WriterInstanceInterface, jrps []*model.Jrp, showID bool)
        WriteAsTable(writer ioproxy.WriterInstanceInterface, jrps []*model.Jrp)
}

// JrpWriter is a struct that implements JrpWritable.
type JrpWriter struct {
        StrconvProxy     strconvproxy.Strconv
        TableWriterProxy tablewriterproxy.TableWriter
}

// New is a constructor for JrpWriter.
func New(
        strconvProxy strconvproxy.Strconv,
        tableWriterProxy tablewriterproxy.TableWriter,
) *JrpWriter <span class="cov8" title="1">{
        return &amp;JrpWriter{
                StrconvProxy:     strconvProxy,
                TableWriterProxy: tableWriterProxy,
        }
}</span>

// WriteGenerateResultAsTable writes the generate result as table.
func (j *JrpWriter) WriteGenerateResultAsTable(writer ioproxy.WriterInstanceInterface, jrps []*model.Jrp, showID bool) <span class="cov8" title="1">{
        if jrps == nil || len(jrps) &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">headers := []string{"phrase", "prefix", "suffix", "created_at"}
        if showID </span><span class="cov8" title="1">{
                headers = append([]string{"id"}, headers...)
        }</span>

        <span class="cov8" title="1">rowFunc := func(jrp *model.Jrp) []string </span><span class="cov8" title="1">{
                prefix := ""
                if jrp.Prefix.FieldNullString.Valid </span><span class="cov8" title="1">{
                        prefix = jrp.Prefix.FieldNullString.String
                }</span>
                <span class="cov8" title="1">suffix := ""
                if jrp.Suffix.FieldNullString.Valid </span><span class="cov8" title="1">{
                        suffix = jrp.Suffix.FieldNullString.String
                }</span>
                <span class="cov8" title="1">row := []string{
                        jrp.Phrase,
                        prefix,
                        suffix,
                        jrp.CreatedAt.Format("2006-01-02 15:04:05"),
                }
                if showID </span><span class="cov8" title="1">{
                        row = append([]string{j.StrconvProxy.Itoa(jrp.ID)}, row...)
                }</span>
                <span class="cov8" title="1">return row</span>
        }

        <span class="cov8" title="1">j.writeTable(writer, jrps, headers, rowFunc)</span>
}

// WriteAsTable writes the jrps as table.
func (j *JrpWriter) WriteAsTable(writer ioproxy.WriterInstanceInterface, jrps []*model.Jrp) <span class="cov8" title="1">{
        if jrps == nil || len(jrps) &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">headers := []string{"id", "phrase", "prefix", "suffix", "is_favorited", "created_at", "updated_at"}
        rowFunc := func(jrp *model.Jrp) []string </span><span class="cov8" title="1">{
                prefix := ""
                if jrp.Prefix.FieldNullString.Valid </span><span class="cov8" title="1">{
                        prefix = jrp.Prefix.FieldNullString.String
                }</span>
                <span class="cov8" title="1">suffix := ""
                if jrp.Suffix.FieldNullString.Valid </span><span class="cov8" title="1">{
                        suffix = jrp.Suffix.FieldNullString.String
                }</span>
                <span class="cov8" title="1">isFavorited := ""
                if jrp.IsFavorited == 1 </span><span class="cov8" title="1">{
                        isFavorited = "○"
                }</span>
                <span class="cov8" title="1">return []string{
                        j.StrconvProxy.Itoa(jrp.ID),
                        jrp.Phrase,
                        prefix,
                        suffix,
                        isFavorited,
                        jrp.CreatedAt.Format("2006-01-02 15:04:05"),
                        jrp.UpdatedAt.Format("2006-01-02 15:04:05"),
                }</span>
        }

        <span class="cov8" title="1">j.writeTable(writer, jrps, headers, rowFunc)</span>
}

// writeTable writes the table.
func (j *JrpWriter) writeTable(writer ioproxy.WriterInstanceInterface, jrps []*model.Jrp, headers []string, rowFunc func(*model.Jrp) []string) <span class="cov8" title="1">{
        if jrps == nil || len(jrps) &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var rows [][]string
        for _, jrp := range jrps </span><span class="cov8" title="1">{
                rows = append(rows, rowFunc(jrp))
        }</span>
        <span class="cov8" title="1">total := j.StrconvProxy.Itoa(len(rows))
        rows = append(rows, make([]string, len(headers)))
        rows = append(rows, append([]string{"TOTAL : " + total}, make([]string, len(headers)-1)...))

        table := j.getDefaultTableWriter(writer)
        table.SetHeader(headers)
        table.AppendBulk(rows)
        table.Render()</span>
}

// getDefaultTableWriter gets the default table instance.
func (j *JrpWriter) getDefaultTableWriter(o ioproxy.WriterInstanceInterface) tablewriterproxy.TableInstanceInterface <span class="cov8" title="1">{
        table := j.TableWriterProxy.NewTable(o)
        table.SetAutoWrapText(false)
        table.SetAutoFormatHeaders(true)
        table.SetHeaderAlignment(tablewriterproxy.ALIGN_LEFT)
        table.SetAlignment(tablewriterproxy.ALIGN_LEFT)
        table.SetCenterSeparator("")
        table.SetColumnSeparator("")
        table.SetRowSeparator("")
        table.SetHeaderLine(false)
        table.SetBorder(false)
        table.SetTablePadding("\t")
        table.SetNoWhiteSpace(true)
        return table
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package utility

import (
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/strconv"
)

// UtilityInterface is an interface for Utility.
type UtilityInterface interface {
        PrintlnWithWriter(writer ioproxy.WriterInstanceInterface, a ...any)
        GetMaxConvertibleString(args []string, def string) string
        GetLargerNumber(num int, argNum string) int
        CreateDirIfNotExist(dirPath string) error
}

// Utility is a struct that implements UtilityInterface.
type Utility struct {
        FmtProxy     fmtproxy.Fmt
        OsProxy      osproxy.Os
        StrconvProxy strconvproxy.Strconv
}

// New is a constructor for Utility.
func New(
        fmtProxy fmtproxy.Fmt,
        osProxy osproxy.Os,
        strconvProxy strconvproxy.Strconv,
) *Utility <span class="cov8" title="1">{
        return &amp;Utility{
                FmtProxy:     fmtProxy,
                OsProxy:      osProxy,
                StrconvProxy: strconvProxy,
        }
}</span>

// PrintlnWithWriter prints any with a writer.
func (u *Utility) PrintlnWithWriter(writer ioproxy.WriterInstanceInterface, a ...any) <span class="cov8" title="1">{
        u.FmtProxy.Fprintf(writer, u.FmtProxy.Sprintf("%s", a[0])+"\n")
}</span>

// GetMaxConvertibleString gets the maximum number from args and converts it to a string.
func (u *Utility) GetMaxConvertibleString(args []string, def string) string <span class="cov8" title="1">{
        var maxArg string
        var maxValue int
        initialized := false

        for _, arg := range args </span><span class="cov8" title="1">{
                if convertedArg, err := u.StrconvProxy.Atoi(arg); err == nil </span><span class="cov8" title="1">{
                        if !initialized || convertedArg &gt; maxValue </span><span class="cov8" title="1">{
                                // if the value is the first one or the value is larger than the max value
                                maxValue = convertedArg
                                maxArg = arg
                                initialized = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if initialized </span><span class="cov8" title="1">{
                // if there is less than 1 convertible arg, return the max arg
                return maxArg
        }</span>

        // if there is no convertible args, return default value
        <span class="cov8" title="1">return def</span>
}

// GetLargerNumber gets the larger number between num and argNum.
func (u *Utility) GetLargerNumber(num int, argNum string) int <span class="cov8" title="1">{
        if num &lt;= 0 </span><span class="cov8" title="1">{
                // if num is less than 1, set num to 1
                num = 1
        }</span>

        <span class="cov8" title="1">convertedArgNum, err := u.StrconvProxy.Atoi(argNum)
        if err != nil </span><span class="cov8" title="1">{
                // if argNum is not convertible, set argNum to 1
                convertedArgNum = 1
        }</span>
        <span class="cov8" title="1">if convertedArgNum &lt;= 0 </span><span class="cov8" title="1">{
                // if argNum is less than 1, set argNum to 1
                convertedArgNum = 1
        }</span>

        // return the larger number
        <span class="cov8" title="1">if convertedArgNum &gt; num </span><span class="cov8" title="1">{
                return convertedArgNum
        }</span> else<span class="cov8" title="1"> {
                return num
        }</span>
}

// CreateDirIfNotExist creates a directory if it does not exist.
func (u *Utility) CreateDirIfNotExist(dirPath string) error <span class="cov8" title="1">{
        if _, err := u.OsProxy.Stat(dirPath); u.OsProxy.IsNotExist(err) </span><span class="cov8" title="1">{
                // if not exist, create dir
                return u.OsProxy.MkdirAll(dirPath, u.OsProxy.FileMode(0755))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package versionprovider

import (
        "github.com/yanosea/jrp/app/proxy/debug"
)

// VersionProvidable is an interface for VersionProvider.
type VersionProvidable interface {
        GetVersion(emmbeddedVersion string) string
}

// VersionProvider is a struct that implements VersionProvidable.
type VersionProvider struct {
        DebugProxy debugproxy.Debug
}

// New is a constructor of VersionProvider.
func New(debugProxy debugproxy.Debug) *VersionProvider <span class="cov8" title="1">{
        return &amp;VersionProvider{
                DebugProxy: debugProxy,
        }
}</span>

// GetVersion gets the version from build info if version is not embedded.
func (v *VersionProvider) GetVersion(embeddedVersion string) string <span class="cov8" title="1">{
        // if version is embedded, return it
        if embeddedVersion != "" </span><span class="cov8" title="1">{
                return embeddedVersion
        }</span>

        <span class="cov8" title="1">i, ok := v.DebugProxy.ReadBuildInfo()
        if !ok </span><span class="cov8" title="1">{
                // if reading build info fails, return unknown
                return "unknown"
        }</span>
        <span class="cov8" title="1">if i.FieldBuildInfo.Main.Version == "" || i.FieldBuildInfo.Main.Version == "(devel)" </span><span class="cov8" title="1">{
                // if version from build info is empty, return dev
                return "devel"
        }</span>

        // return version from build info
        <span class="cov8" title="1">return i.FieldBuildInfo.Main.Version</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bufferproxy

import (
        "bytes"

        "github.com/yanosea/jrp/app/proxy/io"
)

// Buffer is an interface for buffer.
type Buffer interface {
        ReadFrom(r ioproxy.ReaderInstanceInterface) (int64, error)
        Reset()
        String() string
        Write(p []byte) (n int, err error)
}

// BufferProxy is a struct that implements Buffer.
type BufferProxy struct {
        bytes.Buffer
}

// New is a constructor for BufferProxy.
func New() Buffer <span class="cov8" title="1">{
        return &amp;BufferProxy{}
}</span>

// ReadFrom is a proxy for buffer.ReadFrom.
func (b *BufferProxy) ReadFrom(r ioproxy.ReaderInstanceInterface) (int64, error) <span class="cov8" title="1">{
        return b.Buffer.ReadFrom(r)
}</span>

// Reset is a proxy for buffer.Reset.
func (b *BufferProxy) Reset() <span class="cov8" title="1">{
        b.Buffer.Reset()
}</span>

// String is a proxy for buffer.String.
func (b *BufferProxy) String() string <span class="cov8" title="1">{
        return b.Buffer.String()
}</span>

// Write is a proxy for buffer.Write.
func (b *BufferProxy) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return b.Buffer.Write(p)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package cobraproxy

import (
        "github.com/spf13/cobra"
)

// Cobra is an interface for cobra.
type Cobra interface {
        MaximumNArgs(int) *PositionalArgsInstance
        NewCommand() *CommandInstance
}

// CobraProxy is a struct that implements Cobra.
type CobraProxy struct{}

// New is a constructor for CommandProxy.
func New() Cobra <span class="cov8" title="1">{
        return &amp;CobraProxy{}
}</span>

// MaximumNArgs is a proxy for cobra.MaximumNArgs.
func (*CobraProxy) MaximumNArgs(n int) *PositionalArgsInstance <span class="cov8" title="1">{
        return &amp;PositionalArgsInstance{FieldPositionalArgs: cobra.MaximumNArgs(n)}
}</span>

// NewCommand is a proxy for getting cobra.Command struct.
func (*CobraProxy) NewCommand() *CommandInstance <span class="cov8" title="1">{
        return &amp;CommandInstance{FieldCommand: &amp;cobra.Command{}}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package cobraproxy

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/pflag"
)

// CommandInstanceInterface is an interface for cobra.Command.
type CommandInstanceInterface interface {
        AddCommand(cmds ...*CommandInstance)
        Execute() error
        GetCommand() *cobra.Command
        PersistentFlags() *pflagproxy.FlagSetInstance
        SetArgs(args []string)
        SetErr(io ioproxy.WriterInstanceInterface)
        SetHelpTemplate(s string)
        SetOut(io ioproxy.WriterInstanceInterface)
}

// CommandInstance is a struct that implements CommandInstanceInterface.
type CommandInstance struct {
        FieldCommand *cobra.Command
}

// AddCommand is a proxy for cobra.Command.AddCommand.
func (c *CommandInstance) AddCommand(cmds ...*CommandInstance) <span class="cov8" title="1">{
        for _, cmd := range cmds </span><span class="cov8" title="1">{
                c.FieldCommand.AddCommand(cmd.FieldCommand)
        }</span>
}

// Execute is a proxy for cobra.Command.Execute.
func (c *CommandInstance) Execute() error <span class="cov8" title="1">{
        return c.FieldCommand.Execute()
}</span>

// GetCommand returns the cobra.Command.
func (c *CommandInstance) GetCommand() *cobra.Command <span class="cov8" title="1">{
        return c.FieldCommand
}</span>

// PersistentFlags is a proxy for cobra.Command.PersistentFlags.
func (c *CommandInstance) PersistentFlags() *pflagproxy.FlagSetInstance <span class="cov8" title="1">{
        return &amp;pflagproxy.FlagSetInstance{FieldFlagSet: c.FieldCommand.PersistentFlags()}
}</span>

// SetArgs is a proxy for cobra.Command.SetArgs.
func (c *CommandInstance) SetArgs(args []string) <span class="cov8" title="1">{
        c.FieldCommand.SetArgs(args)
}</span>

// SetErr is a proxy for cobra.Command.SetErr.
func (c *CommandInstance) SetErr(io ioproxy.WriterInstanceInterface) <span class="cov8" title="1">{
        c.FieldCommand.SetErr(io)
}</span>

// SetHelpTemplate is a proxy for cobra.Command.SetHelpTemplate.
func (c *CommandInstance) SetHelpTemplate(s string) <span class="cov8" title="1">{
        c.FieldCommand.SetHelpTemplate(s)
}</span>

// SetOut is a proxy for cobra.Command.SetOut.

func (c *CommandInstance) SetOut(io ioproxy.WriterInstanceInterface) <span class="cov8" title="1">{
        c.FieldCommand.SetOut(io)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package colorproxy

import (
        "github.com/fatih/color"
)

// Color is an interface for color.
type Color interface {
        GreenString(format string, a ...interface{}) string
        RedString(format string, a ...interface{}) string
        YellowString(format string, a ...interface{}) string
}

// ColorProxy is a struct that implements Color.
type ColorProxy struct{}

// New is a constructor for BufferProxy.
func New() Color <span class="cov8" title="1">{
        return &amp;ColorProxy{}
}</span>

// GreenString is a proxy for color.GreenString.
func (*ColorProxy) GreenString(format string, a ...interface{}) string <span class="cov8" title="1">{
        return color.GreenString(format, a...)
}</span>

// RedString is a proxy for color.RedString.
func (*ColorProxy) RedString(format string, a ...interface{}) string <span class="cov8" title="1">{
        return color.RedString(format, a...)
}</span>

// YellowString is a proxy for color.YellowString.
func (*ColorProxy) YellowString(format string, a ...interface{}) string <span class="cov8" title="1">{
        return color.YellowString(format, a...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package debugproxy

import (
        "runtime/debug"
)

// Debug is an interface for debug.
type Debug interface {
        ReadBuildInfo() (*BuildInfoInstance, bool)
}

// DebugProxy is a struct that implements Debug.
type DebugProxy struct{}

// New is a constructor for DebugProxy.
func New() Debug <span class="cov8" title="1">{
        return &amp;DebugProxy{}
}</span>

// ReadBuildInfo is a proxy for debug.ReadBuildInfo.
func (*DebugProxy) ReadBuildInfo() (*BuildInfoInstance, bool) <span class="cov8" title="1">{
        buildInfo, ok := debug.ReadBuildInfo()
        return &amp;BuildInfoInstance{FieldBuildInfo: buildInfo}, ok
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package filepathproxy

import (
        "path/filepath"
)

// FilePath is an interface for filepath.
type FilePath interface {
        Join(elem ...string) string
}

// FilePathProxy is a struct that implements FilePath.
type FilePathProxy struct{}

// New is a constructor for FilepathProxy
func New() FilePath <span class="cov8" title="1">{
        return &amp;FilePathProxy{}
}</span>

// Join is a proxy for filepath.Join.
func (*FilePathProxy) Join(elem ...string) string <span class="cov8" title="1">{
        return filepath.Join(elem...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package fmtproxy

import (
        "fmt"

        "github.com/yanosea/jrp/app/proxy/io"
)

// Fmt is an interface for fmt.
type Fmt interface {
        Fprintf(w ioproxy.WriterInstanceInterface, format string, a ...any)
        Sprintf(format string, a ...any) string
}

// FmtProxy is a struct that implements Fmt.
type FmtProxy struct{}

// New is a constructor for FmtProxy.
func New() Fmt <span class="cov8" title="1">{
        return &amp;FmtProxy{}
}</span>

// Fprintf is a proxy for fmt.Fprintf.
func (*FmtProxy) Fprintf(w ioproxy.WriterInstanceInterface, format string, a ...any) <span class="cov8" title="1">{
        fmt.Fprintf(w, format, a...)
}</span>

// Sprintf is a proxy for fmt.Sprintf.
func (*FmtProxy) Sprintf(format string, a ...any) string <span class="cov8" title="1">{
        return fmt.Sprintf(format, a...)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package gzipproxy

import (
        "compress/gzip"

        "github.com/yanosea/jrp/app/proxy/io"
)

// Gzip is an interface for gzip.
type Gzip interface {
        NewReader(r ioproxy.ReaderInstanceInterface) (ReaderInstanceInterface, error)
}

// GzipProxy is a struct that implements Gzip.
type GzipProxy struct{}

// New is a constructor for GzipProxy.
func New() Gzip <span class="cov8" title="1">{
        return &amp;GzipProxy{}
}</span>

// NewReader is a proxy for gzip.NewReader.
func (*GzipProxy) NewReader(r ioproxy.ReaderInstanceInterface) (ReaderInstanceInterface, error) <span class="cov8" title="1">{
        return gzip.NewReader(r)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package httpproxy

import (
        "net/http"
)

// Http is an interface for http.
type Http interface {
        Get(url string) (*ResponseInstance, error)
}

// HttpProxy is a struct that implements Http.
type HttpProxy struct{}

// New is a constructor for HttpProxy.
func New() Http <span class="cov8" title="1">{
        return &amp;HttpProxy{}
}</span>

// Get is a proxy for http.Get.
func (*HttpProxy) Get(url string) (*ResponseInstance, error) <span class="cov8" title="1">{
        resp, err := http.Get(url)
        return &amp;ResponseInstance{FieldResponse: resp}, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package ioproxy

import (
        "io"
)

// Io is an interface for io.
type Io interface {
        Copy(dst WriterInstanceInterface, src ReaderInstanceInterface) (int64, error)
}

// IoProxy is a struct that implements Io.
type IoProxy struct{}

// New is a constructor for IoProxy.
func New() Io <span class="cov8" title="1">{
        return &amp;IoProxy{}
}</span>

// Copy is a proxy for io.Copy.
func (*IoProxy) Copy(dst WriterInstanceInterface, src ReaderInstanceInterface) (int64, error) <span class="cov8" title="1">{
        return io.Copy(dst, src)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package osproxy

import (
        "os"
)

// FileInstanceInterface is an interface for os.File.
type FileInstanceInterface interface {
        Close() error
        Read(p []byte) (n int, err error)
        Seek(offset int64, whence int) (int64, error)
        Write(b []byte) (n int, err error)
}

// FileInstance is a struct that implements FileInstanceInterface.
type FileInstance struct {
        FieldFile *os.File
}

// Close is a proxy for os.File.Close().
func (f *FileInstance) Close() error <span class="cov8" title="1">{
        return f.FieldFile.Close()
}</span>

// Read is a proxy for os.File.Read().
func (f *FileInstance) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return f.FieldFile.Read(p)
}</span>

// Seek is a proxy for os.File.Seek().
func (f *FileInstance) Seek(offset int64, whence int) (int64, error) <span class="cov8" title="1">{
        return f.FieldFile.Seek(offset, whence)
}</span>

// Write is a proxy for os.File.Write().
func (f *FileInstance) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        return f.FieldFile.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package osproxy

import (
        "os"

        "github.com/yanosea/jrp/app/proxy/fs"
)

// Os is an interface for os.
type Os interface {
        Create(name string) (FileInstanceInterface, error)
        FileMode(perm fsproxy.FileMode) fsproxy.FileMode
        Getenv(key string) string
        IsNotExist(err error) bool
        MkdirAll(path string, perm fsproxy.FileMode) error
        Open(name string) (*FileInstance, error)
        Pipe() (*FileInstance, *FileInstance, error)
        Remove(name string) error
        RemoveAll(path string) error
        Stat(name string) (*fsproxy.FileInfoInstance, error)
        TempDir() string
}

// OsProxy is a struct that implements Os.
type OsProxy struct{}

// New is a constructor for OsProxy.
func New() Os <span class="cov8" title="1">{
        return &amp;OsProxy{}
}</span>

// Create is a proxy for os.Create.
func (*OsProxy) Create(name string) (FileInstanceInterface, error) <span class="cov8" title="1">{
        file, _ := os.Create(name)
        return &amp;FileInstance{FieldFile: file}, nil
}</span>

// Filemode is a proxy for os.FileMode.
func (*OsProxy) FileMode(perm fsproxy.FileMode) fsproxy.FileMode <span class="cov8" title="1">{
        return perm
}</span>

// Getenv is a proxy for os.Getenv.
func (*OsProxy) Getenv(key string) string <span class="cov8" title="1">{
        return os.Getenv(key)
}</span>

// IsNotExist is a proxy for os.IsNotExist.
func (*OsProxy) IsNotExist(err error) bool <span class="cov8" title="1">{
        return os.IsNotExist(err)
}</span>

// MkdirAll is a proxy for os.MkdirAll.
func (*OsProxy) MkdirAll(path string, perm fsproxy.FileMode) error <span class="cov8" title="1">{
        return os.MkdirAll(path, os.FileMode(perm))
}</span>

// Open is a proxy for os.Open.
func (*OsProxy) Open(name string) (*FileInstance, error) <span class="cov8" title="1">{
        file, _ := os.Open(name)
        return &amp;FileInstance{FieldFile: file}, nil
}</span>

// Pipe is a proxy for os.Pipe.
func (*OsProxy) Pipe() (*FileInstance, *FileInstance, error) <span class="cov8" title="1">{
        r, w, err := os.Pipe()
        return &amp;FileInstance{FieldFile: r}, &amp;FileInstance{FieldFile: w}, err
}</span>

// Remove is a proxy for os.Remove.
func (*OsProxy) Remove(name string) error <span class="cov8" title="1">{
        return os.Remove(name)
}</span>

// RemoveAll is a proxy for os.RemoveAll.
func (*OsProxy) RemoveAll(path string) error <span class="cov8" title="1">{
        return os.RemoveAll(path)
}</span>

// Stat is a proxy for os.Stat.
func (*OsProxy) Stat(name string) (*fsproxy.FileInfoInstance, error) <span class="cov8" title="1">{
        fileInfo, err := os.Stat(name)
        return &amp;fsproxy.FileInfoInstance{FieldFileInfo: fileInfo}, err
}</span>

// TempDir is a proxy for os.TempDir.
func (*OsProxy) TempDir() string <span class="cov8" title="1">{
        return os.TempDir()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package pflagproxy

import (
        "github.com/spf13/pflag"
)

// FlagSetInstanceInterface is an interface for pflag.FlagSet.
type FlagSetInstanceInterface interface {
        BoolVarP(p *bool, name string, shorthand string, value bool, usage string)
        IntVarP(p *int, name string, shorthand string, value int, usage string)
        StringVarP(p *string, name string, shorthand string, value string, usage string)
}

// FlagSetInstance is a struct that implements FlagSetInstanceInterface.
type FlagSetInstance struct {
        FieldFlagSet *pflag.FlagSet
}

// BoolVarP is a proxy for pflag.FlagSet.BoolVarP.
func (f *FlagSetInstance) BoolVarP(p *bool, name string, shorthand string, value bool, usage string) <span class="cov8" title="1">{
        f.FieldFlagSet.BoolVarP(p, name, shorthand, value, usage)
}</span>

// IntVarP is a proxy for pflag.FlagSet.IntVarP.
func (f *FlagSetInstance) IntVarP(p *int, name string, shorthand string, value int, usage string) <span class="cov8" title="1">{
        f.FieldFlagSet.IntVarP(p, name, shorthand, value, usage)
}</span>

// StringVarP is a proxy for pflag.FlagSet.StringVarP.
func (f *FlagSetInstance) StringVarP(p *string, name string, shorthand string, value string, usage string) <span class="cov8" title="1">{
        f.FieldFlagSet.StringVarP(p, name, shorthand, value, usage)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package promptuiproxy

import (
        "github.com/manifoldco/promptui"
)

// PromptInstanceInterface is an interface for promptui.Prompt.
type PromptInstanceInterface interface {
        Run() (string, error)
        SetLabel(label string)
}

// PromptInstance is a struct that implements PromptInstanceInterface.
type PromptInstance struct {
        FieldPrompt *promptui.Prompt
}

// Run is a proxy for promptui.Prompt.Run.
func (p *PromptInstance) Run() (string, error) <span class="cov8" title="1">{
        return p.FieldPrompt.Run()
}</span>

// SetLabel is a proxy for promptui.Prompt.Label.
func (p *PromptInstance) SetLabel(label string) <span class="cov8" title="1">{
        p.FieldPrompt.Label = label
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package promptuiproxy

import (
        "github.com/manifoldco/promptui"
)

// Promptui is an interface for promptui.
type Promptui interface {
        NewPrompt() PromptInstanceInterface
}

// PromptuiProxy is a struct that implements Promptui.
type PromptuiProxy struct{}

// New is a constructor for PromptuiProxy.
func New() Promptui <span class="cov8" title="1">{
        return &amp;PromptuiProxy{}
}</span>

// NewPrompt is a proxy for getting promptui.Prompt struct.
func (*PromptuiProxy) NewPrompt() PromptInstanceInterface <span class="cov8" title="1">{
        return &amp;PromptInstance{FieldPrompt: &amp;promptui.Prompt{}}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package randproxy

import (
        "math/rand"
)

// Rand is an interface for rand.
type Rand interface {
        Intn(n int) int
}

// RandProxy is a struct that implements Rand.
type RandProxy struct{}

// New is a constructor for RandProxy.
func New() Rand <span class="cov8" title="1">{
        return &amp;RandProxy{}
}</span>

// Intn is a proxy for rand.Intn.
func (*RandProxy) Intn(n int) int <span class="cov8" title="1">{
        return rand.Intn(n)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package sortproxy

import (
        "sort"
)

// Sort is an interface for sort.
type Sort interface {
        Slice(x any, less func(i, j int) bool)
}

// SortProxy is a struct that implements Sort.
type SortProxy struct{}

// New is a constructor of SortProxy.
func New() Sort <span class="cov8" title="1">{
        return &amp;SortProxy{}
}</span>

// Slice is a proxy for sort.Slice.
func (*SortProxy) Slice(x any, less func(i, j int) bool) <span class="cov8" title="1">{
        sort.Slice(x, less)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package spinnerproxy

import (
        "github.com/briandowns/spinner"
)

// SpinnerInstanceInterface is an interface for spinner.Spinner
type SpinnerInstanceInterface interface {
        Reverse()
        SetColor(colors ...string) error
        SetSuffix(suffix string)
        Start()
        Stop()
}

// SpinnerInstance is a struct that implements SpinnerInstanceInterface.
type SpinnerInstance struct {
        FieldSpinner *spinner.Spinner
}

// Reverse is a proxy for spinner.Spinner.Reverse.
func (s *SpinnerInstance) Reverse() <span class="cov8" title="1">{
        s.FieldSpinner.Reverse()
}</span>

// SetColor is a proxy for spinner.Spinner.Color.
func (s *SpinnerInstance) SetColor(colors ...string) error <span class="cov8" title="1">{
        return s.FieldSpinner.Color(colors...)
}</span>

// SetSuffix is a proxy for spinner.Spinner.Suffix.
func (s *SpinnerInstance) SetSuffix(suffix string) <span class="cov8" title="1">{
        s.FieldSpinner.Suffix = suffix
}</span>

// Start is a proxy for spinner.Spinner.Start.
func (s *SpinnerInstance) Start() <span class="cov8" title="1">{
        s.FieldSpinner.Start()
}</span>

// Stop is a proxy for spinner.Spinner.Stop.
func (s *SpinnerInstance) Stop() <span class="cov8" title="1">{
        s.FieldSpinner.Stop()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package spinnerproxy

import (
        "github.com/briandowns/spinner"

        "github.com/yanosea/jrp/app/proxy/time"
)

// Spinner is an interface for spinner.
type Spinner interface {
        NewSpinner() SpinnerInstanceInterface
}

// SpinnerProxy is a struct that implements Spinner.
type SpinnerProxy struct{}

// New is a constructor for SpinnerProxy.
func New() Spinner <span class="cov8" title="1">{
        return &amp;SpinnerProxy{}
}</span>

// New is a proxy for spinner.New.
func (*SpinnerProxy) NewSpinner() SpinnerInstanceInterface <span class="cov8" title="1">{
        return &amp;SpinnerInstance{FieldSpinner: spinner.New(spinner.CharSets[11], 100*timeproxy.Millisecond)}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package sqlproxy

import (
        "database/sql"
)

// DBInstanceInterface is an interface for sql.DB.
type DBInstanceInterface interface {
        Begin() (TxInstanceInterface, error)
        Close() error
        Exec(query string, args ...interface{}) (ResultInstanceInterface, error)
        Prepare(query string) (StmtInstanceInterface, error)
        Query(query string, args ...interface{}) (RowsInstanceInterface, error)
}

// DBInstance is a struct that implements DBInstanceInterface.
type DBInstance struct {
        FieldDB *sql.DB
}

// Begin is a proxy for sql.DB.Begin.
func (d *DBInstance) Begin() (TxInstanceInterface, error) <span class="cov8" title="1">{
        tx, err := d.FieldDB.Begin()
        return &amp;TxInstance{FieldTx: tx}, err
}</span>

// Close is a proxy for sql.DB.Close.
func (d *DBInstance) Close() error <span class="cov8" title="1">{
        return d.FieldDB.Close()
}</span>

// Exec is a proxy for sql.DB.Exec.
func (d *DBInstance) Exec(query string, args ...interface{}) (ResultInstanceInterface, error) <span class="cov8" title="1">{
        res, err := d.FieldDB.Exec(query, args...)
        return &amp;ResultInstance{FieldResult: res}, err
}</span>

// Prepare is a proxy for sql.DB.Prepare.
func (d *DBInstance) Prepare(query string) (StmtInstanceInterface, error) <span class="cov8" title="1">{
        stmt, err := d.FieldDB.Prepare(query)
        return &amp;StmtInstance{FieldStmt: stmt}, err
}</span>

// Query is a proxy for sql.DB.Query.
func (d *DBInstance) Query(query string, args ...interface{}) (RowsInstanceInterface, error) <span class="cov8" title="1">{
        rows, _ := d.FieldDB.Query(query, args...)
        return &amp;RowsInstance{rows}, nil
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package sqlproxy

import (
        "database/sql"
        "database/sql/driver"
)

// NullStringInstanceInterface is an interface for sql.NullString.
type NullStringInstanceInterface interface {
        Scan(value interface{}) error
        Value() (driver.Value, error)
}

// NullStringInstance is a struct that implements NullStringInstanceInterface.
type NullStringInstance struct {
        FieldNullString *sql.NullString
}

// Scan implements the sql.Scanner interface.
func (n *NullStringInstance) Scan(value interface{}) error <span class="cov8" title="1">{
        if n.FieldNullString == nil </span><span class="cov8" title="1">{
                n.FieldNullString = &amp;sql.NullString{
                        String: "",
                        Valid:  false,
                }
        }</span>
        <span class="cov8" title="1">str, _ := value.(string)
        n.FieldNullString.String, n.FieldNullString.Valid = str, true
        return nil</span>
}

// Value implements the driver Valuer interface.
func (n *NullStringInstance) Value() (driver.Value, error) <span class="cov8" title="1">{
        return n.FieldNullString.String, nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package sqlproxy

import (
        "database/sql"
)

// ResultInstanceInterface is an interface for sql.Result.
type ResultInstanceInterface interface {
        LastInsertId() (int64, error)
        RowsAffected() (int64, error)
}

// ResultInstance is a struct that implements ResultInstanceInterface.
type ResultInstance struct {
        FieldResult sql.Result
}

// LastInsertId is a proxy for sql.Result.LastInsertId.
func (r ResultInstance) LastInsertId() (int64, error) <span class="cov8" title="1">{
        return r.FieldResult.LastInsertId()
}</span>

// RowsAffected is a proxy for sql.Result.RowsAffected.
func (r ResultInstance) RowsAffected() (int64, error) <span class="cov8" title="1">{
        return r.FieldResult.RowsAffected()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package sqlproxy

import (
        "database/sql"
)

// RowInstanceInterface is an interface for sql.Row.
type RowInstanceInterface interface {
        Scan(dest ...interface{}) error
}

// RowInstance is a struct that implements RowInstanceInterface.
type RowInstance struct {
        FieldRow *sql.Row
}

// Scan is a proxy for sql.Row.Scan.
func (r *RowInstance) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        return r.FieldRow.Scan(dest...)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package sqlproxy

import (
        "database/sql"
)

// RowsInstanceInterface is an interface for sql.Rows.
type RowsInstanceInterface interface {
        Close() error
        Next() bool
        Scan(dest ...any) error
}

// RowsInstance is a struct that implements RowsInstanceInterface.
type RowsInstance struct {
        FieldRows *sql.Rows
}

// Close is a proxy for sql.Rows.Close.
func (r *RowsInstance) Close() error <span class="cov8" title="1">{
        return r.FieldRows.Close()
}</span>

// Next is a proxy for sql.Rows.Next.
func (r *RowsInstance) Next() bool <span class="cov8" title="1">{
        return r.FieldRows.Next()
}</span>

// Scan is a proxy for sql.Rows.Scan.
func (r *RowsInstance) Scan(dest ...any) error <span class="cov8" title="1">{
        return r.FieldRows.Scan(dest...)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package sqlproxy

import (
        "database/sql"

        _ "modernc.org/sqlite"
)

// Sql is an interface for sql.
type Sql interface {
        Open(driverName string, dataSourceName string) (DBInstanceInterface, error)
        StringToNullString(s string) *NullStringInstance
}

// SqlProxy is a struct that implements Sql.
type SqlProxy struct{}

// New is a constructor for SqlProxy.
func New() Sql <span class="cov8" title="1">{
        return &amp;SqlProxy{}
}</span>

// Open is a proxy for sql.Open.
func (*SqlProxy) Open(driverName string, dataSourceName string) (DBInstanceInterface, error) <span class="cov8" title="1">{
        db, err := sql.Open(driverName, dataSourceName)
        return &amp;DBInstance{FieldDB: db}, err
}</span>

// StringToNullString returns a NullStringInstance with the argument as the String field.
func (*SqlProxy) StringToNullString(s string) *NullStringInstance <span class="cov8" title="1">{
        return &amp;NullStringInstance{
                FieldNullString: &amp;sql.NullString{
                        String: s,
                        Valid:  s != "",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package sqlproxy

import (
        "database/sql"
)

// StmtInstanceInterface is an interface for sql.Stmt.
type StmtInstanceInterface interface {
        Close() error
        Exec(args ...interface{}) (ResultInstanceInterface, error)
        Query(args ...interface{}) (RowsInstanceInterface, error)
}

// StmtInstance is a struct that implements StmtInstanceInterface.
type StmtInstance struct {
        FieldStmt *sql.Stmt
}

// Close is a proxy for sql.Stmt.Close.
func (s *StmtInstance) Close() error <span class="cov8" title="1">{
        return s.FieldStmt.Close()
}</span>

func (s *StmtInstance) Exec(args ...interface{}) (ResultInstanceInterface, error) <span class="cov8" title="1">{
        res, err := s.FieldStmt.Exec(args...)
        return &amp;ResultInstance{FieldResult: res}, err
}</span>

func (s *StmtInstance) Query(args ...interface{}) (RowsInstanceInterface, error) <span class="cov8" title="1">{
        rows, err := s.FieldStmt.Query(args...)
        return &amp;RowsInstance{FieldRows: rows}, err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package sqlproxy

import (
        "database/sql"
)

// TxInstanceInterface is an interface for sql.Tx.
type TxInstanceInterface interface {
        Commit() error
        Exec(query string, args ...interface{}) (ResultInstanceInterface, error)
        QueryRow(query string, args ...interface{}) RowInstanceInterface
        Rollback() error
}

// TxInstance is a struct that implements TxInstanceInterface.
type TxInstance struct {
        FieldTx *sql.Tx
}

// Commit is a proxy for sql.Tx.Commit.
func (t *TxInstance) Commit() error <span class="cov8" title="1">{
        return t.FieldTx.Commit()
}</span>

// Exec is a proxy for sql.Tx.Exec.
func (t *TxInstance) Exec(query string, args ...interface{}) (ResultInstanceInterface, error) <span class="cov8" title="1">{
        res, err := t.FieldTx.Exec(query, args...)
        return &amp;ResultInstance{FieldResult: res}, err
}</span>

// QueryRow is a proxy for sql.Tx.QueryRow.
func (t *TxInstance) QueryRow(query string, args ...interface{}) RowInstanceInterface <span class="cov8" title="1">{
        return &amp;RowInstance{FieldRow: t.FieldTx.QueryRow(query, args...)}
}</span>

// Rollback is a proxy for sql.Tx.Rollback.
func (t *TxInstance) Rollback() error <span class="cov8" title="1">{
        return t.FieldTx.Rollback()
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package strconvproxy

import (
        "strconv"
)

// Strconv is an interface for strconv.
type Strconv interface {
        Atoi(s string) (int, error)
        Itoa(i int) string
}

// StrconvProxy is a struct that implements Strconv.
type StrconvProxy struct{}

// New is a constructor for StrconvProxy.
func New() Strconv <span class="cov8" title="1">{
        return &amp;StrconvProxy{}
}</span>

// Atoi is a proxy for strconv.Atoi.
func (*StrconvProxy) Atoi(s string) (int, error) <span class="cov8" title="1">{
        return strconv.Atoi(s)
}</span>

// Itoa is a proxy for strconv.Itoa.
func (*StrconvProxy) Itoa(i int) string <span class="cov8" title="1">{
        return strconv.Itoa(i)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package stringsproxy

import (
        "strings"
)

// Strings is an interface for strings.
type Strings interface {
        Join(elems []string, sep string) string
}

// StringsProxy is a struct that implements Strings.
type StringsProxy struct{}

// New is a constructor for StringsProxy.
func New() Strings <span class="cov8" title="1">{
        return &amp;StringsProxy{}
}</span>

// Join is a proxy for strings.Join.
func (*StringsProxy) Join(elems []string, sep string) string <span class="cov8" title="1">{
        return strings.Join(elems, sep)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package tablewriterproxy

import (
        "github.com/olekukonko/tablewriter"
)

// TableInstanceInterface is an interface for tablewriter.Table.
type TableInstanceInterface interface {
        AppendBulk(rows [][]string)
        Render()
        SetAlignment(align int)
        SetAutoFormatHeaders(auto bool)
        SetAutoWrapText(auto bool)
        SetBorder(border bool)
        SetCenterSeparator(sep string)
        SetColumnSeparator(sep string)
        SetHeader(keys []string)
        SetHeaderAlignment(hAlign int)
        SetHeaderLine(line bool)
        SetNoWhiteSpace(allow bool)
        SetRowSeparator(sep string)
        SetTablePadding(padding string)
}

// TableInstance is a struct that implements TableInstanceInterface.
type TableInstance struct {
        FieldTable *tablewriter.Table
}

// AppendBulk is a proxy for tablewriter.Table.AppendBulk.
func (t *TableInstance) AppendBulk(rows [][]string) <span class="cov8" title="1">{
        t.FieldTable.AppendBulk(rows)
}</span>

// Render is a proxy for tablewriter.Table.Render.
func (t *TableInstance) Render() <span class="cov8" title="1">{
        t.FieldTable.Render()
}</span>

// SetAlignment is a proxy for tablewriter.Table.SetAlignment.
func (t *TableInstance) SetAlignment(align int) <span class="cov8" title="1">{
        t.FieldTable.SetAlignment(align)
}</span>

// SetAutoFormatHeaders is a proxy for tablewriter.Table.SetAutoFormatHeaders.
func (t *TableInstance) SetAutoFormatHeaders(auto bool) <span class="cov8" title="1">{
        t.FieldTable.SetAutoFormatHeaders(auto)
}</span>

// SetAutoWrapText is a proxy for tablewriter.Table.SetAutoWrapText.
func (t *TableInstance) SetAutoWrapText(auto bool) <span class="cov8" title="1">{
        t.FieldTable.SetAutoWrapText(auto)
}</span>

// SetBorder is a proxy for tablewriter.Table.SetBorder.
func (t *TableInstance) SetBorder(border bool) <span class="cov8" title="1">{
        t.FieldTable.SetBorder(border)
}</span>

// SetCenterSeparator is a proxy for tablewriter.Table.SetCenterSeparator.
func (t *TableInstance) SetCenterSeparator(sep string) <span class="cov8" title="1">{
        t.FieldTable.SetCenterSeparator(sep)
}</span>

// SetColumnSeparator is a proxy for tablewriter.Table.SetColumnSeparator.
func (t *TableInstance) SetColumnSeparator(sep string) <span class="cov8" title="1">{
        t.FieldTable.SetColumnSeparator(sep)
}</span>

// SetHeader is a proxy for tablewriter.Table.SetHeader.
func (t *TableInstance) SetHeader(keys []string) <span class="cov8" title="1">{
        t.FieldTable.SetHeader(keys)
}</span>

// SetHeaderAlignment is a proxy for tablewriter.Table.SetHeaderAlignment.
func (t *TableInstance) SetHeaderAlignment(hAlign int) <span class="cov8" title="1">{
        t.FieldTable.SetHeaderAlignment(hAlign)
}</span>

// SetHeaderLine is a proxy for tablewriter.Table.SetHeaderLine.
func (t TableInstance) SetHeaderLine(line bool) <span class="cov8" title="1">{
        t.FieldTable.SetHeaderLine(line)
}</span>

// SetNoWhiteSpace is a proxy for tablewriter.Table.SetNoWhiteSpace.
func (t *TableInstance) SetNoWhiteSpace(allow bool) <span class="cov8" title="1">{
        t.FieldTable.SetNoWhiteSpace(allow)
}</span>

// SetRowSeparator is a proxy for tablewriter.Table.SetRowSeparator.
func (t *TableInstance) SetRowSeparator(sep string) <span class="cov8" title="1">{
        t.FieldTable.SetRowSeparator(sep)
}</span>

// SetTablePadding is a proxy for tablewriter.Table.SetTablePadding.
func (t *TableInstance) SetTablePadding(padding string) <span class="cov8" title="1">{
        t.FieldTable.SetTablePadding(padding)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package tablewriterproxy

import (
        "github.com/olekukonko/tablewriter"

        "github.com/yanosea/jrp/app/proxy/io"
)

// TableWriter is an interface for tablewriter.
type TableWriter interface {
        NewTable(writer ioproxy.WriterInstanceInterface) *TableInstance
}

// TableWriterProxy is a struct that implements TableWriter.
type TableWriterProxy struct{}

// New is a constructor for TableWriterProxy.
func New() TableWriter <span class="cov8" title="1">{
        return &amp;TableWriterProxy{}
}</span>

// NewTable is a proxy for tablewriter.NewTable.
func (*TableWriterProxy) NewTable(writer ioproxy.WriterInstanceInterface) *TableInstance <span class="cov8" title="1">{
        return &amp;TableInstance{FieldTable: tablewriter.NewWriter(writer)}
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package timeproxy

import (
        "database/sql/driver"
        "time"
)

// TimeInstanceInterface is an interface for time.Time.
type TimeInstanceInterface interface {
        Format(layout string) string
        Scan(value interface{}) error
        Value() (driver.Value, error)
}

// TimeInstance is a struct that implements TimeInstanceInterface.
type TimeInstance struct {
        FieldTime time.Time
}

// Format is a proxy for time.Time.Format.
func (t *TimeInstance) Format(layout string) string <span class="cov8" title="1">{
        return t.FieldTime.Format(layout)
}</span>

// Scan implements the sql.Scanner interface.
func (t *TimeInstance) Scan(value interface{}) error <span class="cov8" title="1">{
        t.FieldTime = value.(time.Time)
        return nil
}</span>

// Value implements the driver.Valuer interface.
func (t *TimeInstance) Value() (driver.Value, error) <span class="cov8" title="1">{
        return t.FieldTime, nil
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package timeproxy

import (
        "time"
)

// Time is an interface for time.
type Time interface {
        Date(year int, month time.Month, day, hour, min, sec, nsec int, loc *time.Location) *TimeInstance
        Now() *TimeInstance
}

// TimeProxy is a struct that implements Time.
type TimeProxy struct{}

// New is a constructor for TimeProxy.
func New() Time <span class="cov8" title="1">{
        return &amp;TimeProxy{}
}</span>

// Date is a proxy for time.Date.
func (t *TimeProxy) Date(year int, month time.Month, day, hour, min, sec, nsec int, loc *time.Location) *TimeInstance <span class="cov8" title="1">{
        return &amp;TimeInstance{FieldTime: time.Date(year, month, day, hour, min, sec, nsec, loc)}
}</span>

// Now is a proxy for time.Now.
func (*TimeProxy) Now() *TimeInstance <span class="cov8" title="1">{
        return &amp;TimeInstance{FieldTime: time.Now()}
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package userproxy

import (
        "os/user"
)

// User is an interface for user.
type User interface {
        Current() (*UserInstance, error)
}

// UserProxy is a struct that implements User.
type UserProxy struct{}

// New is a constructor for UserProxy.
func New() User <span class="cov8" title="1">{
        return &amp;UserProxy{}
}</span>

// Current is a proxy for user.Current.
func (*UserProxy) Current() (*UserInstance, error) <span class="cov8" title="1">{
        currentUser, err := user.Current()
        return &amp;UserInstance{FieldUser: currentUser}, err
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewCompletionCommand creates a new completion command.
func NewCompletionCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.COMPLETION_USE
        cmd.FieldCommand.RunE = g.completionRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.COMPLETION_HELP_TEMPLATE)

        cmd.AddCommand(
                NewCompletionBashCommand(g),
                NewCompletionFishCommand(g),
                NewCompletionPowerShellCommand(g),
                NewCompletionZshCommand(g),
        )

        return cmd
}</span>

// completionRunE is the function that is called when the completion command is executed.
func (g *GlobalOption) completionRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.completion()
}</span>

// completion just prints the message.
func (g *GlobalOption) completion() error <span class="cov8" title="1">{
        // if no sub command is specified, print the message and return nil.
        colorProxy := colorproxy.New()
        g.Utility.PrintlnWithWriter(g.Out, colorProxy.YellowString(constant.COMPLETION_MESSAGE_NO_SUB_COMMAND))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewCompletionBashCommand creates a new completion bash command.
func NewCompletionBashCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.COMPLETION_BASH_USE
        cmd.FieldCommand.RunE = g.completionBashRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.COMPLETION_BASH_HELP_TEMPLATE)

        return cmd
}</span>

// completionBashRunE is a function that is called when the completion bash command is executed.
func (g *GlobalOption) completionBashRunE(c *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.completionBash(c)
}</span>

// completionBash generates the bash completion script.
func (g *GlobalOption) completionBash(c *cobra.Command) error <span class="cov8" title="1">{
        return c.GenBashCompletion(g.Out)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewCompletionFishCommand creates a new command for fish completion.
func NewCompletionFishCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.COMPLETION_FISH_USE
        cmd.FieldCommand.RunE = g.completionFishRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.COMPLETION_FISH_HELP_TEMPLATE)

        return cmd
}</span>

// completionFishRunE is the function that is called when the completion fish command is executed.
func (g *GlobalOption) completionFishRunE(c *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.completionFish(c)
}</span>

// completionFish generates the fish completion script.
func (g *GlobalOption) completionFish(c *cobra.Command) error <span class="cov8" title="1">{
        return c.GenFishCompletion(g.Out, false)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewCompletionPowerShellCommand creates a new completion powershell command.
func NewCompletionPowerShellCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.COMPLETION_POWERSHELL_USE
        cmd.FieldCommand.RunE = g.completionPowerShellRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.COMPLETION_POWERSHELL_HELP_TEMPLATE)

        return cmd
}</span>

// completionPowerShellRunE is a function that is called when the completion powershell command is executed.
func (g *GlobalOption) completionPowerShellRunE(c *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.completionPowerShell(c)
}</span>

// completionPowerShell generates the powershell completion script.
func (g *GlobalOption) completionPowerShell(c *cobra.Command) error <span class="cov8" title="1">{
        return c.GenPowerShellCompletion(g.Out)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewCompletionZshCommand creates a new completion zsh command.
func NewCompletionZshCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.COMPLETION_ZSH_USE
        cmd.FieldCommand.RunE = g.completionZshRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.COMPLETION_ZSH_HELP_TEMPLATE)

        return cmd
}</span>

// completionZshRunE is a function that is called when the completion zsh command is executed.
func (g *GlobalOption) completionZshRunE(c *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.completionZsh(c)
}</span>

// completionZsh generates the zsh completion script.
func (g *GlobalOption) completionZsh(c *cobra.Command) error <span class="cov8" title="1">{
        return c.GenZshCompletion(g.Out)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package constant

const (
        DOWNLOAD_USE           = "download"
        DOWNLOAD_HELP_TEMPLATE = `📦 Download WordNet Japan sqlite database file from the official web site.

You have to download WordNet Japan sqlite database file to use jrp at first.
jrp will download archive file from the official web site and decompress it to the database file.

You can set the directory of the database file to the environment variable "JRP_WNJPN_DB_FILE_DIR".
The default directory is "~/.local/share/jrp" ("$XDG_DATA_HOME/jrp").

Usage:
  jrp download [flags]
  jrp dl       [flags]
  jrp d        [flags]

Flags:
  -h, --help   🤝 help for download
`
        DOWNLOAD_MESSAGE_DOWNLOADING        = "  📦 Downloading WordNet Japan sqlite database file from the official web site..."
        DOWNLOAD_MESSAGE_SUCCEEDED          = "✅ Downloaded successfully! Now, you are ready to use jrp!"
        DOWNLOAD_MESSAGE_FAILED             = "❌ Failed to download... Please try again later..."
        DOWNLOAD_MESSAGE_ALREADY_DOWNLOADED = "✅ You are already ready to use jrp!"
)

func GetDownloadAliases() []string <span class="cov8" title="1">{
        return []string{"dl", "d"}
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package constant

const (
        FAVORITE_USE           = "favorite"
        FAVORITE_HELP_TEMPLATE = `⭐ Manage the favorited phrase(s) of the history of "generate" command.

You can favorite (add) generated phrase(s) with its ID(s).
Also, You can show, remove, search and clear the phrase(s) you favorited.

You can specify how many phrases to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent favorited phrase(s).
If you don't specify the number of phrases, jrp will show the most recent 10 phrases by default.
If both are provided, the larger number takes precedence.

Also, you can show all phrases in the favorite by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

Usage:
  jrp favorite [flag]
  jrp fav      [flag]
  jrp f        [flag]
  jrp favorite [command]
  jrp fav      [command]
  jrp f        [command]

Available Subommands:
  show    ⭐📖 Show the favorited phrase(s). You can abbreviate "show" sub command. ("jrp favorite" and "jrp favorite show" are the same.)
  add     ⭐📌 Favorite (add) phrase(s) in the history of the "generate" command.
  search  ⭐🔍 Search the favorited phrase(s).
  remove  ⭐🧹 Remove the favorited phrase(s).
  clear   ⭐✨ Clear the favorited phrase(s).

Flags:
  -n, --number  📏 number how many phrases to show (default 10, e.g: 50)
  -a, --all     📁 show all favorited phrase(s)
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for favorite

Arguments:
  number  📏 number how many phrases to show (default 10, e.g: 50)

Use "jrp favorite [command] --help" for more information about a command.
`
        FAVORITE_FLAG_NUMBER             = "number"
        FAVORITE_FLAG_NUMBER_SHORTHAND   = "n"
        FAVORITE_FLAG_NUMBER_DEFAULT     = 10
        FAVORITE_FLAG_NUMBER_DESCRIPTION = "number how many phrases to show"
        FAVORITE_FLAG_ALL                = "all"
        FAVORITE_FLAG_ALL_SHORTHAND      = "a"
        FAVORITE_FLAG_ALL_DEFAULT        = false
        FAVORITE_FLAG_ALL_DESCRIPTION    = "show all phrases in the favorite"
        FAVORITE_FLAG_PLAIN              = "plain"
        FAVORITE_FLAG_PLAIN_SHORTHAND    = "P"
        FAVORITE_FLAG_PLAIN_DEFAULT      = false
        FAVORITE_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        FAVORITE_MESSAGE_NO_FAVORITE_FOUND = "⚡ No favorited phrase(s) found..."
)

func GetFavoriteAliases() []string <span class="cov8" title="1">{
        return []string{"fav", "f"}
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package constant

const (
        FAVORITE_ADD_USE           = "add"
        FAVORITE_ADD_HELP_TEMPLATE = `⭐📌 Favorite (add) phrase(s) in the history of the "generate" command.

You can specify the phrase(s) to favorite with ID argument(s).
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.

This command can make the phrase(s) easier to find.
And you will not be able to remove the phrase(s) with executing "history remove" and "history clear".

Usage:
  jrp favorite add [flag]
  jrp favorite ad  [flag]
  jrp favorite a   [flag]

Flags:
  -h, --help  🤝 help for add

Arguments:
  ID  🆔 add the favorite by the ID (e.g: 1 2 3)
`
        FAVORITE_ADD_MESSAGE_NO_ID_SPECIFIED    = "⚡ No ID argument(s) specified..."
        FAVORITE_ADD_MESSAGE_ADDED_SUCCESSFULLY = "✅ Favorite successfully!"
        FAVORITE_ADD_MESSAGE_ADDED_FAILURE      = "❌ Failed favorite..."
        FAVORITE_ADD_MESSAGE_ADDED_NONE         = "⚡ No phrase(s) to favorite..."
        FAVORITE_ADD_MESSAGE_ADDED_NOT_ALL      = "⚡ Some phrase(s) are not favorited because the id does not exist or have already favorited..."
)

func GetFavoriteAddAliases() []string <span class="cov8" title="1">{
        return []string{"ad", "a"}
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package constant

const (
        FAVORITE_CLEAR_USE           = "clear"
        FAVORITE_CLEAR_HELP_TEMPLATE = `⭐✨ Clear the favorited phrase(s).

You can clear all favorited phrase(s).
This is the same as the "favorite remove -a" command.
This does not clear the history of the "generate" command, just clear the favorited status.

Usage:
  jrp favorite clear [flag]
  jrp favorite cl    [flag]
  jrp favorite c     [flag]

Flags:
  -no-confirm  🚫 do not confirm before clearing the history
  -h, --help   🤝 help for clear
`
        FAVORITE_CLEAR_FLAG_NO_CONFIRM             = "no-confirm"
        FAVORITE_CLEAR_FLAG_NO_CONFIRM_SHORTHAND   = ""
        FAVORITE_CLEAR_FLAG_NO_CONFIRM_DEFAULT     = false
        FAVORITE_CLEAR_FLAG_NO_CONFIRM_DESCRIPTION = "do not confirm before clearing the favorited phrase(s)"

        FAVORITE_CLEAR_MESSAGE_CLEARED_SUCCESSFULLY = "✅ Cleared favorited phrase(s) successfully!"
        FAVORITE_CLEAR_MESSAGE_CLEARED_NONE         = "⚡ No favorited phrase(s) to clear..."
        FAVORITE_CLEAR_MESSAGE_CLEARED_FAIRULE      = "❌ Failed to clear favorited phraase(s)..."
        FAVORITE_CLEAR_MESSAGE_CLEAR_CANCELED       = "🚫 Cancelled clearing the favorited phrases(s)."
        FAVORITE_CLEAR_PROMPT_LABEL                 = "Proceed with clearing the favorited phrases(s)? [y/N]"
)

func GetFavoriteClearAliases() []string <span class="cov8" title="1">{
        return []string{"cl", "c"}
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package constant

const (
        FAVORITE_REMOVE_USE           = "remove"
        FAVORITE_REMOVE_HELP_TEMPLATE = `⭐🧹 Remove the favorited phrase(s).

You can specify the favorited phrase(s) to remove with ID argument(s).
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.
This does not remove the history of the "generate" command, just remove the favorited status.

Also, you can remove all favorited phrase(s) by flag "-a" or "--all".
This is the same as the "favorite clear" command.

Usage:
  jrp favorite remove [flag]
  jrp favorite rm     [flag]
  jrp favorite r      [flag]

Flags:
  -a, --all    ✨ remove all favorited phrase(s)
  -no-confirm  🚫 do not confirm before removing all the favorited phrase(s)
  -h, --help   🤝 help for remove

Arguments:
  ID  🆔 remove the favorite by the ID (e.g: 1 2 3)
`
        FAVORITE_REMOVE_FLAG_ALL                    = "all"
        FAVORITE_REMOVE_FLAG_ALL_SHORTHAND          = "a"
        FAVORITE_REMOVE_FLAG_ALL_DEFAULT            = false
        FAVORITE_REMOVE_FLAG_ALL_DESCRIPTION        = "remove all favorited phrase(s)"
        FAVORITE_REMOVE_FLAG_NO_CONFIRM             = "no-confirm"
        FAVORITE_REMOVE_FLAG_NO_CONFIRM_SHORTHAND   = ""
        FAVORITE_REMOVE_FLAG_NO_CONFIRM_DEFAULT     = false
        FAVORITE_REMOVE_FLAG_NO_CONFIRM_DESCRIPTION = "do not confirm before removing all the favorited phrase(s)"

        FAVORITE_REMOVE_MESSAGE_NO_ID_SPECIFIED      = "⚡ No ID argument(s) specified..."
        FAVORITE_REMOVE_MESSAGE_REMOVED_SUCCESSFULLY = "✅ Removed favorited phrase(s) successfully!"
        FAVORITE_REMOVE_MESSAGE_REMOVED_FAILURE      = "❌ Failed to remove favorited phrase(s)..."
        FAVORITE_REMOVE_MESSAGE_REMOVED_NONE         = "⚡ No favorited phrase(s) to remove..."
        FAVORITE_REMOVE_MESSAGE_REMOVED_NOT_ALL      = "⚡ Some favorited phrase(s) was not removed because the id does not exist or have not favorited..."
        FAVORITE_REMOVE_MESSAGE_REMOVE_ALL_CANCELED  = "🚫 Cancelled removing all the favorited phrase(s)."
        FAVORITE_REMOVE_PROMPT_REMOVE_ALL_LABEL      = "Proceed with removing all the favorited phrase(s)? [y/N]"
)

func GetFavoriteRemoveAliases() []string <span class="cov8" title="1">{
        return []string{"rm", "r"}
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package constant

const (
        FAVORITE_SEARCH_USE           = "search"
        FAVORITE_SEARCH_HELP_TEMPLATE = `⭐🔍 Search the favorited phrase(s).

You can search favorited phrase(s) with keyword argument(s).
Multiple keywords are separated by a space.

If you want to search favorited phrase(s) by AND condition, you can use flag "-A" or "--and".
OR condition is by default.

You can specify how many results to show with flag "-n" or "--number".
If you don't specify the number of phrases, jrp will show the most recent 10 results by default.

Also, you can show all results by flag "-a" or "--all".
If you use the flag, the number flag will be ignored.

Usage:
  jrp favorite search [flag]
  jrp favorite se     [flag]
  jrp favorite S      [flag]

Flags:
  -A, --and     🧠 search phrase(s) by AND condition
  -n, --number  📏 number how many results to show (default 10, e.g: 50)
  -a, --all     📁 show all results
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for search

Arguments:
  keywords  💬 search phrase(s) by keywords (multiple keywords are separated by space)
`
        FAVORITE_SEARCH_FLAG_AND                = "and"
        FAVORITE_SEARCH_FLAG_AND_SHORTHAND      = "A"
        FAVORITE_SEARCH_FLAG_AND_DEFAULT        = false
        FAVORITE_SEARCH_FLAG_AND_DESCRIPTION    = "search phrase(s) by AND condition"
        FAVORITE_SEARCH_FLAG_NUMBER             = "number"
        FAVORITE_SEARCH_FLAG_NUMBER_SHORTHAND   = "n"
        FAVORITE_SEARCH_FLAG_NUMBER_DEFAULT     = 10
        FAVORITE_SEARCH_FLAG_NUMBER_DESCRIPTION = "number how many results to show"
        FAVORITE_SEARCH_FLAG_ALL                = "all"
        FAVORITE_SEARCH_FLAG_ALL_SHORTHAND      = "a"
        FAVORITE_SEARCH_FLAG_ALL_DEFAULT        = false
        FAVORITE_SEARCH_FLAG_ALL_DESCRIPTION    = "show all phrases in the favorite"
        FAVORITE_SEARCH_FLAG_PLAIN              = "plain"
        FAVORITE_SEARCH_FLAG_PLAIN_SHORTHAND    = "P"
        FAVORITE_SEARCH_FLAG_PLAIN_DEFAULT      = false
        FAVORITE_SEARCH_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        FAVORITE_SEARCH_MESSAGE_NO_KEYWORDS_PROVIDED = "⚡ No keyword(s) provided..."
        FAVORITE_SEARCH_MESSAGE_NO_RESULT_FOUND      = "⚡ No results found..."
)

func GetFavoriteSearchAliases() []string <span class="cov8" title="1">{
        return []string{"se", "S"}
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package constant

const (
        FAVORITE_SHOW_USE           = "show"
        FAVORITE_SHOW_HELP_TEMPLATE = `⭐📖 Show the favorited phrase(s).

You can specify how many phrases to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent favorited phrase(s).
If you don't specify the number of phrases, jrp will show the most recent 10 phrases by default.
If both are provided, the larger number takes precedence.

Also, you can show all phrases in the favorite by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

Usage:
  jrp favorite show [flag]
  jrp favorite sh   [flag]
  jrp favorite s    [flag]

Flags:
  -n, --number  📏 number how many phrases to show (default 10, e.g: 50)
  -a, --all     📁 show all favorited phrase(s)
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for show

Arguments:
  number  📏 number how many phrases to show (default 10, e.g: 50)
`
        FAVORITE_SHOW_FLAG_NUMBER             = "number"
        FAVORITE_SHOW_FLAG_NUMBER_SHORTHAND   = "n"
        FAVORITE_SHOW_FLAG_NUMBER_DEFAULT     = 10
        FAVORITE_SHOW_FLAG_NUMBER_DESCRIPTION = "number how many phrases to show"
        FAVORITE_SHOW_FLAG_ALL                = "all"
        FAVORITE_SHOW_FLAG_ALL_SHORTHAND      = "a"
        FAVORITE_SHOW_FLAG_ALL_DEFAULT        = false
        FAVORITE_SHOW_FLAG_ALL_DESCRIPTION    = "show all phrases in the favorite"
        FAVORITE_SHOW_FLAG_PLAIN              = "plain"
        FAVORITE_SHOW_FLAG_PLAIN_SHORTHAND    = "P"
        FAVORITE_SHOW_FLAG_PLAIN_DEFAULT      = false
        FAVORITE_SHOW_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        FAVORITE_SHOW_MESSAGE_NO_FAVORITE_FOUND = "⚡ No favorited phrase(s) found..."
)

func GetFavoriteShowAliases() []string <span class="cov8" title="1">{
        return []string{"sh", "s"}
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package constant

const (
        GENERATE_USE           = "generate"
        GENARETE_HELP_TEMPLATE = `✨ Generate Japanese random phrase(s).

You can specify how many phrases to generate by flag "-n" or "--number" or a number argument.
If both are provided, the larger number takes precedence.

And you can specify the prefix or suffix of the phrase(s) to generate
by the flag "-p" or "--prefix" and "-s" or "--suffix".

Usage:
  jrp generate [flags]
  jrp gen      [flags]
  jrp g        [flags]

Flags:
  -n, --number   🔢 number of phrases to generate (default 1, e.g: 10)
  -p  --prefix   💬 prefix of phrase(s) to generate
  -s  --suffix   💬 suffix of phrase(s) to generate
  -d  --dry-run  🧪 generate phrase(s) without saving to the history
  -P, --plain    📝 plain text output instead of table output
  -h, --help     🤝 help for generate

Arguments:
  number  🔢 number of phrases to generate (default 1, e.g: 10)
`
        GENERATE_FLAG_NUMBER              = "number"
        GENERATE_FLAG_NUMBER_SHORTHAND    = "n"
        GENERATE_FLAG_NUMBER_DEFAULT      = 1
        GENERATE_FLAG_NUMBER_DESCRIPTION  = "number of phrases to generate"
        GENERATE_FLAG_PREFIX              = "prifix"
        GENERATE_FLAG_PREFIX_SHORTHAND    = "p"
        GENERATE_FLAG_PREFIX_DEFAULT      = ""
        GENERATE_FLAG_PREFIX_DESCRIPTION  = "prefix of phrase(s) to generate"
        GENERATE_FLAG_SUFFIX              = "suffix"
        GENERATE_FLAG_SUFFIX_SHORTHAND    = "s"
        GENERATE_FLAG_SUFFIX_DEFAULT      = ""
        GENERATE_FLAG_SUFFIX_DESCRIPTION  = "suffix of phrase(s) to generate"
        GENERATE_FLAG_DRY_RUN             = "dry-run"
        GENERATE_FLAG_DRY_RUN_SHORTHAND   = "d"
        GENERATE_FLAG_DRY_RUN_DEFAULT     = false
        GENERATE_FLAG_DRY_RUN_DESCRIPTION = "generate phrase(s) without saving to the history"
        GENERATE_FLAG_PLAIN               = "plain"
        GENERATE_FLAG_PLAIN_SHORTHAND     = "P"
        GENERATE_FLAG_PLAIN_DEFAULT       = false
        GENERATE_FLAG_PLAIN_DESCRIPTION   = "plain text output instead of table output"

        GENERATE_MESSAGE_GENERATE_FAILURE         = "❌ Failed to generate the phrase(s)..."
        GENERATE_MESSAGE_NOTIFY_DOWNLOAD_REQUIRED = "⚡ You have to execute \"download\" to use jrp..."
        GENERATE_MESSAGE_NOTIFY_USE_ONLY_ONE      = "⚡ You can use only one of prefix or suffix..."
        GENERATE_MESSAGE_SAVED_FAILURE            = "❌ Failed to save the history..."
        GENERATE_MESSAGE_SAVED_NONE               = "⚡ No phrase(s) to save to the history..."
        GENERATE_MESSAGE_SAVED_NOT_ALL            = "⚡ Some phrase(s) are not saved to the history..."
)

func GetGenerateAliases() []string <span class="cov8" title="1">{
        return []string{"gen", "g"}
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package constant

const (
        HISTORY_USE           = "history"
        HISTORY_HELP_TEMPLATE = `📜 Manage the history of the "generate" command.

You can show, remove, search and clear the history of the "generate" command.

You can specify how many phrases to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent phrase(s) from the history.
If you don't specify the number of phrases, jrp will show the most recent 10 phrases by default.
If both are provided, the larger number takes precedence.

Also, you can show all phrases in the history by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

Usage:
  jrp history [flag]
  jrp hist    [flag]
  jrp h       [flag]
  jrp history [command]
  jrp hist    [command]
  jrp h       [command]

Available Subommands:
  show    📜📖 Show the history of the "generate" command. You can abbreviate "show" sub command. ("jrp history" and "jrp history show" are the same.)
  search  📜🔍 Search the history of the "generate" command.
  remove  📜🧹 Remove the history of the "generate" command.
  clear   📜✨ Clear the history of the "generate" command.

Flags:
  -n, --number  📏 number how many phrases to show (default 10, e.g: 50)
  -a, --all     📁 show all history
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for history

Arguments:
  number  📏 number how many phrases to show (default 10, e.g: 50)

Use "jrp history [command] --help" for more information about a command.
`
        HISTORY_FLAG_NUMBER             = "number"
        HISTORY_FLAG_NUMBER_SHORTHAND   = "n"
        HISTORY_FLAG_NUMBER_DEFAULT     = 10
        HISTORY_FLAG_NUMBER_DESCRIPTION = "number how many phrases to show"
        HISTORY_FLAG_ALL                = "all"
        HISTORY_FLAG_ALL_SHORTHAND      = "a"
        HISTORY_FLAG_ALL_DEFAULT        = false
        HISTORY_FLAG_ALL_DESCRIPTION    = "show all phrases in the history"
        HISTORY_FLAG_PLAIN              = "plain"
        HISTORY_FLAG_PLAIN_SHORTHAND    = "P"
        HISTORY_FLAG_PLAIN_DEFAULT      = false
        HISTORY_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        HISTORY_MESSAGE_NO_HISTORY_FOUND = "⚡ No history found..."
)

func GetHistoryAliases() []string <span class="cov8" title="1">{
        return []string{"hist", "h"}
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package constant

const (
        HISTORY_CLEAR_USE           = "clear"
        HISTORY_CLEAR_HELP_TEMPLATE = `📜✨ Clear the history of the "generate" command.

You can clear all history.
This is the same as the "history remove -a" command.
Also, you can clear the history even if it is favorited by using the "-f" or ""--force" flag.

Usage:
  jrp history clear [flag]
  jrp history cl    [flag]
  jrp history c     [flag]

Flags:
  -f, --force  💪 clear all the history even if it is favorited
  -no-confirm  🚫 do not confirm before clearing the history
  -h, --help   🤝 help for clear
`
        HISTORY_CLEAR_FLAG_FORCE                  = "force"
        HISTORY_CLEAR_FLAG_FORCE_SHORTHAND        = "f"
        HISTORY_CLEAR_FLAG_FORCE_DEFAULT          = false
        HISTORY_CLEAR_FLAG_FORCE_DESCRIPTION      = "clear all the history even if it is favorited"
        HISTORY_CLEAR_FLAG_NO_CONFIRM             = "no-confirm"
        HISTORY_CLEAR_FLAG_NO_CONFIRM_SHORTHAND   = ""
        HISTORY_CLEAR_FLAG_NO_CONFIRM_DEFAULT     = false
        HISTORY_CLEAR_FLAG_NO_CONFIRM_DESCRIPTION = "do not confirm before clearing the history"

        HISTORY_CLEAR_MESSAGE_CLEARED_SUCCESSFULLY = "✅ Cleared history successfully!"
        HISTORY_CLEAR_MESSAGE_CLEARED_NONE         = "⚡ No history to clear..."
        HISTORY_CLEAR_MESSAGE_CLEARED_FAIRULE      = "❌ Failed to clear history..."
        HISTORY_CLEAR_MESSAGE_CLEAR_CANCELED       = "🚫 Cancelled clearing the history."
        HISTORY_CLEAR_PROMPT_LABEL                 = "Proceed with clearing the history? [y/N]"
)

func GetHistoryClearAliases() []string <span class="cov8" title="1">{
        return []string{"cl", "c"}
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package constant

const (
        HISTORY_REMOVE_USE           = "remove"
        HISTORY_REMOVE_HELP_TEMPLATE = `📜🧹 Remove the history of the "generate" command.

You can specify the history to remove with ID argument(s).
You have to get ID from the "history" command.
Multiple ID's can be specified separated by spaces.

You can remove all history by flag "-a" or "--all".
This is the same as the "history clear" command.

Also, you can remove the history even if it is favorited by using the "-f" or ""--force" flag.

Usage:
  jrp history remove [flag]
  jrp history rm     [flag]
  jrp history r      [flag]

Flags:
  -a, --all    ✨ remove all history
  -f, --force  💪 remove the history even if it is favorited
  -no-confirm  🚫 do not confirm before removing all the history
  -h, --help   🤝 help for remove

Arguments:
  ID  🆔 remove the history by the ID (e.g: 1 2 3)
`
        HISTORY_REMOVE_FLAG_ALL                    = "all"
        HISTORY_REMOVE_FLAG_ALL_SHORTHAND          = "a"
        HISTORY_REMOVE_FLAG_ALL_DEFAULT            = false
        HISTORY_REMOVE_FLAG_ALL_DESCRIPTION        = "remove all history"
        HISTORY_REMOVE_FLAG_FORCE                  = "force"
        HISTORY_REMOVE_FLAG_FORCE_SHORTHAND        = "f"
        HISTORY_REMOVE_FLAG_FORCE_DEFAULT          = false
        HISTORY_REMOVE_FLAG_FORCE_DESCRIPTION      = "force remove the history even if it is favorited"
        HISTORY_REMOVE_FLAG_NO_CONFIRM             = "no-confirm"
        HISTORY_REMOVE_FLAG_NO_CONFIRM_SHORTHAND   = ""
        HISTORY_REMOVE_FLAG_NO_CONFIRM_DEFAULT     = false
        HISTORY_REMOVE_FLAG_NO_CONFIRM_DESCRIPTION = "do not confirm before removing all the history"

        HISTORY_REMOVE_MESSAGE_NO_ID_SPECIFIED      = "⚡ No ID argument(s) specified..."
        HISTORY_REMOVE_MESSAGE_REMOVED_SUCCESSFULLY = "✅ Removed the history successfully!"
        HISTORY_REMOVE_MESSAGE_REMOVED_FAILURE      = "❌ Failed to remove the history..."
        HISTORY_REMOVE_MESSAGE_REMOVED_NONE         = "⚡ No history to remove..."
        HISTORY_REMOVE_MESSAGE_REMOVED_NOT_ALL      = "⚡ Some phtase(s) was not removed because the id does not exist or have already favorited..."
        HISTORY_REMOVE_MESSAGE_REMOVE_ALL_CANCELED  = "🚫 Cancelled removing all the history."
        HISTORY_REMOVE_PROMPT_REMOVE_ALL_LABEL      = "Proceed with removing all the history? [y/N]"
)

func GetHistoryRemoveAliases() []string <span class="cov8" title="1">{
        return []string{"rm", "r"}
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package constant

const (
        HISTORY_SEARCH_USE           = "search"
        HISTORY_SEARCH_HELP_TEMPLATE = `📜🔍 Search the history of the "generate" command.

You can search phrase(s) with keyword argument(s).
Multiple keywords are separated by a space.

If you want to search phrase(s) by AND condition, you can use flag "-A" or "--and".
OR condition is by default.

You can specify how many results to show with flag "-n" or "--number".
If you don't specify the number of phrases, jrp will show the most recent 10 results by default.

Also, you can show all results in the history by flag "-a" or "--all".
If you use the flag, the number flag will be ignored.

Usage:
  jrp history search [flag]
  jrp history se     [flag]
  jrp history S      [flag]

Flags:
  -A, --and     🧠 search phrase(s) by AND condition
  -n, --number  📏 number how many results to show (default 10, e.g: 50)
  -a, --all     📁 show all results
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for search

Arguments:
  keywords  💬 search phrase(s) by keywords (multiple keywords are separated by space)
`
        HISTORY_SEARCH_FLAG_AND                = "and"
        HISTORY_SEARCH_FLAG_AND_SHORTHAND      = "A"
        HISTORY_SEARCH_FLAG_AND_DEFAULT        = false
        HISTORY_SEARCH_FLAG_AND_DESCRIPTION    = "search phrase(s) by AND condition"
        HISTORY_SEARCH_FLAG_NUMBER             = "number"
        HISTORY_SEARCH_FLAG_NUMBER_SHORTHAND   = "n"
        HISTORY_SEARCH_FLAG_NUMBER_DEFAULT     = 10
        HISTORY_SEARCH_FLAG_NUMBER_DESCRIPTION = "number how many results to show"
        HISTORY_SEARCH_FLAG_ALL                = "all"
        HISTORY_SEARCH_FLAG_ALL_SHORTHAND      = "a"
        HISTORY_SEARCH_FLAG_ALL_DEFAULT        = false
        HISTORY_SEARCH_FLAG_ALL_DESCRIPTION    = "show all phrases in the history"
        HISTORY_SEARCH_FLAG_PLAIN              = "plain"
        HISTORY_SEARCH_FLAG_PLAIN_SHORTHAND    = "P"
        HISTORY_SEARCH_FLAG_PLAIN_DEFAULT      = false
        HISTORY_SEARCH_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        HISTORY_SEARCH_MESSAGE_NO_KEYWORDS_PROVIDED = "⚡ No keyword(s) provided..."
        HISTORY_SEARCH_MESSAGE_NO_RESULT_FOUND      = "⚡ No results found..."
)

func GetHistorySearchAliases() []string <span class="cov8" title="1">{
        return []string{"se", "S"}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package constant

const (
        HISTORY_SHOW_USE           = "show"
        HISTORY_SHOW_HELP_TEMPLATE = `📜📖 Show the history of the "generate" command.

You can specify how many phrases to show by flag "-n" or "--number" or a number argument.
jrp will get the most recent phrase(s) from the history.
If you don't specify the number of phrases, jrp will show the most recent 10 phrases by default.
If both are provided, the larger number takes precedence.

Also, you can show all phrases in the history by flag "-a" or "--all".
If you use the flag, the number flag or argument will be ignored.

Usage:
  jrp history show [flag]
  jrp history sh   [flag]
  jrp history s    [flag]

Flags:
  -n, --number  📏 number how many phrases to show (default 10, e.g: 50)
  -a, --all     📁 show all history
  -P, --plain   📝 plain text output instead of table output
  -h, --help    🤝 help for show

Arguments:
  number  📏 number how many phrases to show (default 10, e.g: 50)
`
        HISTORY_SHOW_FLAG_NUMBER             = "number"
        HISTORY_SHOW_FLAG_NUMBER_SHORTHAND   = "n"
        HISTORY_SHOW_FLAG_NUMBER_DEFAULT     = 10
        HISTORY_SHOW_FLAG_NUMBER_DESCRIPTION = "number how many phrases to show"
        HISTORY_SHOW_FLAG_ALL                = "all"
        HISTORY_SHOW_FLAG_ALL_SHORTHAND      = "a"
        HISTORY_SHOW_FLAG_ALL_DEFAULT        = false
        HISTORY_SHOW_FLAG_ALL_DESCRIPTION    = "show all phrases in the history"
        HISTORY_SHOW_FLAG_PLAIN              = "plain"
        HISTORY_SHOW_FLAG_PLAIN_SHORTHAND    = "P"
        HISTORY_SHOW_FLAG_PLAIN_DEFAULT      = false
        HISTORY_SHOW_FLAG_PLAIN_DESCRIPTION  = "plain text output instead of table output"

        HISTORY_SHOW_MESSAGE_NO_HISTORY_FOUND = "⚡ No history found..."
)

func GetHistoryShowAliases() []string <span class="cov8" title="1">{
        return []string{"sh", "s"}
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/downloader"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/gzip"
        "github.com/yanosea/jrp/app/proxy/http"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/spinner"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// downloadOption is the struct for download command.
type downloadOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        Downloader            downloader.Downloadable
        SpinnerProxy          spinnerproxy.Spinner
        Utility               utility.UtilityInterface
}

// NewDownloadCommand creates a new download command.
func NewDownloadCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;downloadOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.Downloader = downloader.New(
                filepathproxy.New(),
                gzipproxy.New(),
                httpproxy.New(),
                ioproxy.New(),
                osproxy.New(),
                g.Utility,
        )
        o.SpinnerProxy = spinnerproxy.New()

        cobraproxy := cobraproxy.New()
        cmd := cobraproxy.NewCommand()

        cmd.FieldCommand.Use = constant.DOWNLOAD_USE
        cmd.FieldCommand.Aliases = constant.GetDownloadAliases()
        cmd.FieldCommand.RunE = o.downloadRunE

        cmd.SetOut(o.Out)
        cmd.SetErr(o.ErrOut)
        cmd.SetHelpTemplate(constant.DOWNLOAD_HELP_TEMPLATE)

        return cmd
}</span>

// downloadRunE is the function that is called when the download command is executed.
func (o *downloadOption) downloadRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        // get wnjpn db file dir path
        wnJpnDBFileDirPath, err := o.DBFileDirPathProvider.GetWNJpnDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(wnJpnDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return o.download(wnJpnDBFileDirPath)</span>
}

// download downloads wnjpn db file.
func (o *downloadOption) download(wnJpnDBFileDirPath string) error <span class="cov8" title="1">{
        // start spinner
        spinner := o.SpinnerProxy.NewSpinner()
        spinner.Reverse()
        if err := spinner.SetColor("yellow"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">colorProxy := colorproxy.New()
        spinner.SetSuffix(colorProxy.YellowString(constant.DOWNLOAD_MESSAGE_DOWNLOADING))
        spinner.Start()

        // download with downloader
        res, err := o.Downloader.DownloadWNJpnDBFile(wnJpnDBFileDirPath)
        spinner.Stop()
        o.writeDownloadResult(res)

        return err</span>
}

// writeDownloadResult writes the download result.
func (o *downloadOption) writeDownloadResult(result downloader.DownloadStatus) <span class="cov8" title="1">{
        colorProxy := colorproxy.New()
        if result == downloader.DownloadedFailed </span><span class="cov8" title="1">{
                o.Utility.PrintlnWithWriter(o.ErrOut, colorProxy.RedString(constant.DOWNLOAD_MESSAGE_FAILED))
        }</span> else<span class="cov8" title="1"> if result == downloader.DownloadedAlready </span><span class="cov8" title="1">{
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.GreenString(constant.DOWNLOAD_MESSAGE_ALREADY_DOWNLOADED))
        }</span> else<span class="cov8" title="1"> {
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.GreenString(constant.DOWNLOAD_MESSAGE_SUCCEEDED))
        }</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteOption is the struct for favorite command.
type favoriteOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewFavoriteCommand creates a new favorite command.
func NewFavoriteCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteAliases()
        cmd.FieldCommand.Args = cobra.MaximumNArgs(1)
        cmd.FieldCommand.RunE = o.favoriteRunE

        cmd.PersistentFlags().IntVarP(
                &amp;o.Number,
                constant.FAVORITE_FLAG_NUMBER,
                constant.FAVORITE_FLAG_NUMBER_SHORTHAND,
                constant.FAVORITE_FLAG_NUMBER_DEFAULT,
                constant.FAVORITE_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.All,
                constant.FAVORITE_FLAG_ALL,
                constant.FAVORITE_FLAG_ALL_SHORTHAND,
                constant.FAVORITE_FLAG_ALL_DEFAULT,
                constant.FAVORITE_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.FAVORITE_FLAG_PLAIN,
                constant.FAVORITE_FLAG_PLAIN_SHORTHAND,
                constant.FAVORITE_FLAG_PLAIN_DEFAULT,
                constant.FAVORITE_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_HELP_TEMPLATE)

        cmd.AddCommand(
                NewFavoriteShowCommand(g),
                NewFavoriteAddCommand(g),
                NewFavoriteRemoveCommand(g, promptuiproxy.New()),
                NewFavoriteSearchCommand(g),
                NewFavoriteClearCommand(g, promptuiproxy.New()),
        )

        return cmd
}</span>

// favoriteRunE is the function that is called when the favorite command is executed.
func (o *favoriteOption) favoriteRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        if len(o.Args) &lt;= 1 </span><span class="cov8" title="1">{
                // if no argument is given, set the default value to args
                o.Args = []string{constant.FAVORITE_USE, strconvProxy.Itoa(constant.FAVORITE_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favorite(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// favorite shows the favorite.
func (o *favoriteOption) favorite(jrpDBFilePath string) error <span class="cov8" title="1">{
        var favorites []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, get all favorite
                favorites, err = o.JrpRepository.GetAllFavorite(jrpDBFilePath)
        }</span> else<span class="cov8" title="1"> {
                if o.Number != constant.FAVORITE_FLAG_NUMBER_DEFAULT &amp;&amp; o.Number &gt;= 1 </span><span class="cov8" title="1">{
                        // if number flag is set, get favorites with the given number
                        favorites, err = o.JrpRepository.GetFavoriteWithNumber(jrpDBFilePath, o.Number)
                }</span> else<span class="cov8" title="1"> {
                        strconvProxy := strconvproxy.New()
                        // get favorite with the given number
                        favorites, err = o.JrpRepository.GetFavoriteWithNumber(
                                jrpDBFilePath,
                                // get the larger number between the given number flag and the largest number that can be converted from the args
                                o.Utility.GetLargerNumber(
                                        o.Number,
                                        o.Utility.GetMaxConvertibleString(
                                                o.Args,
                                                strconvProxy.Itoa(constant.FAVORITE_FLAG_NUMBER_DEFAULT),
                                        ),
                                ),
                        )
                }</span>
        }
        <span class="cov8" title="1">o.writeFavoriteResult(favorites)

        return err</span>
}

// writeFavoriteResult writes the favorite result.
func (o *favoriteOption) writeFavoriteResult(favorites []*model.Jrp) <span class="cov8" title="1">{
        if len(favorites) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, favorite := range favorites </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, favorite.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the favorite as a table
                        o.JrpWriter.WriteAsTable(o.Out, favorites)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no favorite is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_MESSAGE_NO_FAVORITE_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteAddOption is the struct for favorite add command.
type favoriteAddOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        Utility               utility.UtilityInterface
}

// NewFavoriteAddCommand creates a new favorite add command.
func NewFavoriteAddCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteAddOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_ADD_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteAddAliases()
        cmd.FieldCommand.RunE = o.favoriteAddRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_ADD_HELP_TEMPLATE)

        return cmd
}</span>

// favoriteAddRunE is the function that is called when the favorite add command is executed.
func (o *favoriteAddOption) favoriteAddRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // if no arguments is given, set default value to args
                o.Args = []string{constant.FAVORITE_USE, constant.FAVORITE_ADD_USE, ""}
        }</span>

        // set ID
        <span class="cov8" title="1">strconvProxy := strconvproxy.New()
        var IDs []int
        for _, arg := range o.Args[2:] </span><span class="cov8" title="1">{
                if id, err := strconvProxy.Atoi(arg); err != nil </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        IDs = append(IDs, id)
                }</span>
        }
        <span class="cov8" title="1">if len(IDs) == 0 </span><span class="cov8" title="1">{
                // if no ID is specified, print write and return
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_ADD_MESSAGE_NO_ID_SPECIFIED))
                return nil
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favoriteAdd(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME), IDs)</span>
}

// favoriteAdd adds the specified ID to favorite.
func (o *favoriteAddOption) favoriteAdd(jrpDBFilePath string, IDs []int) error <span class="cov8" title="1">{
        // if ID is specified, add to favorite
        res, err := o.JrpRepository.AddFavoriteByIDs(jrpDBFilePath, IDs)
        o.writeFavoriteAddResult(res)

        return err
}</span>

// writeFavoriteAddResult writes the result of favorite add.
func (o *favoriteAddOption) writeFavoriteAddResult(result repository.AddStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == repository.AddedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.FAVORITE_ADD_MESSAGE_ADDED_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == repository.AddedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.FAVORITE_ADD_MESSAGE_ADDED_NONE)
        }</span> else<span class="cov8" title="1"> if result == repository.AddedNotAll </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.FAVORITE_ADD_MESSAGE_ADDED_NOT_ALL)
        }</span> else<span class="cov8" title="1"> {
                message = colorProxy.GreenString(constant.FAVORITE_ADD_MESSAGE_ADDED_SUCCESSFULLY)
        }</span>
        <span class="cov8" title="1">o.Utility.PrintlnWithWriter(out, message)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteClearOption is the struct for favorite clear command.
type favoriteClearOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        NoConfirm             bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        PromptuiProxy         promptuiproxy.Promptui
        Utility               utility.UtilityInterface
}

// NewFavoriteClearCommand creates a new favorite clear command.
func NewFavoriteClearCommand(g *GlobalOption, promptuiProxy promptuiproxy.Promptui) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteClearOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.PromptuiProxy = promptuiProxy

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_CLEAR_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteClearAliases()
        cmd.FieldCommand.RunE = o.favoriteClearRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.NoConfirm,
                constant.FAVORITE_CLEAR_FLAG_NO_CONFIRM,
                constant.FAVORITE_CLEAR_FLAG_NO_CONFIRM_SHORTHAND,
                constant.FAVORITE_CLEAR_FLAG_NO_CONFIRM_DEFAULT,
                constant.FAVORITE_CLEAR_FLAG_NO_CONFIRM_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_CLEAR_HELP_TEMPLATE)

        return cmd
}</span>

// favoriteClearRunE is the function that is called when the favorite clear command is executed.
func (o *favoriteClearOption) favoriteClearRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        // get jrp db file dir path
        jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // write prompt if no-confirm option is not set
        <span class="cov8" title="1">if !o.NoConfirm </span><span class="cov8" title="1">{
                colorProxy := colorproxy.New()
                prompt := o.PromptuiProxy.NewPrompt()
                prompt.SetLabel(colorProxy.YellowString(constant.FAVORITE_CLEAR_PROMPT_LABEL))
                result, err := prompt.Run()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if result != "y" &amp;&amp; result != "Y" </span><span class="cov8" title="1">{
                        // write canceled message and do nothing
                        o.Utility.PrintlnWithWriter(o.Out, constant.FAVORITE_CLEAR_MESSAGE_CLEAR_CANCELED)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favoriteClear(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// favoriteClear clears all favorite.
func (o *favoriteClearOption) favoriteClear(jrpDBFilePath string) error <span class="cov8" title="1">{
        // remove all favorite
        res, err := o.JrpRepository.RemoveFavoriteAll(jrpDBFilePath)
        o.writeFavoriteClearResult(res)

        return err
}</span>

// writeFavoriteClearResult writes the result of favorite clear.
func (o *favoriteClearOption) writeFavoriteClearResult(result repository.RemoveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == repository.RemovedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.FAVORITE_CLEAR_MESSAGE_CLEARED_FAIRULE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.FAVORITE_CLEAR_MESSAGE_CLEARED_NONE)
        }</span> else<span class="cov8" title="1"> {
                message = colorProxy.GreenString(constant.FAVORITE_CLEAR_MESSAGE_CLEARED_SUCCESSFULLY)
        }</span>
        <span class="cov8" title="1">o.Utility.PrintlnWithWriter(out, message)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteRemoveOption is the struct for favorite remove command.
type favoriteRemoveOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        All                   bool
        NoConfirm             bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        PromptuiProxy         promptuiproxy.Promptui
        Utility               utility.UtilityInterface
}

// NewFavoriteRemoveCommand creates a new favorite remove command.
func NewFavoriteRemoveCommand(g *GlobalOption, promptuiProxy promptuiproxy.Promptui) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteRemoveOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.PromptuiProxy = promptuiProxy

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_REMOVE_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteRemoveAliases()
        cmd.FieldCommand.RunE = o.favoriteRemoveRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.All,
                constant.FAVORITE_REMOVE_FLAG_ALL,
                constant.FAVORITE_REMOVE_FLAG_ALL_SHORTHAND,
                constant.FAVORITE_REMOVE_FLAG_ALL_DEFAULT,
                constant.FAVORITE_REMOVE_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.NoConfirm,
                constant.FAVORITE_REMOVE_FLAG_NO_CONFIRM,
                constant.FAVORITE_REMOVE_FLAG_NO_CONFIRM_SHORTHAND,
                constant.FAVORITE_REMOVE_FLAG_NO_CONFIRM_DEFAULT,
                constant.FAVORITE_REMOVE_FLAG_NO_CONFIRM_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_REMOVE_HELP_TEMPLATE)

        return cmd
}</span>

// favoriteRemoveRunE is the function that is called when the favorite remove command is executed.
func (o *favoriteRemoveOption) favoriteRemoveRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // if no arguments is given, set default value to args
                o.Args = []string{constant.FAVORITE_USE, constant.FAVORITE_REMOVE_USE, ""}
        }</span>

        // set ID
        <span class="cov8" title="1">strconvProxy := strconvproxy.New()
        var IDs []int
        if !o.All </span><span class="cov8" title="1">{
                for _, arg := range o.Args[2:] </span><span class="cov8" title="1">{
                        if id, err := strconvProxy.Atoi(arg); err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                IDs = append(IDs, id)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(IDs) == 0 &amp;&amp; !o.All </span><span class="cov8" title="1">{
                // if no ID is specified, print write and return
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_REMOVE_MESSAGE_NO_ID_SPECIFIED))
                return nil
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // write prompt if all flag is set and no-confirm option is not set
        <span class="cov8" title="1">if o.All &amp;&amp; !o.NoConfirm </span><span class="cov8" title="1">{
                colorProxy := colorproxy.New()
                prompt := o.PromptuiProxy.NewPrompt()
                prompt.SetLabel(colorProxy.YellowString(constant.FAVORITE_REMOVE_PROMPT_REMOVE_ALL_LABEL))
                result, err := prompt.Run()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if result != "y" &amp;&amp; result != "Y" </span><span class="cov8" title="1">{
                        // write canceled message and do nothing
                        o.Utility.PrintlnWithWriter(o.Out, constant.FAVORITE_REMOVE_MESSAGE_REMOVE_ALL_CANCELED)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favoriteRemove(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME), IDs)</span>
}

// favoriteRemove removes favorite by IDs.
func (o *favoriteRemoveOption) favoriteRemove(jrpDBFilePath string, IDs []int) error <span class="cov8" title="1">{
        var res repository.RemoveStatus
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, remove all favorite
                res, err = o.JrpRepository.RemoveFavoriteAll(jrpDBFilePath)
        }</span> else<span class="cov8" title="1"> {
                // if IDs are specified, remove favorite by IDs
                res, err = o.JrpRepository.RemoveFavoriteByIDs(jrpDBFilePath, IDs)
        }</span>
        <span class="cov8" title="1">o.writeFavoriteRemoveResult(res)

        return err</span>
}

// writeFavoriteRemoveResult writes the result of favorite remove.
func (o *favoriteRemoveOption) writeFavoriteRemoveResult(result repository.RemoveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == repository.RemovedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.FAVORITE_REMOVE_MESSAGE_REMOVED_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.FAVORITE_REMOVE_MESSAGE_REMOVED_NONE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNotAll </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.FAVORITE_REMOVE_MESSAGE_REMOVED_NOT_ALL)
        }</span> else<span class="cov8" title="1"> {
                message = colorProxy.GreenString(constant.FAVORITE_REMOVE_MESSAGE_REMOVED_SUCCESSFULLY)
        }</span>
        <span class="cov8" title="1">o.Utility.PrintlnWithWriter(out, message)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteSearchOption is the struct for favorite search command.
type favoriteSearchOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        And                   bool
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewFavoriteSearchCommand creates a new favorite search command.
func NewFavoriteSearchCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteSearchOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_SEARCH_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteSearchAliases()
        cmd.FieldCommand.RunE = o.favoriteSearchRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.And,
                constant.FAVORITE_SEARCH_FLAG_AND,
                constant.FAVORITE_SEARCH_FLAG_AND_SHORTHAND,
                constant.FAVORITE_SEARCH_FLAG_AND_DEFAULT,
                constant.FAVORITE_SEARCH_FLAG_AND_DESCRIPTION,
        )
        cmd.PersistentFlags().IntVarP(&amp;o.Number,
                constant.FAVORITE_SEARCH_FLAG_NUMBER,
                constant.FAVORITE_SEARCH_FLAG_NUMBER_SHORTHAND,
                constant.FAVORITE_SEARCH_FLAG_NUMBER_DEFAULT,
                constant.FAVORITE_SEARCH_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.All,
                constant.FAVORITE_SEARCH_FLAG_ALL,
                constant.FAVORITE_SEARCH_FLAG_ALL_SHORTHAND,
                constant.FAVORITE_SEARCH_FLAG_ALL_DEFAULT,
                constant.FAVORITE_SEARCH_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.FAVORITE_SEARCH_FLAG_PLAIN,
                constant.FAVORITE_SEARCH_FLAG_PLAIN_SHORTHAND,
                constant.FAVORITE_SEARCH_FLAG_PLAIN_DEFAULT,
                constant.FAVORITE_SEARCH_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_SEARCH_HELP_TEMPLATE)

        return cmd
}</span>

// favoriteSearchRunE is the function that is called when the favorite search command is executed.
func (o *favoriteSearchOption) favoriteSearchRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // if no arguments is given, set default value to args
                o.Args = []string{constant.FAVORITE_USE, constant.FAVORITE_SEARCH_USE, ""}
        }</span>

        // set keywords
        <span class="cov8" title="1">var keywords []string
        for _, arg := range o.Args[2:] </span><span class="cov8" title="1">{
                if arg != "" </span><span class="cov8" title="1">{
                        keywords = append(keywords, arg)
                }</span>
        }
        <span class="cov8" title="1">if len(keywords) == 0 </span><span class="cov8" title="1">{
                // if no keywords are provided, write message and return
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_SEARCH_MESSAGE_NO_KEYWORDS_PROVIDED))
                return nil
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favoriteSearch(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME), keywords)</span>
}

// favoriteSearch searches favorite.
func (o *favoriteSearchOption) favoriteSearch(jrpDBFilePath string, keywords []string) error <span class="cov8" title="1">{
        var favorites []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, search all favorite
                favorites, err = o.JrpRepository.SearchAllFavorite(jrpDBFilePath, keywords, o.And)
        }</span> else<span class="cov8" title="1"> {
                // search favorite with the given number
                favorites, err = o.JrpRepository.SearchFavoriteWithNumber(
                        jrpDBFilePath,
                        o.Number,
                        keywords,
                        o.And,
                )
        }</span>
        <span class="cov8" title="1">o.writeFavoriteSearchResult(favorites)

        return err</span>
}

// writeFavoriteSearchResult writes the favorite search result.
func (o *favoriteSearchOption) writeFavoriteSearchResult(favorites []*model.Jrp) <span class="cov8" title="1">{
        if len(favorites) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, favorite := range favorites </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, favorite.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the favorite as a table
                        o.JrpWriter.WriteAsTable(o.Out, favorites)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no favorite is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_SEARCH_MESSAGE_NO_RESULT_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// favoriteShowOption is the struct for favorite show command.
type favoriteShowOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewFavoriteShowCommand creates a new favorite show command.
func NewFavoriteShowCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;favoriteShowOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.FAVORITE_SHOW_USE
        cmd.FieldCommand.Aliases = constant.GetFavoriteShowAliases()
        cmd.FieldCommand.Args = cobra.MaximumNArgs(1)
        cmd.FieldCommand.RunE = o.favoriteShowRunE

        cmd.PersistentFlags().IntVarP(
                &amp;o.Number,
                constant.FAVORITE_SHOW_FLAG_NUMBER,
                constant.FAVORITE_SHOW_FLAG_NUMBER_SHORTHAND,
                constant.FAVORITE_SHOW_FLAG_NUMBER_DEFAULT,
                constant.FAVORITE_SHOW_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.All,
                constant.FAVORITE_SHOW_FLAG_ALL,
                constant.FAVORITE_SHOW_FLAG_ALL_SHORTHAND,
                constant.FAVORITE_SHOW_FLAG_ALL_DEFAULT,
                constant.FAVORITE_SHOW_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.FAVORITE_SHOW_FLAG_PLAIN,
                constant.FAVORITE_SHOW_FLAG_PLAIN_SHORTHAND,
                constant.FAVORITE_SHOW_FLAG_PLAIN_DEFAULT,
                constant.FAVORITE_SHOW_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.FAVORITE_SHOW_HELP_TEMPLATE)

        cmd.SetArgs(o.Args)
        return cmd
}</span>

// favoriteShowRunE is the function that is called when the favorite show command is executed.
func (o *favoriteShowOption) favoriteShowRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // ifno arguments are given, set default value to args
                o.Args = []string{constant.FAVORITE_USE, constant.FAVORITE_SHOW_USE, strconvProxy.Itoa(constant.FAVORITE_SHOW_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.favoriteShow(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// favoriteShow is the function that gets the favorite.
func (o *favoriteShowOption) favoriteShow(jrpDBFilePath string) error <span class="cov8" title="1">{
        var favorites []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, get all favorite
                favorites, err = o.JrpRepository.GetAllFavorite(jrpDBFilePath)
        }</span> else<span class="cov8" title="1"> {
                strconvProxy := strconvproxy.New()
                // get the larger number between the given number flag and the largest number that can be converted from the args
                num := o.Utility.GetLargerNumber(
                        o.Number,
                        o.Utility.GetMaxConvertibleString(
                                o.Args,
                                strconvProxy.Itoa(constant.FAVORITE_SHOW_FLAG_NUMBER_DEFAULT),
                        ),
                )
                if o.Number != num &amp;&amp; o.Number &gt; 0 </span><span class="cov8" title="1">{
                        // if the number flag is littler than the default number, set the number flag value to num
                        num = o.Number
                }</span>
                // get favorite with the given number
                <span class="cov8" title="1">favorites, err = o.JrpRepository.GetFavoriteWithNumber(
                        jrpDBFilePath,
                        num,
                )</span>
        }
        <span class="cov8" title="1">o.writeFavoriteShowResult(favorites)

        return err</span>
}

// writeFavoriteShowResult writes the favorite show result.
func (o *favoriteShowOption) writeFavoriteShowResult(favorites []*model.Jrp) <span class="cov8" title="1">{
        if len(favorites) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, favorite := range favorites </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, favorite.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the favorite as a table
                        o.JrpWriter.WriteAsTable(o.Out, favorites)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no favorite is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.FAVORITE_SHOW_MESSAGE_NO_FAVORITE_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        jrprepository "github.com/yanosea/jrp/app/database/jrp/repository"
        wnjpnrepository "github.com/yanosea/jrp/app/database/wnjpn/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/generator"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/rand"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/time"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// generateOption is the struct for generate command.
type generateOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        Prefix                string
        Suffix                string
        DryRun                bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        Generator             generator.Generatable
        JrpRepository         jrprepository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        WNJpnRepository       wnjpnrepository.WNJpnRepositoryInterface
        Utility               utility.UtilityInterface
}

// NewGenerateCommand creates a new generate command.
func NewGenerateCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;generateOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = jrprepository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )
        o.WNJpnRepository = wnjpnrepository.New(
                sqlproxy.New(),
        )
        o.Generator = generator.New(
                osproxy.New(),
                randproxy.New(),
                sqlproxy.New(),
                timeproxy.New(),
                o.WNJpnRepository,
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.GENERATE_USE
        cmd.FieldCommand.Aliases = constant.GetGenerateAliases()
        cmd.FieldCommand.Args = cobra.MaximumNArgs(1)
        cmd.FieldCommand.RunE = o.generateRunE

        cmd.PersistentFlags().IntVarP(
                &amp;o.Number,
                constant.GENERATE_FLAG_NUMBER,
                constant.GENERATE_FLAG_NUMBER_SHORTHAND,
                constant.GENERATE_FLAG_NUMBER_DEFAULT,
                constant.GENERATE_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().StringVarP(
                &amp;o.Prefix,
                constant.GENERATE_FLAG_PREFIX,
                constant.GENERATE_FLAG_PREFIX_SHORTHAND,
                constant.GENERATE_FLAG_PREFIX_DEFAULT,
                constant.GENERATE_FLAG_PREFIX_DESCRIPTION,
        )
        cmd.PersistentFlags().StringVarP(
                &amp;o.Suffix,
                constant.GENERATE_FLAG_SUFFIX,
                constant.GENERATE_FLAG_SUFFIX_SHORTHAND,
                constant.GENERATE_FLAG_SUFFIX_DEFAULT,
                constant.GENERATE_FLAG_SUFFIX_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.DryRun,
                constant.GENERATE_FLAG_DRY_RUN,
                constant.GENERATE_FLAG_DRY_RUN_SHORTHAND,
                constant.GENERATE_FLAG_DRY_RUN_DEFAULT,
                constant.GENERATE_FLAG_DRY_RUN_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.Plain,
                constant.GENERATE_FLAG_PLAIN,
                constant.GENERATE_FLAG_PLAIN_SHORTHAND,
                constant.GENERATE_FLAG_PLAIN_DEFAULT,
                constant.GENERATE_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(o.Out)
        cmd.SetErr(o.ErrOut)
        cmd.SetHelpTemplate(constant.GENARETE_HELP_TEMPLATE)

        cmd.SetArgs(o.Args)

        return cmd
}</span>

// generateRunE is the function that is called when the generate command is executed.
func (o *generateOption) generateRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        var word string
        var mode generator.GenerateMode
        if o.Prefix != "" &amp;&amp; o.Suffix != "" </span><span class="cov8" title="1">{
                // if both prefix and suffix are provided, notify to use only one
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.GENERATE_MESSAGE_NOTIFY_USE_ONLY_ONE))
                return nil
        }</span> else<span class="cov8" title="1"> if o.Prefix != "" </span><span class="cov8" title="1">{
                word = o.Prefix
                mode = generator.WithPrefix
        }</span> else<span class="cov8" title="1"> if o.Suffix != "" </span><span class="cov8" title="1">{
                word = o.Suffix
                mode = generator.WithSuffix
        }</span>

        <span class="cov8" title="1">if len(o.Args) &lt;= 1 </span><span class="cov8" title="1">{
                strconvProxy := strconvproxy.New()
                // if no args are given, set the default value to the args
                o.Args = []string{constant.GENERATE_USE, strconvProxy.Itoa(constant.GENERATE_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">wnJpnDBFileDirPath, err := o.DBFileDirPathProvider.GetWNJpnDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.generate(
                filepathProxy.Join(wnJpnDBFileDirPath, wnjpnrepository.WNJPN_DB_FILE_NAME),
                filepathProxy.Join(jrpDBFileDirPath, jrprepository.JRP_DB_FILE_NAME),
                word,
                mode,
        )</span>
}

// generate generates jrpss and saves them.
func (o *generateOption) generate(
        wnJpnDBFilePath string,
        jrpDBFilePath string,
        word string,
        mode generator.GenerateMode,
) error <span class="cov8" title="1">{
        var jrps []*model.Jrp
        var err error
        jrps, err = o.generateGenerate(wnJpnDBFilePath, word, mode)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = o.generateSave(jrpDBFilePath, jrps)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">o.writeGenerateResult(jrps)

        return nil</span>
}

// generateGenerate generates jrps.
func (o *generateOption) generateGenerate(wnJpnDBFilePath string, word string, mode generator.GenerateMode) ([]*model.Jrp, error) <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        res, jrps, err := o.Generator.GenerateJrp(
                wnJpnDBFilePath,
                // get the larger number between the given number flag and the largest number that can be converted from the args
                o.Utility.GetLargerNumber(
                        o.Number,
                        o.Utility.GetMaxConvertibleString(
                                o.Args,
                                strconvProxy.Itoa(constant.GENERATE_FLAG_NUMBER_DEFAULT),
                        ),
                ),
                word,
                mode,
        )
        o.writeGenerateGenerateResult(res)

        return jrps, err
}</span>

// writeGenerateGenerateResult writes the result of generating jrps.
func (o *generateOption) writeGenerateGenerateResult(result generator.GenerateResult) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == generator.GeneratedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.GENERATE_MESSAGE_GENERATE_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == generator.DBFileNotFound </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.GENERATE_MESSAGE_NOTIFY_DOWNLOAD_REQUIRED)
        }</span>

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // if success, do not write any message
                o.Utility.PrintlnWithWriter(out, message)
        }</span>
}

// generateSave saves jrps.
func (o *generateOption) generateSave(jrpDBFilePath string, jrps []*model.Jrp) error <span class="cov8" title="1">{
        var res jrprepository.SaveStatus
        var err error
        if !o.DryRun &amp;&amp; len(jrps) != 0 </span><span class="cov8" title="1">{
                // if the dry-run flag is not set and the generated phrases are not empty, save the generated phrases
                res, err = o.JrpRepository.SaveHistory(jrpDBFilePath, jrps)
        }</span>
        <span class="cov8" title="1">o.writeGenerateSaveResult(res)

        return err</span>
}

// writeGenerateSaveResult writes the result of saving jrps.
func (o *generateOption) writeGenerateSaveResult(result jrprepository.SaveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == jrprepository.SavedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.GENERATE_MESSAGE_SAVED_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == jrprepository.SavedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.GENERATE_MESSAGE_SAVED_NONE)
        }</span> else<span class="cov8" title="1"> if result == jrprepository.SavedNotAll </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.GENERATE_MESSAGE_SAVED_NOT_ALL)
        }</span>

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // if success, do not write any message
                o.Utility.PrintlnWithWriter(out, message)
        }</span>
}

// writeGenerateResult writes the result of generate command.
func (o *generateOption) writeGenerateResult(jrps []*model.Jrp) <span class="cov8" title="1">{
        if len(jrps) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, jrp := range jrps </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, jrp.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the favorite as a table
                        o.JrpWriter.WriteGenerateResultAsTable(o.Out, jrps, !o.DryRun)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// historyOption is the struct for history command.
type historyOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewHistoryCommand creates a new history command.
func NewHistoryCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;historyOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()
        cmd.FieldCommand.Use = constant.HISTORY_USE
        cmd.FieldCommand.Aliases = constant.GetHistoryAliases()
        cmd.FieldCommand.Args = cobra.MaximumNArgs(1)
        cmd.FieldCommand.RunE = o.historyRunE

        cmd.PersistentFlags().IntVarP(&amp;o.Number,
                constant.HISTORY_FLAG_NUMBER,
                constant.HISTORY_FLAG_NUMBER_SHORTHAND,
                constant.HISTORY_FLAG_NUMBER_DEFAULT,
                constant.HISTORY_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.All,
                constant.HISTORY_FLAG_ALL,
                constant.HISTORY_FLAG_ALL_SHORTHAND,
                constant.HISTORY_FLAG_ALL_DEFAULT,
                constant.HISTORY_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.HISTORY_FLAG_PLAIN,
                constant.HISTORY_FLAG_PLAIN_SHORTHAND,
                constant.HISTORY_FLAG_PLAIN_DEFAULT,
                constant.HISTORY_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.HISTORY_HELP_TEMPLATE)

        cmd.AddCommand(
                NewHistoryShowCommand(g),
                NewHistoryRemoveCommand(g, promptuiproxy.New()),
                NewHistorySearchCommand(g),
                NewHistoryClearCommand(g, promptuiproxy.New()),
        )

        return cmd
}</span>

// historyRunE is the function that is called when the history command is executed.
func (o *historyOption) historyRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        if len(o.Args) &lt;= 1 </span><span class="cov8" title="1">{
                // if no argument is given, set the default value to args
                o.Args = []string{constant.HISTORY_USE, strconvProxy.Itoa(constant.HISTORY_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.history(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// history searches the history.
func (o *historyOption) history(jrpDBFilePath string) error <span class="cov8" title="1">{
        var histories []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, get all history
                histories, err = o.JrpRepository.GetAllHistory(jrpDBFilePath)
        }</span> else<span class="cov8" title="1"> {
                if o.Number != constant.HISTORY_FLAG_NUMBER_DEFAULT &amp;&amp; o.Number &gt;= 1 </span><span class="cov8" title="1">{
                        // if number flag is set, get history with the given number
                        histories, err = o.JrpRepository.GetHistoryWithNumber(jrpDBFilePath, o.Number)
                }</span> else<span class="cov8" title="1"> {
                        strconvProxy := strconvproxy.New()
                        // get history with the given number
                        histories, err = o.JrpRepository.GetHistoryWithNumber(
                                jrpDBFilePath,
                                // get the larger number between the given number flag and the largest number that can be converted from the args
                                o.Utility.GetLargerNumber(
                                        o.Number,
                                        o.Utility.GetMaxConvertibleString(
                                                o.Args,
                                                strconvProxy.Itoa(constant.HISTORY_FLAG_NUMBER_DEFAULT),
                                        ),
                                ),
                        )
                }</span>
        }
        <span class="cov8" title="1">o.writeHistoryResult(histories)

        return err</span>
}

// writeHistoryResult writes the history result.
func (o *historyOption) writeHistoryResult(histories []*model.Jrp) <span class="cov8" title="1">{
        if len(histories) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, history := range histories </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, history.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the history as a table
                        o.JrpWriter.WriteAsTable(o.Out, histories)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no history is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.HISTORY_MESSAGE_NO_HISTORY_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// historyClearOption is the struct for history clear command.
type historyClearOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Force                 bool
        NoConfirm             bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        PromptuiProxy         promptuiproxy.Promptui
        Utility               utility.UtilityInterface
}

// NewHistoryClearCommand creates a new history clear command.
func NewHistoryClearCommand(g *GlobalOption, promptuiProxy promptuiproxy.Promptui) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;historyClearOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.PromptuiProxy = promptuiProxy

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.HISTORY_CLEAR_USE
        cmd.FieldCommand.Aliases = constant.GetHistoryClearAliases()
        cmd.FieldCommand.RunE = o.historyClearRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.Force,
                constant.HISTORY_CLEAR_FLAG_FORCE,
                constant.HISTORY_CLEAR_FLAG_FORCE_SHORTHAND,
                constant.HISTORY_CLEAR_FLAG_FORCE_DEFAULT,
                constant.HISTORY_CLEAR_FLAG_FORCE_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.NoConfirm,
                constant.HISTORY_CLEAR_FLAG_NO_CONFIRM,
                constant.HISTORY_CLEAR_FLAG_NO_CONFIRM_SHORTHAND,
                constant.HISTORY_CLEAR_FLAG_NO_CONFIRM_DEFAULT,
                constant.HISTORY_CLEAR_FLAG_NO_CONFIRM_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.HISTORY_CLEAR_HELP_TEMPLATE)

        return cmd
}</span>

// historyClearRunE is the function that is called when the history clear command is executed.
func (o *historyClearOption) historyClearRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        // get jrp db file dir path
        jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // write prompt if no-confirm option is not set
        <span class="cov8" title="1">if !o.NoConfirm </span><span class="cov8" title="1">{
                colorProxy := colorproxy.New()
                prompt := o.PromptuiProxy.NewPrompt()
                prompt.SetLabel(colorProxy.YellowString(constant.HISTORY_CLEAR_PROMPT_LABEL))
                result, err := prompt.Run()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if result != "y" &amp;&amp; result != "Y" </span><span class="cov8" title="1">{
                        // write canceled message and do nothing
                        o.Utility.PrintlnWithWriter(o.Out, constant.HISTORY_CLEAR_MESSAGE_CLEAR_CANCELED)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.historyClear(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// historyClear clears all history.
func (o *historyClearOption) historyClear(jrpDBFilePath string) error <span class="cov8" title="1">{
        // remove all history
        res, err := o.JrpRepository.RemoveHistoryAll(jrpDBFilePath, o.Force)
        o.writeHistoryClearResult(res)

        return err
}</span>

// writeHistoryClearResult writes the result of history clear.
func (o *historyClearOption) writeHistoryClearResult(result repository.RemoveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == repository.RemovedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.HISTORY_CLEAR_MESSAGE_CLEARED_FAIRULE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNone &amp;&amp; !o.Force </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.HISTORY_CLEAR_MESSAGE_CLEARED_NONE)
        }</span> else<span class="cov8" title="1"> {
                message = colorProxy.GreenString(constant.HISTORY_CLEAR_MESSAGE_CLEARED_SUCCESSFULLY)
        }</span>
        <span class="cov8" title="1">o.Utility.PrintlnWithWriter(out, message)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/promptui"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// historyRemoveOption is the struct for history remove command.
type historyRemoveOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        All                   bool
        Force                 bool
        NoConfirm             bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        PromptuiProxy         promptuiproxy.Promptui
        Utility               utility.UtilityInterface
}

// NewHistoryRemoveCommand creates a new history remove command.
func NewHistoryRemoveCommand(g *GlobalOption, promptuiProxy promptuiproxy.Promptui) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;historyRemoveOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.PromptuiProxy = promptuiProxy

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.HISTORY_REMOVE_USE
        cmd.FieldCommand.Aliases = constant.GetHistoryRemoveAliases()
        cmd.FieldCommand.RunE = o.historyRemoveRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.All,
                constant.HISTORY_REMOVE_FLAG_ALL,
                constant.HISTORY_REMOVE_FLAG_ALL_SHORTHAND,
                constant.HISTORY_REMOVE_FLAG_ALL_DEFAULT,
                constant.HISTORY_REMOVE_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.Force,
                constant.HISTORY_REMOVE_FLAG_FORCE,
                constant.HISTORY_REMOVE_FLAG_FORCE_SHORTHAND,
                constant.HISTORY_REMOVE_FLAG_FORCE_DEFAULT,
                constant.HISTORY_REMOVE_FLAG_FORCE_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.NoConfirm,
                constant.HISTORY_REMOVE_FLAG_NO_CONFIRM,
                constant.HISTORY_REMOVE_FLAG_NO_CONFIRM_SHORTHAND,
                constant.HISTORY_REMOVE_FLAG_NO_CONFIRM_DEFAULT,
                constant.HISTORY_REMOVE_FLAG_NO_CONFIRM_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.HISTORY_REMOVE_HELP_TEMPLATE)

        return cmd
}</span>

// historyRemoveRunE is the function that is called when the history remove command is executed.
func (o *historyRemoveOption) historyRemoveRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // if no arguments is given, set default value to args
                o.Args = []string{constant.HISTORY_USE, constant.HISTORY_REMOVE_USE, ""}
        }</span>

        // set ID
        <span class="cov8" title="1">strconvProxy := strconvproxy.New()
        var IDs []int
        if !o.All </span><span class="cov8" title="1">{
                for _, arg := range o.Args[2:] </span><span class="cov8" title="1">{
                        if id, err := strconvProxy.Atoi(arg); err != nil </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                IDs = append(IDs, id)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(IDs) == 0 &amp;&amp; !o.All </span><span class="cov8" title="1">{
                // if no ID is specified, print write and return
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.HISTORY_REMOVE_MESSAGE_NO_ID_SPECIFIED))
                return nil
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // write prompt if all flag is set and no-confirm option is not set
        <span class="cov8" title="1">if o.All &amp;&amp; !o.NoConfirm </span><span class="cov8" title="1">{
                colorProxy := colorproxy.New()
                prompt := o.PromptuiProxy.NewPrompt()
                prompt.SetLabel(colorProxy.YellowString(constant.HISTORY_REMOVE_PROMPT_REMOVE_ALL_LABEL))
                result, err := prompt.Run()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if result != "y" &amp;&amp; result != "Y" </span><span class="cov8" title="1">{
                        // write canceled message and do nothing
                        o.Utility.PrintlnWithWriter(o.Out, constant.HISTORY_REMOVE_MESSAGE_REMOVE_ALL_CANCELED)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.historyRemove(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME), IDs)</span>
}

// historyRemove is the function that removes history by IDs.
func (o *historyRemoveOption) historyRemove(jrpDBFilePath string, IDs []int) error <span class="cov8" title="1">{
        var res repository.RemoveStatus
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, remove all history
                res, err = o.JrpRepository.RemoveHistoryAll(jrpDBFilePath, o.Force)
        }</span> else<span class="cov8" title="1"> {
                // if IDs are specified, remove history by IDs
                res, err = o.JrpRepository.RemoveHistoryByIDs(jrpDBFilePath, IDs, o.Force)
        }</span>
        <span class="cov8" title="1">o.writeHistoryRemoveResult(res)

        return err</span>
}

// writeHistoryRemoveResult writes the result of history remove.
func (o *historyRemoveOption) writeHistoryRemoveResult(result repository.RemoveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == repository.RemovedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.HISTORY_REMOVE_MESSAGE_REMOVED_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.HISTORY_REMOVE_MESSAGE_REMOVED_NONE)
        }</span> else<span class="cov8" title="1"> if result == repository.RemovedNotAll </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.HISTORY_REMOVE_MESSAGE_REMOVED_NOT_ALL)
        }</span> else<span class="cov8" title="1"> {
                message = colorProxy.GreenString(constant.HISTORY_REMOVE_MESSAGE_REMOVED_SUCCESSFULLY)
        }</span>
        <span class="cov8" title="1">o.Utility.PrintlnWithWriter(out, message)</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// historySearchOption is the struct for history search command.
type historySearchOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        And                   bool
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewHistorySearchCommand creates a new history search command.
func NewHistorySearchCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;historySearchOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.HISTORY_SEARCH_USE
        cmd.FieldCommand.Aliases = constant.GetHistorySearchAliases()
        cmd.FieldCommand.RunE = o.historySearchRunE

        cmd.PersistentFlags().BoolVarP(
                &amp;o.And,
                constant.HISTORY_SEARCH_FLAG_AND,
                constant.HISTORY_SEARCH_FLAG_AND_SHORTHAND,
                constant.HISTORY_SEARCH_FLAG_AND_DEFAULT,
                constant.HISTORY_SEARCH_FLAG_AND_DESCRIPTION,
        )
        cmd.PersistentFlags().IntVarP(&amp;o.Number,
                constant.HISTORY_SEARCH_FLAG_NUMBER,
                constant.HISTORY_SEARCH_FLAG_NUMBER_SHORTHAND,
                constant.HISTORY_SEARCH_FLAG_NUMBER_DEFAULT,
                constant.HISTORY_SEARCH_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.All,
                constant.HISTORY_SEARCH_FLAG_ALL,
                constant.HISTORY_SEARCH_FLAG_ALL_SHORTHAND,
                constant.HISTORY_SEARCH_FLAG_ALL_DEFAULT,
                constant.HISTORY_SEARCH_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.HISTORY_SEARCH_FLAG_PLAIN,
                constant.HISTORY_SEARCH_FLAG_PLAIN_SHORTHAND,
                constant.HISTORY_SEARCH_FLAG_PLAIN_DEFAULT,
                constant.HISTORY_SEARCH_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.HISTORY_SEARCH_HELP_TEMPLATE)

        return cmd
}</span>

// historySearchRunE is the function that is called when the history search command is executed.
func (o *historySearchOption) historySearchRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // if no arguments is given, set default value to args
                o.Args = []string{constant.HISTORY_USE, constant.HISTORY_SEARCH_USE, ""}
        }</span>

        // set keywords
        <span class="cov8" title="1">var keywords []string
        for _, arg := range o.Args[2:] </span><span class="cov8" title="1">{
                if arg != "" </span><span class="cov8" title="1">{
                        keywords = append(keywords, arg)
                }</span>
        }
        <span class="cov8" title="1">if len(keywords) == 0 </span><span class="cov8" title="1">{
                // if no keywords are provided, write message and return
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.HISTORY_SEARCH_MESSAGE_NO_KEYWORDS_PROVIDED))
                return nil
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.historySearch(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME), keywords)</span>
}

// historySearch searches the history with the given keywords.
func (o *historySearchOption) historySearch(jrpDBFilePath string, keywords []string) error <span class="cov8" title="1">{
        var histories []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, search all history
                histories, err = o.JrpRepository.SearchAllHistory(jrpDBFilePath, keywords, o.And)
        }</span> else<span class="cov8" title="1"> {
                // search history with the given number
                histories, err = o.JrpRepository.SearchHistoryWithNumber(
                        jrpDBFilePath,
                        o.Number,
                        keywords,
                        o.And,
                )
        }</span>
        <span class="cov8" title="1">o.writeHistorySearchResult(histories)

        return err</span>
}

// writeHistorySearchResult writes the history search result.
func (o *historySearchOption) writeHistorySearchResult(histories []*model.Jrp) <span class="cov8" title="1">{
        if len(histories) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, hist := range histories </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, hist.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the history as a table
                        o.JrpWriter.WriteAsTable(o.Out, histories)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no history is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.HISTORY_SEARCH_MESSAGE_NO_RESULT_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/database/jrp/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// historyShowOption is the struct for history show command.
type historyShowOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        All                   bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        JrpRepository         repository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        Utility               utility.UtilityInterface
}

// NewHistoryShowCommand creates a new history show command.
func NewHistoryShowCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        o := &amp;historyShowOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    g.Args,
                Utility: g.Utility,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = repository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.HISTORY_SHOW_USE
        cmd.FieldCommand.Args = cobra.MaximumNArgs(1)
        cmd.FieldCommand.RunE = o.historyShowRunE

        cmd.PersistentFlags().IntVarP(
                &amp;o.Number,
                constant.HISTORY_SHOW_FLAG_NUMBER,
                constant.HISTORY_SHOW_FLAG_NUMBER_SHORTHAND,
                constant.HISTORY_SHOW_FLAG_NUMBER_DEFAULT,
                constant.HISTORY_SHOW_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.All,
                constant.HISTORY_SHOW_FLAG_ALL,
                constant.HISTORY_SHOW_FLAG_ALL_SHORTHAND,
                constant.HISTORY_SHOW_FLAG_ALL_DEFAULT,
                constant.HISTORY_SHOW_FLAG_ALL_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(&amp;o.Plain,
                constant.HISTORY_SHOW_FLAG_PLAIN,
                constant.HISTORY_SHOW_FLAG_PLAIN_SHORTHAND,
                constant.HISTORY_SHOW_FLAG_PLAIN_DEFAULT,
                constant.HISTORY_SHOW_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.HISTORY_SHOW_HELP_TEMPLATE)

        cmd.SetArgs(o.Args)
        return cmd
}</span>

// historyShowRunE is the function to run history show command.
func (o *historyShowOption) historyShowRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        if len(o.Args) &lt;= 2 </span><span class="cov8" title="1">{
                // ifno arguments are given, set default value to args
                o.Args = []string{constant.HISTORY_USE, constant.HISTORY_SHOW_USE, strconvProxy.Itoa(constant.HISTORY_SHOW_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // create the directory if it does not exist
        <span class="cov8" title="1">if err := o.Utility.CreateDirIfNotExist(jrpDBFileDirPath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.historyShow(filepathProxy.Join(jrpDBFileDirPath, repository.JRP_DB_FILE_NAME))</span>
}

// historyShow shows the history.
func (o *historyShowOption) historyShow(jrpDBFilePath string) error <span class="cov8" title="1">{
        var histories []*model.Jrp
        var err error
        if o.All </span><span class="cov8" title="1">{
                // if all flag is set, get all history
                histories, err = o.JrpRepository.GetAllHistory(jrpDBFilePath)
        }</span> else<span class="cov8" title="1"> {
                strconvProxy := strconvproxy.New()
                // get the larger number between the given number flag and the largest number that can be converted from the args
                num := o.Utility.GetLargerNumber(
                        o.Number,
                        o.Utility.GetMaxConvertibleString(
                                o.Args,
                                strconvProxy.Itoa(constant.HISTORY_SHOW_FLAG_NUMBER_DEFAULT),
                        ),
                )
                if o.Number != num &amp;&amp; o.Number &gt; 0 </span><span class="cov8" title="1">{
                        // if the number flag is littler than the default number, set the number flag value to num
                        num = o.Number
                }</span>
                // get history with the given num
                <span class="cov8" title="1">histories, err = o.JrpRepository.GetHistoryWithNumber(
                        jrpDBFilePath,
                        num,
                )</span>
        }
        <span class="cov8" title="1">o.writeHistoryShowResult(histories)

        return err</span>
}

// writeHistory writes the history.
func (o *historyShowOption) writeHistoryShowResult(histories []*model.Jrp) <span class="cov8" title="1">{
        if len(histories) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, history := range histories </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, history.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the history as a table
                        o.JrpWriter.WriteAsTable(o.Out, histories)
                }</span>
        } else<span class="cov8" title="1"> {
                // if no history is found, write the message
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.HISTORY_SHOW_MESSAGE_NO_HISTORY_FOUND))
        }</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/database/jrp/model"
        jrprepository "github.com/yanosea/jrp/app/database/jrp/repository"
        wnjpnrepository "github.com/yanosea/jrp/app/database/wnjpn/repository"
        "github.com/yanosea/jrp/app/library/dbfiledirpathprovider"
        "github.com/yanosea/jrp/app/library/generator"
        "github.com/yanosea/jrp/app/library/jrpwriter"
        "github.com/yanosea/jrp/app/library/utility"
        "github.com/yanosea/jrp/app/library/versionprovider"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/color"
        "github.com/yanosea/jrp/app/proxy/debug"
        "github.com/yanosea/jrp/app/proxy/filepath"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/io"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/rand"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/tablewriter"
        "github.com/yanosea/jrp/app/proxy/time"
        "github.com/yanosea/jrp/app/proxy/user"
        "github.com/yanosea/jrp/cmd/constant"
)

// ver is the version of the jrp.
var ver = ""

// GlobalOption is the struct for global option.
type GlobalOption struct {
        Out            ioproxy.WriterInstanceInterface
        ErrOut         ioproxy.WriterInstanceInterface
        Args           []string
        Utility        utility.UtilityInterface
        NewRootCommand func(ow, ew ioproxy.WriterInstanceInterface, args []string) cobraproxy.CommandInstanceInterface
}

// rootOption is the struct for root command.
type rootOption struct {
        Out                   ioproxy.WriterInstanceInterface
        ErrOut                ioproxy.WriterInstanceInterface
        Args                  []string
        Number                int
        Prefix                string
        Suffix                string
        DryRun                bool
        Plain                 bool
        DBFileDirPathProvider dbfiledirpathprovider.DBFileDirPathProvidable
        Generator             generator.Generatable
        JrpRepository         jrprepository.JrpRepositoryInterface
        JrpWriter             jrpwriter.JrpWritable
        WNJpnRepository       wnjpnrepository.WNJpnRepositoryInterface
        Utility               utility.UtilityInterface
}

// NewGlobalOption creates a new global option.
func NewGlobalOption(fmtProxy fmtproxy.Fmt, osProxy osproxy.Os, strconvProxy strconvproxy.Strconv) *GlobalOption <span class="cov8" title="1">{
        return &amp;GlobalOption{
                Out:    osproxy.Stdout,
                ErrOut: osproxy.Stderr,
                Args:   osproxy.Args[1:],
                Utility: utility.New(
                        fmtProxy,
                        osProxy,
                        strconvProxy,
                ),
                NewRootCommand: NewRootCommand,
        }
}</span>

// Execute executes the jrp.
func (g *GlobalOption) Execute() int <span class="cov8" title="1">{
        rootCmd := g.NewRootCommand(g.Out, g.ErrOut, g.Args)
        if err := rootCmd.Execute(); err != nil </span><span class="cov8" title="1">{
                colorProxy := colorproxy.New()
                g.Utility.PrintlnWithWriter(g.ErrOut, colorProxy.RedString(err.Error()))
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// NewRootCommand creates a new root command.
func NewRootCommand(ow, ew ioproxy.WriterInstanceInterface, cmdArgs []string) cobraproxy.CommandInstanceInterface <span class="cov8" title="1">{
        util := utility.New(
                fmtproxy.New(),
                osproxy.New(),
                strconvproxy.New(),
        )
        g := &amp;GlobalOption{
                Out:     ow,
                ErrOut:  ew,
                Args:    cmdArgs,
                Utility: util,
        }
        o := &amp;rootOption{
                Out:     g.Out,
                ErrOut:  g.ErrOut,
                Args:    cmdArgs,
                Utility: util,
        }
        o.DBFileDirPathProvider = dbfiledirpathprovider.New(
                filepathproxy.New(),
                osproxy.New(),
                userproxy.New(),
        )
        o.JrpRepository = jrprepository.New(
                fmtproxy.New(),
                sortproxy.New(),
                sqlproxy.New(),
                stringsproxy.New(),
        )
        o.JrpWriter = jrpwriter.New(
                strconvproxy.New(),
                tablewriterproxy.New(),
        )
        o.WNJpnRepository = wnjpnrepository.New(
                sqlproxy.New(),
        )
        o.Generator = generator.New(
                osproxy.New(),
                randproxy.New(),
                sqlproxy.New(),
                timeproxy.New(),
                o.WNJpnRepository,
        )

        v := versionprovider.New(debugproxy.New())

        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.ROOT_USE
        cmd.FieldCommand.Version = v.GetVersion(ver)
        cmd.FieldCommand.SilenceErrors = true
        cmd.FieldCommand.SilenceUsage = true
        cmd.FieldCommand.Args = cobraProxy.MaximumNArgs(1).FieldPositionalArgs
        cmd.FieldCommand.RunE = o.rootRunE

        cmd.PersistentFlags().IntVarP(
                &amp;o.Number,
                constant.ROOT_FLAG_NUMBER,
                constant.ROOT_FLAG_NUMBER_SHORTHAND,
                constant.ROOT_FLAG_NUMBER_DEFAULT,
                constant.ROOT_FLAG_NUMBER_DESCRIPTION,
        )
        cmd.PersistentFlags().StringVarP(
                &amp;o.Prefix,
                constant.ROOT_FLAG_PREFIX,
                constant.ROOT_FLAG_PREFIX_SHORTHAND,
                constant.ROOT_FLAG_PREFIX_DEFAULT,
                constant.ROOT_FLAG_PREFIX_DESCRIPTION,
        )
        cmd.PersistentFlags().StringVarP(
                &amp;o.Suffix,
                constant.ROOT_FLAG_SUFFIX,
                constant.ROOT_FLAG_SUFFIX_SHORTHAND,
                constant.ROOT_FLAG_SUFFIX_DEFAULT,
                constant.ROOT_FLAG_SUFFIX_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.DryRun,
                constant.ROOT_FLAG_DRY_RUN,
                constant.ROOT_FLAG_DRY_RUN_SHORTHAND,
                constant.ROOT_FLAG_DRY_RUN_DEFAULT,
                constant.ROOT_FLAG_DRY_RUN_DESCRIPTION,
        )
        cmd.PersistentFlags().BoolVarP(
                &amp;o.Plain,
                constant.ROOT_FLAG_PLAIN,
                constant.ROOT_FLAG_PLAIN_SHORTHAND,
                constant.ROOT_FLAG_PLAIN_DEFAULT,
                constant.ROOT_FLAG_PLAIN_DESCRIPTION,
        )

        cmd.SetOut(ow)
        cmd.SetErr(ew)
        cmd.SetHelpTemplate(constant.ROOT_HELP_TEMPLATE)

        cmd.AddCommand(
                NewDownloadCommand(g),
                NewFavoriteCommand(g),
                NewGenerateCommand(g),
                NewHistoryCommand(g),
                NewVersionCommand(g),
                NewCompletionCommand(g),
        )

        cmd.SetArgs(cmdArgs)

        return cmd
}</span>

// rootRunE is the function to run root command.
func (o *rootOption) rootRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        var word string
        var mode generator.GenerateMode
        if o.Prefix != "" &amp;&amp; o.Suffix != "" </span><span class="cov8" title="1">{
                // if both prefix and suffix are provided, notify to use only one
                colorProxy := colorproxy.New()
                o.Utility.PrintlnWithWriter(o.Out, colorProxy.YellowString(constant.GENERATE_MESSAGE_NOTIFY_USE_ONLY_ONE))
                return nil
        }</span> else<span class="cov8" title="1"> if o.Prefix != "" </span><span class="cov8" title="1">{
                word = o.Prefix
                mode = generator.WithPrefix
        }</span> else<span class="cov8" title="1"> if o.Suffix != "" </span><span class="cov8" title="1">{
                word = o.Suffix
                mode = generator.WithSuffix
        }</span>

        <span class="cov8" title="1">if len(o.Args) == 0 </span><span class="cov8" title="1">{
                strconvProxy := strconvproxy.New()
                // if no args are given, set the default value to the args
                o.Args = []string{strconvProxy.Itoa(constant.ROOT_FLAG_NUMBER_DEFAULT)}
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">wnJpnDBFileDirPath, err := o.DBFileDirPathProvider.GetWNJpnDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // get jrp db file dir path
        <span class="cov8" title="1">jrpDBFileDirPath, err := o.DBFileDirPathProvider.GetJrpDBFileDirPath()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // execute root command
        <span class="cov8" title="1">filepathProxy := filepathproxy.New()
        return o.root(
                filepathProxy.Join(wnJpnDBFileDirPath, wnjpnrepository.WNJPN_DB_FILE_NAME),
                filepathProxy.Join(jrpDBFileDirPath, jrprepository.JRP_DB_FILE_NAME),
                word,
                mode,
        )</span>
}

// root generates jrpss and saves them.
func (o *rootOption) root(
        wnJpnDBFilePath string,
        jrpDBFilePath string,
        word string,
        mode generator.GenerateMode,
) error <span class="cov8" title="1">{
        var jrps []*model.Jrp
        var err error
        jrps, err = o.rootGenerate(wnJpnDBFilePath, word, mode)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">err = o.rootSave(jrpDBFilePath, jrps)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">o.writeRootResult(jrps)

        return nil</span>
}

// rootGenerate generates jrpss.
func (o *rootOption) rootGenerate(wnJpnDBFilePath string, word string, mode generator.GenerateMode) ([]*model.Jrp, error) <span class="cov8" title="1">{
        strconvProxy := strconvproxy.New()
        res, jrps, err := o.Generator.GenerateJrp(
                wnJpnDBFilePath,
                // get the larger number between the given number flag and the largest number that can be converted from the args
                o.Utility.GetLargerNumber(
                        o.Number,
                        o.Utility.GetMaxConvertibleString(
                                o.Args,
                                strconvProxy.Itoa(constant.ROOT_FLAG_NUMBER_DEFAULT),
                        ),
                ),
                word,
                mode,
        )
        o.writeRootGenerateResult(res)

        return jrps, err
}</span>

// writeRootGenerateResult writes the result of the generation.
func (o *rootOption) writeRootGenerateResult(result generator.GenerateResult) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == generator.GeneratedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.ROOT_MESSAGE_GENERATE_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == generator.DBFileNotFound </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.ROOT_MESSAGE_NOTIFY_DOWNLOAD_REQUIRED)
        }</span>

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // if success, do not write any message
                o.Utility.PrintlnWithWriter(out, message)
        }</span>
}

// rootSave saves jrpss.
func (o *rootOption) rootSave(jrpDBFilePath string, jrps []*model.Jrp) error <span class="cov8" title="1">{
        var res jrprepository.SaveStatus
        var err error
        if !o.DryRun &amp;&amp; len(jrps) != 0 </span><span class="cov8" title="1">{
                // if the dry-run flag is not set and the generated phrases are not empty, save the generated phrases
                res, err = o.JrpRepository.SaveHistory(jrpDBFilePath, jrps)
        }</span>
        <span class="cov8" title="1">o.writeRootSaveResult(res)
        return err</span>
}

// writeRootSaveResult writes the result of saving jrps.
func (o *rootOption) writeRootSaveResult(result jrprepository.SaveStatus) <span class="cov8" title="1">{
        var out = o.Out
        var message string
        colorProxy := colorproxy.New()
        if result == jrprepository.SavedFailed </span><span class="cov8" title="1">{
                out = o.ErrOut
                message = colorProxy.RedString(constant.ROOT_MESSAGE_SAVED_FAILURE)
        }</span> else<span class="cov8" title="1"> if result == jrprepository.SavedNone </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.ROOT_MESSAGE_SAVED_NONE)
        }</span> else<span class="cov8" title="1"> if result == jrprepository.SavedNotAll </span><span class="cov8" title="1">{
                message = colorProxy.YellowString(constant.ROOT_MESSAGE_SAVED_NOT_ALL)
        }</span>

        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // if success, do not write any message
                o.Utility.PrintlnWithWriter(out, message)
        }</span>
}

// writeRootResult writes the result of the root command.
func (o *rootOption) writeRootResult(jrps []*model.Jrp) <span class="cov8" title="1">{
        if len(jrps) != 0 </span><span class="cov8" title="1">{
                if o.Plain </span><span class="cov8" title="1">{
                        for _, jrp := range jrps </span><span class="cov8" title="1">{
                                // if plain flag is set, write only the phrase
                                o.Utility.PrintlnWithWriter(o.Out, jrp.Phrase)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // if plain flag is not set, write the favorite as a table
                        o.JrpWriter.WriteGenerateResultAsTable(o.Out, jrps, !o.DryRun)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/yanosea/jrp/app/library/versionprovider"
        "github.com/yanosea/jrp/app/proxy/cobra"
        "github.com/yanosea/jrp/app/proxy/debug"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/cmd/constant"
)

// NewVersionCommand creates a new version command.
func NewVersionCommand(g *GlobalOption) *cobraproxy.CommandInstance <span class="cov8" title="1">{
        cobraProxy := cobraproxy.New()
        cmd := cobraProxy.NewCommand()

        cmd.FieldCommand.Use = constant.VERSION_USE
        cmd.FieldCommand.RunE = g.versionRunE

        cmd.SetOut(g.Out)
        cmd.SetErr(g.ErrOut)
        cmd.SetHelpTemplate(constant.VERSION_HELP_TEMPLATE)

        return cmd
}</span>

// versionRunE is the function that is called when the version command is executed.
func (g *GlobalOption) versionRunE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return g.version()
}</span>

// version shows the version of jrp.
func (g *GlobalOption) version() error <span class="cov8" title="1">{
        v := versionprovider.New(debugproxy.New())
        fmtProxy := fmtproxy.New()
        // get version from buildinfo and write it
        g.Utility.PrintlnWithWriter(g.Out, fmtProxy.Sprintf(constant.VERSION_MESSAGE_TEMPLATE, v.GetVersion(ver)))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Package main is the entry point of jrp.
package main

import (
        "os"

        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/os"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/cmd"
)

// fmtProxy is variable for fmt.Proxy.
var fmtProxy = fmtproxy.New()

// osProxy is variable for os.Proxy.
var osProxy = osproxy.New()

// strconvProxy is variable for strconv.Proxy.
var strconvProxy = strconvproxy.New()

// osExit is variable for os.Exit.
var osExit = os.Exit

// main is the entry point of jrp.
func main() <span class="cov8" title="1">{
        g := cmd.NewGlobalOption(fmtProxy, osProxy, strconvProxy)
        osExit(g.Execute())
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package testutility

import (
        "testing"

        "github.com/yanosea/jrp/app/proxy/buffer"
        "github.com/yanosea/jrp/app/proxy/os"
)

// Capturable is an interface for capturing output.
type Capturable interface {
        CaptureOutput() (string, string, error)
}

// Capturer is a struct for capturing output.
type Capturer struct {
        OutBuffer bufferproxy.Buffer
        ErrBuffer bufferproxy.Buffer
        OsProxy   osproxy.Os
}

// NewCapturer is a constructor for Capturer.
func NewCapturer(
        outBuffer bufferproxy.Buffer,
        errBuffer bufferproxy.Buffer,
        osProxy osproxy.Os,
) *Capturer <span class="cov8" title="1">{
        return &amp;Capturer{
                OutBuffer: outBuffer,
                ErrBuffer: errBuffer,
                OsProxy:   osProxy,
        }
}</span>

// CaptureOutput captures the output of the function and returns the captured.
func (c *Capturer) CaptureOutput(t *testing.T, fnc func()) (string, string, error) <span class="cov8" title="1">{
        t.Helper()

        // save the original stdout and stderr
        origStdout := osproxy.Stdout
        origStderr := osproxy.Stderr
        defer func() </span><span class="cov8" title="1">{
                osproxy.Stdout = origStdout
                osproxy.Stderr = origStderr
        }</span>()

        // create a pipe for stdout and stderr
        <span class="cov8" title="1">rOut, wOut, _ := c.OsProxy.Pipe()
        rErr, wErr, _ := c.OsProxy.Pipe()
        osproxy.Stdout = wOut.FieldFile
        osproxy.Stderr = wErr.FieldFile

        // execute the function
        fnc()

        // close the pipe
        wOut.Close()
        wErr.Close()

        // read from the pipe of stdout
        if _, err := c.OutBuffer.ReadFrom(rOut); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        // read from the pipe of stderr
        <span class="cov8" title="1">if _, err := c.ErrBuffer.ReadFrom(rErr); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        // return the captured output
        <span class="cov8" title="1">stdout := c.OutBuffer.String()
        errout := c.ErrBuffer.String()

        // reset the buffer
        c.OutBuffer.Reset()
        c.ErrBuffer.Reset()

        return stdout, errout, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package testutility

import (
        "github.com/yanosea/jrp/app/database/jrp/model"
        "github.com/yanosea/jrp/app/proxy/fmt"
        "github.com/yanosea/jrp/app/proxy/sort"
        "github.com/yanosea/jrp/app/proxy/sql"
        "github.com/yanosea/jrp/app/proxy/strconv"
        "github.com/yanosea/jrp/app/proxy/strings"
        "github.com/yanosea/jrp/app/proxy/time"
)

// JrpCheckerInterface is an interface for checking Jrp.
type JrpCheckerInterface interface {
        GetJrpSeq(jrpDBFilePath string) (int, error)
        IsExist(jrpDBFilePath string, id int) (bool, error)
        IsFavorited(jrpDBFilePath string, id int) (bool, error)
        IsSameJrps(got, want []*model.Jrp) bool
}

// JrpChecker is a struct for checking Jrp.
type JrpChecker struct {
        FmtProxy     fmtproxy.Fmt
        SortProxy    sortproxy.Sort
        SqlProxy     sqlproxy.Sql
        StrconvProxy strconvproxy.Strconv
        StringsProxy stringsproxy.Strings
}

// NewJrpChecker is a constructor for JrpChecker.
func NewJrpChecker(
        fmtProxy fmtproxy.Fmt,
        sortProxy sortproxy.Sort,
        sqlProxy sqlproxy.Sql,
        strconvProxy strconvproxy.Strconv,
        stringsProxy stringsproxy.Strings,
) *JrpChecker <span class="cov8" title="1">{
        return &amp;JrpChecker{
                FmtProxy:     fmtProxy,
                SortProxy:    sortProxy,
                SqlProxy:     sqlProxy,
                StrconvProxy: strconvProxy,
                StringsProxy: stringsProxy,
        }
}</span>

// GetJrpSeq returns the sequence of jrp.
func (j *JrpChecker) GetJrpSeq(jrpDBFilePath string) (int, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        <span class="cov8" title="1">rows, err := db.Query("SELECT seq FROM sqlite_sequence WHERE sqlite_sequence.name = 'jrp';")
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">var seq int
        for rows.Next() </span><span class="cov8" title="1">{
                if err := rows.Scan(&amp;seq); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">return seq, deferErr</span>
}

// IsExist checks if jrp exists.
func (j *JrpChecker) IsExist(jrpDBFilePath string, id int) (bool, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        <span class="cov8" title="1">rows, err := db.Query("SELECT COUNT(*) FROM jrp WHERE jrp.ID = (?);", j.StrconvProxy.Itoa(id))
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">var count int
        for rows.Next() </span><span class="cov8" title="1">{
                if err := rows.Scan(&amp;count); err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return count == 1, deferErr</span>
}

// IsFavorited checks if jrp is favorited.
func (j *JrpChecker) IsFavorited(jrpDBFilePath string, id int) (bool, error) <span class="cov8" title="1">{
        var deferErr error
        db, err := j.SqlProxy.Open(sqlproxy.Sqlite, jrpDBFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = db.Close()
        }</span>()

        <span class="cov8" title="1">rows, err := db.Query("SELECT COUNT(*) FROM jrp WHERE jrp.IsFavorite = 1 AND jrp.ID = (?);", j.StrconvProxy.Itoa(id))
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                deferErr = rows.Close()
        }</span>()

        <span class="cov8" title="1">var count int
        for rows.Next() </span><span class="cov8" title="1">{
                if err := rows.Scan(&amp;count); err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return count == 1, deferErr</span>
}

// IsSameJrps checks if jrps are the same.
func (j *JrpChecker) IsSameJrps(got, want []*model.Jrp) bool <span class="cov8" title="1">{
        if len(got) != len(want) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range got </span><span class="cov8" title="1">{
                if got[i].IsFavorited == 1 </span><span class="cov8" title="1">{
                        if got[i].ID != want[i].ID ||
                                got[i].Phrase != want[i].Phrase ||
                                !isSameNullStringInstance(got[i].Prefix, want[i].Prefix) ||
                                !isSameNullStringInstance(got[i].Suffix, want[i].Suffix) ||
                                got[i].IsFavorited != want[i].IsFavorited ||
                                !isSameTimeInstance(got[i].CreatedAt, want[i].CreatedAt) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }

                <span class="cov8" title="1">if got[i].ID != want[i].ID ||
                        got[i].Phrase != want[i].Phrase ||
                        !isSameNullStringInstance(got[i].Prefix, want[i].Prefix) ||
                        !isSameNullStringInstance(got[i].Suffix, want[i].Suffix) ||
                        got[i].IsFavorited != want[i].IsFavorited ||
                        !isSameTimeInstance(got[i].CreatedAt, want[i].CreatedAt) ||
                        !isSameTimeInstance(got[i].UpdatedAt, want[i].UpdatedAt) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// isSameNullStringInstance checks if NullStringInstance is the same.
func isSameNullStringInstance(a, b *sqlproxy.NullStringInstance) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return a.FieldNullString.String == b.FieldNullString.String</span>
}

// isSameTimeInstance checks if TimeInstance is the same.
func isSameTimeInstance(a, b *timeproxy.TimeInstance) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return a.FieldTime.Equal(b.FieldTime)</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package testutility

import (
        "strings"
)

const (
        // TEST_OUTPUT_STDOUT is a constant for stdout
        TEST_OUTPUT_ANY = "ANY"
)

// ReplaceDoubleSlashToSingleSlash replaces double slash to single slash
func ReplaceDoubleSlashToSingleSlash(input string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(input, "//", "/")
}</span>

// RemoveTabAndSpaceAndLf removes tab, space, and line feed
func RemoveTabAndSpaceAndLf(input string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(input, "\t", ""), " ", ""), "\n", "")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
